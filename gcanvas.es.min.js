var __defProp=Object.defineProperty,__defNormalProp=(t,i,e)=>i in t?__defProp(t,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[i]=e,__publicField=(t,i,e)=>__defNormalProp(t,"symbol"!=typeof i?i+"":i,e);class Painter{static init(t){Painter.ctx=t}static save(){Painter.ctx.save()}static restore(){Painter.ctx.restore()}static clear(t=0,i=0,e=Painter.ctx.canvas.width,s=Painter.ctx.canvas.height){Painter.ctx.clearRect(t,i,e,s)}static translate(t,i){Painter.ctx.translate(t,i)}static rotate(t){Painter.ctx.rotate(t)}static scale(t,i){Painter.ctx.scale(t,i)}static fillRect(t,i,e,s,o){o&&(Painter.ctx.fillStyle=o),Painter.ctx.fillRect(t,i,e,s)}static strokeRect(t,i,e,s,o,n){o&&(Painter.ctx.strokeStyle=o),void 0!==n&&(Painter.ctx.lineWidth=n),Painter.ctx.strokeRect(t,i,e,s)}static fillCircle(t,i,e,s){Painter.ctx.beginPath(),Painter.ctx.arc(t,i,e,0,2*Math.PI),s&&(Painter.ctx.fillStyle=s),Painter.ctx.fill()}static strokeCircle(t,i,e,s,o){Painter.ctx.beginPath(),Painter.ctx.arc(t,i,e,0,2*Math.PI),s&&(Painter.ctx.strokeStyle=s),void 0!==o&&(Painter.ctx.lineWidth=o),Painter.ctx.stroke()}static fillEllipse(t,i,e,s,o=0,n){Painter.ctx.beginPath(),Painter.ctx.ellipse(t,i,e,s,o,0,2*Math.PI),n&&(Painter.ctx.fillStyle=n),Painter.ctx.fill()}static path(t,i,e,s=1){const o=Painter.ctx;o.beginPath();for(const i of t){const[t,...e]=i;"M"===t?o.moveTo(...e):"L"===t?o.lineTo(...e):"C"===t?o.bezierCurveTo(...e):"Q"===t?o.quadraticCurveTo(...e):"Z"===t&&o.closePath()}i&&(o.fillStyle=i,o.fill()),e&&(o.strokeStyle=e,o.lineWidth=s,o.stroke())}static strokeEllipse(t,i,e,s,o=0,n,r){Painter.ctx.beginPath(),Painter.ctx.ellipse(t,i,e,s,o,0,2*Math.PI),n&&(Painter.ctx.strokeStyle=n),void 0!==r&&(Painter.ctx.lineWidth=r),Painter.ctx.stroke()}static line(t,i,e,s,o,n){Painter.ctx.beginPath(),Painter.ctx.moveTo(t,i),Painter.ctx.lineTo(e,s),o&&(Painter.ctx.strokeStyle=o),void 0!==n&&(Painter.ctx.lineWidth=n),Painter.ctx.stroke()}static beginPath(){Painter.ctx.beginPath()}static moveTo(t,i){Painter.ctx.moveTo(t,i)}static lineTo(t,i){Painter.ctx.lineTo(t,i)}static bezierCurveTo(t,i,e,s,o,n){Painter.ctx.bezierCurveTo(t,i,e,s,o,n)}static closePath(){Painter.ctx.closePath()}static fill(t){t&&(Painter.ctx.fillStyle=t),Painter.ctx.fill()}static strokeOptions(t){t.color&&(Painter.ctx.strokeStyle=t.color),void 0!==t.lineWidth&&(Painter.ctx.lineWidth=t.lineWidth),t.lineCap&&(Painter.ctx.lineCap=t.lineCap),t.lineJoin&&(Painter.ctx.lineJoin=t.lineJoin),t.strokeStyle&&(Painter.ctx.strokeStyle=t.strokeStyle)}static stroke(t,i){t&&(Painter.ctx.strokeStyle=t),void 0!==i&&(Painter.ctx.lineWidth=i),Painter.ctx.stroke()}static polygon(t,i,e,s){if(!(t.length<2)){Painter.ctx.beginPath(),Painter.ctx.moveTo(t[0].x,t[0].y);for(let i=1;i<t.length;i++)Painter.ctx.lineTo(t[i].x,t[i].y);Painter.ctx.closePath(),i&&(Painter.ctx.fillStyle=i,Painter.ctx.fill()),e&&(Painter.ctx.strokeStyle=e,void 0!==s&&(Painter.ctx.lineWidth=s),Painter.ctx.stroke())}}static heart(t,i,e,s,o="#FF0055"){const n=e/2;Painter.ctx.save(),Painter.ctx.translate(t,i),Painter.ctx.beginPath(),Painter.ctx.moveTo(0,.3*s),Painter.ctx.bezierCurveTo(.5*-n,.3*-s,-n,.6*-s,0,-s),Painter.ctx.bezierCurveTo(n,.6*-s,.5*n,.3*-s,0,.3*s),Painter.ctx.closePath(),Painter.ctx.fillStyle=o,Painter.ctx.fill(),Painter.ctx.restore()}static setFont(t){Painter.ctx.font=t}static setTextAlign(t){Painter.ctx.textAlign=t}static setTextBaseline(t){Painter.ctx.textBaseline=t}static fillText(t,i,e,s,o){s&&(Painter.ctx.fillStyle=s),o&&(Painter.ctx.font=o),Painter.ctx.fillText(t,i,e)}static strokeText(t,i,e,s,o,n){s&&(Painter.ctx.strokeStyle=s),void 0!==o&&(Painter.ctx.lineWidth=o),n&&(Painter.ctx.font=n),Painter.ctx.strokeText(t,i,e)}static measureText(t){return Painter.ctx.measureText(t).width}static setFillColor(t){Painter.ctx.fillStyle=t}static setStrokeColor(t){Painter.ctx.strokeStyle=t}static setLineWidth(t){Painter.ctx.lineWidth=t}static rgba(t,i,e,s=1){return`rgba(${Math.round(t)}, ${Math.round(i)}, ${Math.round(e)}, ${s})`}static hsl(t,i,e){return`hsl(${t}, ${i}%, ${e}%)`}static hsla(t,i,e,s){return`hsla(${t}, ${i}%, ${e}%, ${s})`}static linearGradient(t,i,e,s,o){const n=Painter.ctx.createLinearGradient(t,i,e,s);for(const t of o)n.addColorStop(t.offset,t.color);return n}static radialGradient(t,i,e,s,o,n,r){const a=Painter.ctx.createRadialGradient(t,i,e,s,o,n);for(const t of r)a.addColorStop(t.offset,t.color);return a}static verticalGradient(t,i,e,s,o){return Painter.linearGradient(t,i,t,i+s,o)}static horizontalGradient(t,i,e,s,o){return Painter.linearGradient(t,i,t+e,i,o)}static hslToRgb(t,i,e){i/=100,e/=100;const s=(1-Math.abs(2*e-1))*i,o=s*(1-Math.abs(t/60%2-1)),n=e-s/2;let r,a,h;return[r,a,h]=t<60?[s,o,0]:t<120?[o,s,0]:t<180?[0,s,o]:t<240?[0,o,s]:t<300?[o,0,s]:[s,0,o],[Math.round(255*(r+n)),Math.round(255*(a+n)),Math.round(255*(h+n))]}static setShadow(t,i,e=0,s=0){Painter.ctx.shadowColor=t,Painter.ctx.shadowBlur=i,Painter.ctx.shadowOffsetX=e,Painter.ctx.shadowOffsetY=s}static clearShadow(){Painter.ctx.shadowColor="rgba(0, 0, 0, 0)",Painter.ctx.shadowBlur=0,Painter.ctx.shadowOffsetX=0,Painter.ctx.shadowOffsetY=0}static setAlpha(t){Painter.ctx.globalAlpha=t}static setBlendMode(t){Painter.ctx.globalCompositeOperation=t}}const _Mouse=class t{static init(i){t.game=i,t.canvas=i.canvas,t.x=0,t.y=0,t.leftDown=!1,t.middleDown=!1,t.rightDown=!1,t.canvas.addEventListener("mousemove",t._onMove),t.canvas.addEventListener("mousedown",t._onDown),t.canvas.addEventListener("mouseup",t._onUp),t.canvas.addEventListener("click",t._onClick),t.canvas.addEventListener("wheel",t._onWheel)}static _updatePosition(i){const e=t.canvas.getBoundingClientRect();t.x=i.clientX-e.left,t.y=i.clientY-e.top}};__publicField(_Mouse,"_onMove",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("mousemove",t)})),__publicField(_Mouse,"_onDown",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!0),1===t.button&&(_Mouse.middleDown=!0),2===t.button&&(_Mouse.rightDown=!0),_Mouse.game.events.emit("mousedown",t)})),__publicField(_Mouse,"_onUp",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!1),1===t.button&&(_Mouse.middleDown=!1),2===t.button&&(_Mouse.rightDown=!1),_Mouse.game.events.emit("mouseup",t)})),__publicField(_Mouse,"_onClick",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("click",t)})),__publicField(_Mouse,"_onWheel",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("wheel",t)}));let Mouse=_Mouse;const _Keys=class t{static init(i){t.game=i,window.addEventListener("keydown",t._onKeyDown),window.addEventListener("keyup",t._onKeyUp)}static isDown(i){return t._down.has(i)}static _onKeyDown(i){const e=t._codeMap[i.code];e&&(t._down.has(e)||(t._down.add(e),t.game.events.emit(e,i))),t.game.events.emit(i.type,i)}static _onKeyUp(i){const e=t._codeMap[i.code];e&&t._down.has(e)&&(t._down.delete(e),t.game.events.emit(e+"_up",i)),t.game.events.emit(i.type,i)}};__publicField(_Keys,"W","W"),__publicField(_Keys,"A","A"),__publicField(_Keys,"S","S"),__publicField(_Keys,"D","D"),__publicField(_Keys,"UP","UP"),__publicField(_Keys,"DOWN","DOWN"),__publicField(_Keys,"LEFT","LEFT"),__publicField(_Keys,"RIGHT","RIGHT"),__publicField(_Keys,"SPACE","SPACE"),__publicField(_Keys,"SHIFT","SHIFT"),__publicField(_Keys,"ENTER","ENTER"),__publicField(_Keys,"ESC","ESC"),__publicField(_Keys,"_codeMap",{KeyW:_Keys.W,KeyA:_Keys.A,KeyS:_Keys.S,KeyD:_Keys.D,ArrowUp:_Keys.UP,ArrowDown:_Keys.DOWN,ArrowLeft:_Keys.LEFT,ArrowRight:_Keys.RIGHT,Space:_Keys.SPACE,ShiftLeft:_Keys.SHIFT,ShiftRight:_Keys.SHIFT,Enter:_Keys.ENTER,NumpadEnter:_Keys.ENTER,Escape:_Keys.ESC}),__publicField(_Keys,"_down",new Set),__publicField(_Keys,"game",null);let Keys=_Keys;const _Touch=class t{static init(i){t.game=i,t.canvas=i.canvas,t.x=0,t.y=0,t.active=!1,t.canvas.addEventListener("touchstart",t._onStart),t.canvas.addEventListener("touchend",t._onEnd),t.canvas.addEventListener("touchmove",t._onMove)}static _updatePosition(i){const e=t.canvas.getBoundingClientRect();t.x=i.clientX-e.left,t.y=i.clientY-e.top}};__publicField(_Touch,"_onStart",(t=>{t.touches.length>0&&(_Touch.active=!0,_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchstart",t))})),__publicField(_Touch,"_onEnd",(t=>{_Touch.active=!1,_Touch.game.events.emit("touchend",t)})),__publicField(_Touch,"_onMove",(t=>{t.touches.length>0&&(_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchmove",t))}));let Touch=_Touch;const _Input=class t{static init(i){t.game=i,t.x=0,t.y=0,t.down=!1,i.events.on("mousedown",t._onDown),i.events.on("mouseup",t._onUp),i.events.on("mousemove",t._onMove),i.events.on("touchstart",t._onTouchStart),i.events.on("touchend",t._onTouchEnd),i.events.on("touchmove",t._onTouchMove)}static _setPosition(i,e){t.x=i,t.y=e}};__publicField(_Input,"_onDown",(t=>{_Input.down=!0,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onUp",(t=>{_Input.down=!1,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onMove",(t=>{_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputmove",t)})),__publicField(_Input,"_onTouchStart",(t=>{const i=t.touches[0],e=_Input.game.canvas.getBoundingClientRect();_Input.down=!0,_Input._setPosition(i.clientX-e.left,i.clientY-e.top),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onTouchEnd",(t=>{_Input.down=!1,_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onTouchMove",(t=>{const i=t.touches[0],e=_Input.game.canvas.getBoundingClientRect();_Input._setPosition(i.clientX-e.left,i.clientY-e.top),_Input.game.events.emit("inputmove",t)}));let Input=_Input;class EventEmitter{constructor(){this.listeners={}}on(t,i){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(i)}off(t,i){this.listeners[t]&&(this.listeners[t]=this.listeners[t].filter((t=>t!==i)))}emit(t,i){this.listeners[t]&&this.listeners[t].forEach((t=>t(i)))}}function applyAnchor(t,i={}){var e;t.anchor=i.anchor??null,t.padding=i.padding??10;const s=t.game,o=null==(e=t.update)?void 0:e.bind(t);t.update=function(i){if(t.anchor){const{x:i,y:e,align:o,baseline:n}=((t,i)=>{const e=s.width,o=s.height;switch(t){case"top-left":return{x:i,y:i,align:"left",baseline:"top"};case"top-right":return{x:e-i,y:i,align:"right",baseline:"top"};case"bottom-left":return{x:i,y:o-i,align:"left",baseline:"bottom"};case"bottom-right":return{x:e-i,y:o-i,align:"right",baseline:"bottom"};default:return{x:10,y:10,align:"left",baseline:"top"}}})(t.anchor,t.padding);t.x=i,t.y=e,"align"in t&&(t.align=o),"baseline"in t&&(t.baseline=n)}null==o||o(i)}}class Transformable{constructor(t={}){this.x=t.x??0,this.y=t.y??0,this.width=t.width??0,this.height=t.height??0,this.rotation=t.rotation??0,this.scaleX=t.scaleX??1,this.scaleY=t.scaleY??1,this.opacity=t.opacity??1,this.visible=void 0===t.visible||t.visible}}class Shape extends Transformable{constructor(t,i,e={}){super(e),this.x=t,this.y=i,this.fillColor=e.fillColor||null,this.strokeColor=e.strokeColor||null,this.lineWidth=e.lineWidth||1,this.shadowColor=e.shadowColor??null,this.shadowBlur=e.shadowBlur??0,this.shadowOffsetX=e.shadowOffsetX??0,this.shadowOffsetY=e.shadowOffsetY??0,this.minX=e.minX,this.maxX=e.maxX,this.minY=e.minY,this.maxY=e.maxY}applyConstraints(){void 0!==this.minX&&(this.x=Math.max(this.x,this.minX)),void 0!==this.maxX&&(this.x=Math.min(this.x,this.maxX)),void 0!==this.minY&&(this.y=Math.max(this.y,this.minY)),void 0!==this.maxY&&(this.y=Math.min(this.y,this.maxY))}draw(){throw new Error("Shape.draw() must be implemented by subclass")}renderWithTransform(t){this.visible&&(Painter.ctx.save(),Painter.ctx.globalAlpha=this.opacity,Painter.ctx.translate(this.x,this.y),Painter.ctx.rotate(this.rotation),Painter.ctx.scale(this.scaleX,this.scaleY),t(),Painter.ctx.restore())}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class Arc extends Shape{constructor(t,i,e,s,o,n={}){super(t,i,n),this.radius=e,this.startAngle=s,this.endAngle=o}draw(){this.applyConstraints(),this.renderWithTransform((()=>{const t=Painter.ctx;t.beginPath(),t.arc(0,0,this.radius,this.startAngle,this.endAngle,!1),this.strokeColor&&(t.strokeStyle=this.strokeColor,t.lineWidth=this.lineWidth,t.stroke())}))}getBounds(){const t=this.radius;return{x:this.x,y:this.y,width:2*t,height:2*t}}}class Circle extends Shape{constructor(t,i,e,s={}){super(t,i,s),this.radius=e}draw(){this.applyConstraints(),this.renderWithTransform((()=>{this.fillColor&&Painter.fillCircle(0,0,this.radius,this.fillColor),this.strokeColor&&Painter.strokeCircle(0,0,this.radius,this.strokeColor,this.lineWidth)}))}getBounds(){const t=2*this.radius;return{x:this.x,y:this.y,width:t,height:t}}}class Cloud extends Shape{constructor(t,i,e=40,s={}){super(t,i,s),this.size=e}draw(){this.applyConstraints();const t=this.size,i=[["M",-t,0],["C",-t,-t,0,-t,0,0],["C",0,1.2*-t,1.2*t,-t,t,0],["C",1.5*t,.5*t,.5*t,1.2*t,0,t],["C",.8*-t,1.3*t,1.2*-t,.3*t,-t,0],["Z"]];this.renderWithTransform((()=>{Painter.path(i,this.fillColor,this.strokeColor,this.lineWidth)}))}getBounds(){const t=2*this.size;return{x:this.x,y:this.y,width:t,height:t}}}class BezierShape extends Shape{constructor(t,i,e=[],s={}){super(t,i,s),this.path=e}draw(){this.applyConstraints(),this.renderWithTransform((()=>{Painter.path(this.path,this.fillColor,this.strokeColor,this.lineWidth)}))}getBounds(){return{x:this.x,y:this.y,width:100,height:100}}}class Rectangle extends Shape{constructor(t,i,e,s,o={}){super(t,i,o),this.width=e,this.height=s}draw(){this.applyConstraints(),this.renderWithTransform((()=>{const t=-this.width/2,i=-this.height/2;this.fillColor&&Painter.fillRect(t,i,this.width,this.height,this.fillColor),this.strokeColor&&Painter.strokeRect(t,i,this.width,this.height,this.strokeColor,this.lineWidth)}))}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class Square extends Rectangle{constructor(t,i,e,s={}){super(t,i,e,e,s)}}class Cube extends Shape{constructor(t,i,e=50,s={}){super(t,i,s),this.size=e,this.faceTopColor=s.faceTopColor||"#eee",this.faceBottomColor=s.faceBottomColor||"#ccc",this.faceLeftColor=s.faceLeftColor||"#aaa",this.faceRightColor=s.faceRightColor||"#888",this.faceFrontColor=s.faceFrontColor||"#666",this.faceBackColor=s.faceBackColor||"#444",this.strokeColor=s.strokeColor||null,this.lineWidth=s.lineWidth||1,this.rotationX=s.rotationX||0,this.rotationY=s.rotationY||0,this.rotationZ=s.rotationZ||0,this.visibleFaces=s.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,i,e){return this.rotationX=t,this.rotationY=i,this.rotationZ=e,this}rotate(t,i,e){return this.rotationX+=t,this.rotationY+=i,this.rotationZ+=e,this}draw(){this.applyConstraints();const t=this.size/2,i=(t,i,e)=>{let s=i,o=e;i=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=e=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),e=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=i,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:i=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:e}},e=(t,e,s)=>{const o=i(t,e,s);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z}},s={p0:e(-t,-t,-t),p1:e(t,-t,-t),p2:e(t,t,-t),p3:e(-t,t,-t),p4:e(-t,-t,t),p5:e(t,-t,t),p6:e(t,t,t),p7:e(-t,t,t)},o={top:{points:[s.p4,s.p5,s.p6,s.p7],color:this.faceTopColor,normal:[0,0,1]},bottom:{points:[s.p0,s.p1,s.p2,s.p3],color:this.faceBottomColor,normal:[0,0,-1]},left:{points:[s.p0,s.p4,s.p7,s.p3],color:this.faceLeftColor,normal:[-1,0,0]},right:{points:[s.p1,s.p5,s.p6,s.p2],color:this.faceRightColor,normal:[1,0,0]},front:{points:[s.p0,s.p1,s.p5,s.p4],color:this.faceFrontColor,normal:[0,-1,0]},back:{points:[s.p3,s.p2,s.p6,s.p7],color:this.faceBackColor,normal:[0,1,0]}},n=this.visibleFaces.map((t=>{const i=o[t];if(!i)return null;const e=i.points.reduce(((t,i)=>({x:t.x+i.x,y:t.y+i.y})),{x:0,y:0});e.x/=i.points.length,e.y/=i.points.length;return{key:t,face:i,depth:e.x*e.x+e.y*e.y}})).filter((t=>null!==t)).sort(((t,i)=>i.depth-t.depth));this.renderWithTransform((()=>{n.forEach((({key:t,face:i})=>{(null==i?void 0:i.color)&&Painter.polygon(i.points,i.color,this.strokeColor,this.lineWidth)}))}))}getBounds(){const t=1.5*this.size;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cone extends Shape{constructor(t,i,e=50,s=100,o={}){super(t,i,o),this.radius=e,this.height=s,this.segments=o.segments||24,this.bottomColor=o.bottomColor||"#eee",this.sideColor=o.sideColor||"#aaa",this.strokeColor=o.strokeColor||null,this.lineWidth=o.lineWidth||1,this.rotationX=o.rotationX||0,this.rotationY=o.rotationY||0,this.rotationZ=o.rotationZ||0,this.visibleFaces=o.visibleFaces||["bottom","side"]}setRotation(t,i,e){return this.rotationX=t,this.rotationY=i,this.rotationZ=e,this}rotate(t,i,e){return this.rotationX+=t,this.rotationY+=i,this.rotationZ+=e,this}draw(){this.applyConstraints();const t=this.radius,i=this.height/2,e=(t,i,e)=>{let s=i,o=e;i=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=e=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),e=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=i,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:i=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:e}},s=(t,i,s)=>{const o=e(t,i,s);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z,z:o.z}},o=s(0,0,i),n=[],r=2*Math.PI/this.segments;for(let e=0;e<this.segments;e++){const o=e*r,a=Math.cos(o)*t,h=Math.sin(o)*t;n.push(s(a,h,-i))}const a=[];for(let t=0;t<this.segments;t++){const i=(t+1)%this.segments;a.push({points:[o,n[t],n[i]],z:(o.z+n[t].z+n[i].z)/3})}const h=[];this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...n].reverse(),z:-i}),this.visibleFaces.includes("side")&&h.push(...a.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,i)=>i.z-t.z)),this.renderWithTransform((()=>{for(const t of h){const i="bottom"===t.type?this.bottomColor:this.sideColor;Painter.polygon(t.points,i,this.strokeColor,this.lineWidth)}}))}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Prism extends Shape{constructor(t,i,e=80,s=60,o=100,n={}){super(t,i,n),this.width=e,this.height=s,this.depth=o,this.faceTopColor=n.faceTopColor||"#eee",this.faceBottomColor=n.faceBottomColor||"#ccc",this.faceLeftColor=n.faceLeftColor||"#aaa",this.faceRightColor=n.faceRightColor||"#888",this.faceFrontColor=n.faceFrontColor||"#666",this.faceBackColor=n.faceBackColor||"#444",this.strokeColor=n.strokeColor||null,this.lineWidth=n.lineWidth||1,this.rotationX=n.rotationX||0,this.rotationY=n.rotationY||0,this.rotationZ=n.rotationZ||0,this.visibleFaces=n.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,i,e){return this.rotationX=t,this.rotationY=i,this.rotationZ=e,this}rotate(t,i,e){return this.rotationX+=t,this.rotationY+=i,this.rotationZ+=e,this}draw(){this.applyConstraints();const t=this.width/2,i=this.height/2,e=this.depth/2,s=(t,i,e)=>{let s=i,o=e;i=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=e=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),e=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=i,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:i=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:e}},o=(t,i,e)=>{const o=s(t,i,e);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z,z:o.z}},n={p0:o(-t,-e,-i),p1:o(t,-e,-i),p2:o(0,-e,i),p3:o(-t,e,-i),p4:o(t,e,-i),p5:o(0,e,i)},r={front:{points:[n.p0,n.p1,n.p2],color:this.faceFrontColor},back:{points:[n.p3,n.p4,n.p5],color:this.faceBackColor},bottom:{points:[n.p0,n.p1,n.p4,n.p3],color:this.faceBottomColor},right:{points:[n.p1,n.p2,n.p5,n.p4],color:this.faceRightColor},left:{points:[n.p0,n.p2,n.p5,n.p3],color:this.faceLeftColor}},a=this.visibleFaces.filter((t=>r[t])).map((t=>{const i=r[t],e=i.points.reduce(((t,i)=>t+i.x),0)/i.points.length,s=i.points.reduce(((t,i)=>t+i.y),0)/i.points.length,o=i.points.reduce(((t,i)=>t+(i.z||0)),0)/i.points.length;return{key:t,face:i,depth:e*e+s*s+o*o}})).sort(((t,i)=>i.depth-t.depth));this.renderWithTransform((()=>{a.forEach((({key:t,face:i})=>{(null==i?void 0:i.color)&&Painter.polygon(i.points,i.color,this.strokeColor,this.lineWidth)}))}))}getBounds(){const t=1.5*Math.max(this.width,this.height,this.depth);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cylinder extends Shape{constructor(t,i,e=40,s=80,o={}){super(t,i,o),this.radius=e,this.height=s,this.segments=o.segments||24,this.topColor=o.topColor||"#FF00FF",this.bottomColor=o.bottomColor||"#FF0FFF",this.sideColor=o.sideColor||"#00FF00",this.strokeColor=o.strokeColor||"#000000",this.lineWidth=o.lineWidth||1,this.rotationX=o.rotationX||0,this.rotationY=o.rotationY||0,this.rotationZ=o.rotationZ||0,this.visibleFaces=o.visibleFaces||["top","bottom","side"]}setRotation(t,i,e){return this.rotationX=t,this.rotationY=i,this.rotationZ=e,this}rotate(t,i,e){return this.rotationX+=t,this.rotationY+=i,this.rotationZ+=e,this}draw(){this.applyConstraints();const t=this.radius,i=this.height/2,e=(t,i,e)=>{let s=i,o=e;i=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=e=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),e=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=i,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:i=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:e}},s=(t,i,s)=>{const o=e(t,i,s);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z,z:o.z}},o=[],n=[],r=2*Math.PI/this.segments;for(let e=0;e<this.segments;e++){const a=e*r,h=Math.cos(a)*t,l=Math.sin(a)*t;o.push(s(h,l,i)),n.push(s(h,l,-i))}const a=[];for(let t=0;t<this.segments;t++){const i=(t+1)%this.segments;a.push({points:[n[t],n[i],o[i],o[t]],z:(o[t].z+o[i].z+n[t].z+n[i].z)/4})}const h=[];this.visibleFaces.includes("top")&&h.push({type:"top",points:o,z:i}),this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...n].reverse(),z:-i}),this.visibleFaces.includes("side")&&h.push(...a.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,i)=>i.z-t.z)),this.renderWithTransform((()=>{for(const t of h){let i;switch(t.type){case"top":i=this.topColor;break;case"bottom":i=this.bottomColor;break;case"side":i=this.sideColor}Painter.polygon(t.points,i,this.strokeColor,this.lineWidth)}}))}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Diamond extends Shape{constructor(t,i,e,s,o={}){super(t,i,o),this.width=e,this.height=s}draw(){this.applyConstraints(),this.renderWithTransform((()=>{const t=this.width/2,i=this.height/2,e=[{x:0,y:-i},{x:t,y:0},{x:0,y:i},{x:-t,y:0}];Painter.polygon(e,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Line extends Shape{constructor(t,i,e=40,s={}){super(t,i,s),this.length=e}draw(){this.applyConstraints();const t=this.length/2;this.renderWithTransform((()=>{Painter.line(-t,-t,t,t,this.strokeColor,this.lineWidth)}))}}class Triangle extends Shape{constructor(t,i,e=50,s={}){super(t,i,s),this.size=e}draw(){this.applyConstraints();const t=this.size/2,i=[{x:0,y:-t},{x:t,y:t},{x:-t,y:t}];this.renderWithTransform((()=>{Painter.polygon(i,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Star extends Shape{constructor(t,i,e=40,s=5,o=.5,n={}){super(t,i,n),this.radius=e,this.spikes=s,this.inset=o}draw(){this.applyConstraints();const t=Math.PI/this.spikes,i=-Math.PI/2;this.renderWithTransform((()=>{Painter.ctx.beginPath();for(let e=0;e<2*this.spikes;e++){const s=e%2==0?this.radius:this.radius*this.inset,o=e*t+i,n=Math.cos(o)*s,r=Math.sin(o)*s;0===e?Painter.ctx.moveTo(n,r):Painter.ctx.lineTo(n,r)}Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Sphere extends Shape{constructor(t,i,e=50,s={}){super(t,i,s),this.radius=e,this.hSegments=s.hSegments||16,this.vSegments=s.vSegments||12,this.color=s.color||"#6495ED",this.highlightColor=s.highlightColor||"#FFFFFF",this.wireframe=s.wireframe||!1,this.strokeColor=s.strokeColor||"#333333",this.lineWidth=s.lineWidth||1,this.rotationX=s.rotationX||0,this.rotationY=s.rotationY||0,this.rotationZ=s.rotationZ||0}setRotation(t,i,e){return this.rotationX=t,this.rotationY=i,this.rotationZ=e,this}rotate(t,i,e){return this.rotationX+=t,this.rotationY+=i,this.rotationZ+=e,this}calculateSurfaceColor(t,i,e){let s=t*(1/Math.sqrt(3))+i*(1/Math.sqrt(3))+e*(1/Math.sqrt(3));if(s=Math.max(.3,s),this.highlightColor){const t=this.hexToRgb(this.color),i=this.hexToRgb(this.highlightColor);return`rgb(${Math.round(t.r*(1-s)+i.r*s)}, ${Math.round(t.g*(1-s)+i.g*s)}, ${Math.round(t.b*(1-s)+i.b*s)})`}const o=this.hexToRgb(this.color);return`rgb(${Math.min(255,Math.round(o.r*s))}, ${Math.min(255,Math.round(o.g*s))}, ${Math.min(255,Math.round(o.b*s))})`}hexToRgb(t){const i={r:100,g:100,b:255};if(!t||"string"!=typeof t)return i;const e=t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,((t,i,e,s)=>i+i+e+e+s+s)),s=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return s?{r:parseInt(s[1],16),g:parseInt(s[2],16),b:parseInt(s[3],16)}:i}draw(){this.applyConstraints();const t=this.radius,i=(t,i,e)=>{let s=i,o=e;i=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=e=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),e=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=i,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:i=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:e}},e=(e,s,o)=>{const n=i(e,s,o);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z,nx:n.x/t,ny:n.y/t,nz:n.z/t}},s=[];for(let i=0;i<=this.vSegments;i++){const o=[],n=i/this.vSegments,r=Math.PI*n-Math.PI/2;for(let i=0;i<=this.hSegments;i++){const s=i/this.hSegments,n=2*Math.PI*s,a=t*Math.cos(r)*Math.cos(n),h=t*Math.cos(r)*Math.sin(n),l=t*Math.sin(r);o.push(e(a,h,l))}s.push(o)}const o=[];for(let t=0;t<this.vSegments;t++)for(let i=0;i<this.hSegments;i++){const e=s[t][i],n=s[t][i+1],r=s[t+1][i],a=s[t+1][i+1],h=(e.z+n.z+r.z+a.z)/4,l=(e.nx+n.nx+r.nx+a.nx)/4,c=(e.ny+n.ny+r.ny+a.ny)/4,d=(e.nz+n.nz+r.nz+a.nz)/4;o.push({points:[e,n,a,r],z:h,color:this.calculateSurfaceColor(l,c,d)})}o.sort(((t,i)=>i.z-t.z)),this.renderWithTransform((()=>{if(this.wireframe)for(const t of o){const i=t.points;for(let t=0;t<i.length;t++){const e=(t+1)%i.length;Painter.line(i[t].x,i[t].y,i[e].x,i[e].y,this.strokeColor,this.lineWidth)}}else for(const t of o)Painter.polygon(t.points,t.color,this.strokeColor,this.lineWidth)}))}getBounds(){const t=2*this.radius*1.5;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class StickFigure extends Shape{constructor(t,i,e=1,s={}){super(t,i,s),this.scale=e,this.strokeColor=s.strokeColor||"#000",this.headColor=s.headColor||this.strokeColor,this.jointColor=s.jointColor||this.strokeColor,this.lineWidth=s.lineWidth||2,this.showJoints=!1!==s.showJoints}draw(){this.applyConstraints();const t=this.scale,i=10*t,e=-30*t,s=e+i,o=s+40*t,n=s+10*t,r=15*t,a=10*t,h=o+40*t,l=3*t;this.renderWithTransform((()=>{if(Painter.fillCircle(0,e,i,this.headColor),Painter.strokeCircle(0,e,i,this.strokeColor,this.lineWidth),Painter.line(0,s,0,o,this.strokeColor,this.lineWidth),Painter.line(-r,n,r,n,this.strokeColor,this.lineWidth),Painter.line(0,o,-a,h,this.strokeColor,this.lineWidth),Painter.line(0,o,a,h,this.strokeColor,this.lineWidth),this.showJoints){[[0,s],[-r,n],[r,n],[0,o],[-a,h],[a,h]].forEach((([t,i])=>Painter.fillCircle(t,i,l,this.jointColor)))}}))}getBounds(){const t=100*this.scale,i=40*this.scale;return{x:this.x,y:this.y,width:i,height:t}}}class Ring extends Shape{constructor(t,i,e,s,o={}){super(t,i,o),this.outerRadius=e,this.innerRadius=s}draw(){this.applyConstraints(),this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.arc(0,0,this.outerRadius,0,2*Math.PI),Painter.ctx.arc(0,0,this.innerRadius,0,2*Math.PI,!0),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Polygon extends Shape{constructor(t,i,e=6,s=40,o={}){super(t,i,o),this.sides=e,this.radius=s}draw(){this.applyConstraints();const t=[],i=2*Math.PI/this.sides;for(let e=0;e<this.sides;e++){const s=e*i;t.push({x:Math.cos(s)*this.radius,y:Math.sin(s)*this.radius})}this.renderWithTransform((()=>{Painter.polygon(t,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Arrow extends Shape{constructor(t,i,e,s,o={}){super(t,i,o),this.length=e,this.width=s}draw(){this.applyConstraints();const t=this.width/2,i=.4*this.length,e=this.length-i;this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.moveTo(-e/2,-t),Painter.ctx.lineTo(e/2,-t),Painter.ctx.lineTo(e/2,-this.width),Painter.ctx.lineTo(this.length/2,0),Painter.ctx.lineTo(e/2,this.width),Painter.ctx.lineTo(e/2,t),Painter.ctx.lineTo(-e/2,t),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Pin extends Shape{constructor(t,i,e=20,s={}){super(t,i,s),this.radius=e}draw(){this.applyConstraints();const t=this.radius,i=2.5*t;this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.arc(0,0,t,Math.PI,0),Painter.ctx.lineTo(t,0),Painter.ctx.lineTo(0,i),Painter.ctx.lineTo(-t,0),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}getBounds(){return{x:this.x,y:this.y+.98*this.radius,width:2*this.radius,height:2.5*this.radius}}}class PieSlice extends Shape{constructor(t,i,e,s,o,n={}){super(t,i,n),this.radius=e,this.startAngle=s,this.endAngle=o}draw(){this.applyConstraints(),this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.moveTo(0,0),Painter.ctx.arc(0,0,this.radius,this.startAngle,this.endAngle),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Hexagon extends Shape{constructor(t,i,e,s={}){super(t,i,s),this.radius=e}draw(){this.applyConstraints();const t=Array.from({length:6},((t,i)=>{const e=Math.PI/3*i;return{x:Math.cos(e)*this.radius,y:Math.sin(e)*this.radius}}));this.renderWithTransform((()=>{Painter.polygon(t,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Heart extends Shape{constructor(t,i,e=50,s=50,o={}){super(t,i,o),this.width=e,this.height=s}draw(){this.applyConstraints();const t=this.width,i=this.height,e=.3*i;this.renderWithTransform((()=>{const s=Painter.ctx;s.beginPath(),s.moveTo(0,e),s.bezierCurveTo(0,0,-t/2,0,-t/2,e),s.bezierCurveTo(-t/2,.8*i,0,i,0,i),s.bezierCurveTo(0,i,t/2,.8*i,t/2,e),s.bezierCurveTo(t/2,0,0,0,0,e),s.closePath(),this.fillColor&&(s.fillStyle=this.fillColor,s.fill()),this.strokeColor&&(s.strokeStyle=this.strokeColor,s.lineWidth=this.lineWidth,s.stroke())}))}getBounds(){return{x:this.x,y:this.y+this.height/2,width:this.width,height:this.height}}}class Cross extends Shape{constructor(t,i,e,s,o={}){super(t,i,o),this.size=e,this.thickness=s,this.diagonal=o.diagonal||!1}draw(){this.applyConstraints(),this.renderWithTransform((()=>{const t=this.size/2,i=this.thickness/2;this.diagonal?(Painter.ctx.beginPath(),Painter.ctx.moveTo(-t,-t+i),Painter.ctx.lineTo(-t+i,-t),Painter.ctx.lineTo(0,-i),Painter.ctx.lineTo(t-i,-t),Painter.ctx.lineTo(t,-t+i),Painter.ctx.lineTo(i,0),Painter.ctx.lineTo(t,t-i),Painter.ctx.lineTo(t-i,t),Painter.ctx.lineTo(0,i),Painter.ctx.lineTo(-t+i,t),Painter.ctx.lineTo(-t,t-i),Painter.ctx.lineTo(-i,0),Painter.ctx.closePath()):(Painter.ctx.beginPath(),Painter.ctx.moveTo(-i,-t),Painter.ctx.lineTo(i,-t),Painter.ctx.lineTo(i,-i),Painter.ctx.lineTo(t,-i),Painter.ctx.lineTo(t,i),Painter.ctx.lineTo(i,i),Painter.ctx.lineTo(i,t),Painter.ctx.lineTo(-i,t),Painter.ctx.lineTo(-i,i),Painter.ctx.lineTo(-t,i),Painter.ctx.lineTo(-t,-i),Painter.ctx.lineTo(-i,-i),Painter.ctx.closePath()),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Group extends Shape{constructor(t,i,e={}){super(t,i,e),this.children=[]}add(t){this.children=[...this.children,t]}remove(t){this.children=this.children.filter((i=>i!==t))}removeMutable(t){const i=this.children.indexOf(t);-1!==i&&this.children.splice(i,1)}clear(){this.children=[]}draw(){this.renderWithTransform((()=>{this.children.forEach((t=>t.draw()))}))}getBounds(){if(0===this.children.length)return null;const t=this.children.map((t=>{const i="function"==typeof t.getBounds?t.getBounds():null;if(!i)return null;const e=i.width/2,s=i.height/2;return{minX:i.x-e,maxX:i.x+e,minY:i.y-s,maxY:i.y+s}})).filter((t=>null!==t));if(0===t.length)return null;const i=Math.min(...t.map((t=>t.minX))),e=Math.max(...t.map((t=>t.maxX))),s=Math.min(...t.map((t=>t.minY))),o=e-i,n=Math.max(...t.map((t=>t.maxY)))-s,r=i+o/2,a=s+n/2;return{x:this.x+r,y:this.y+a,width:o,height:n}}}class TextShape extends Shape{constructor(t,i,e,s={}){super(t,i,s),this.text=e,this.font=s.font||"12px monospace",this.color=s.color||"#000",this.align=s.align||"center",this.baseline=s.baseline||"top"}draw(){this.applyConstraints(),this.renderWithTransform((()=>{Painter.setFont(this.font),Painter.setTextAlign(this.align),Painter.setTextBaseline(this.baseline),Painter.fillText(this.text,0,0,this.color)}))}getBounds(){return this.width=Painter.measureText(this.text),{x:this.x,y:this.y,width:this.width,height:parseInt(this.font)}}}const index=Object.freeze(Object.defineProperty({__proto__:null,Arc:Arc,Arrow:Arrow,BezierShape:BezierShape,Circle:Circle,Cloud:Cloud,Cone:Cone,Cross:Cross,Cube:Cube,Cylinder:Cylinder,Diamond:Diamond,Group:Group,Heart:Heart,Hexagon:Hexagon,Line:Line,PieSlice:PieSlice,Pin:Pin,Polygon:Polygon,Prism:Prism,Rectangle:Rectangle,Ring:Ring,Shape:Shape,Sphere:Sphere,Square:Square,Star:Star,StickFigure:StickFigure,TextShape:TextShape,Transformable:Transformable,Triangle:Triangle},Symbol.toStringTag,{value:"Module"}));class GameObject extends Transformable{constructor(t,i={}){super(i),this.game=t,this.ctx=t.ctx,this.active=!0,this.events=new EventEmitter,this.interactive=!1,applyAnchor(this,i)}enableInteractivity(t){this.interactive=!0,this.shape=t,this._hovered=!1}_hitTest(t,i){var e,s,o;const n=(null==(s=null==(e=this.shape)?void 0:e.getBounds)?void 0:s.call(e))??(null==(o=this.getBounds)?void 0:o.call(this));if(!n)return!1;const{x:r,y:a,width:h,height:l}=n,c=h/2,d=l/2;return t>=r-c&&t<=r+c&&i>=a-d&&i<=a+d}on(t,i){this.events.on(t,i)}off(t,i){this.events.off(t,i)}update(t){}render(){}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class ShapeGOFactory{static create(t,i){const e={x:(null==i?void 0:i.x)??0,y:(null==i?void 0:i.y)??0,width:(null==i?void 0:i.width)??0,height:(null==i?void 0:i.height)??0};return new class extends GameObject{constructor(){super(t,e),this.shape=i}update(t){this.shape&&(this.shape.x=this.x,this.shape.y=this.y,this.shape.width=this.width,this.shape.height=this.height,this.shape.opacity=this.opacity)}render(){this.shape&&this.shape.draw()}}}}class Scene extends GameObject{constructor(t,i={}){super(t,i),this.children=[],this.x=i.x??0,this.y=i.y??0}add(t){return this.children.push(t),t}remove(t){this.children=this.children.filter((i=>i!==t))}clear(){this.children=[]}bringToFront(t){this.remove(t),this.children.push(t)}sendToBack(t){this.remove(t),this.children.unshift(t)}update(t){for(let i of this.children){"number"==typeof i.x&&(i.x+=this.x),"number"==typeof i.y&&(i.y+=this.y);const e=i.opacity??1;i.opacity=this.opacity*e,i.update&&i.update(t),i.opacity=e,"number"==typeof i.x&&(i.x-=this.x),"number"==typeof i.y&&(i.y-=this.y)}}render(){if(this.visible&&!(this.opacity<=0))for(let t of this.children)t.render&&t.render()}}class Text extends GameObject{constructor(t,i,e={}){super(t,e),this.text=i,this.x=e.x||0,this.y=e.y||0,this.font=e.font||"16px monospace",this.color=e.color||"#fff",this.align=e.align||"left",this.baseline=e.baseline||"top",this.stroke=e.stroke||!1,this.strokeColor=e.strokeColor||"#000",this.lineWidth=e.lineWidth||1}render(){Painter.setFont(this.font),Painter.setTextAlign(this.align),Painter.setTextBaseline(this.baseline),this.stroke&&Painter.strokeText(this.text,this.x,this.y,this.strokeColor,this.lineWidth,this.font),Painter.fillText(this.text,this.x,this.y,this.color,this.font)}}class Pipeline{constructor(t){this.game=t,this.gameObjects=[];["inputdown","inputup","inputmove"].forEach((t=>{this.game.events.on(t,(i=>{this.dispatchInputEvent(t,i)}))}))}_hoverObject(t,i){if(!t.interactive||!t._hitTest)return;const e=t._hitTest(i.x,i.y);e&&!t._hovered?(t._hovered=!0,t.events.emit("mouseover",i)):!e&&t._hovered&&(t._hovered=!1,t.events.emit("mouseout",i))}_hoverScene(t,i){for(let e=t.children.length-1;e>=0;e--){const s=t.children[e];s instanceof Scene?this._hoverScene(s,i):this._hoverObject(s,i)}}dispatchInputEvent(t,i){var e;for(let s=this.gameObjects.length-1;s>=0;s--){const o=this.gameObjects[s];if(o instanceof Scene){if(this._dispatchToScene(o,t,i))break}else if(o.interactive&&(null==(e=o._hitTest)?void 0:e.call(o,i.x,i.y))){o.events.emit(t,i);break}}"inputmove"===t&&this._dispatchHover(i)}_dispatchHover(t){for(let i=this.gameObjects.length-1;i>=0;i--){const e=this.gameObjects[i];e instanceof Scene?this._hoverScene(e,t):this._hoverObject(e,t)}}_dispatchToScene(t,i,e){var s;for(let o=t.children.length-1;o>=0;o--){const n=t.children[o];if(n instanceof Scene){if(this._dispatchToScene(n,i,e))return!0}else if(n.interactive&&(null==(s=n._hitTest)?void 0:s.call(n,e.x,e.y)))return n.events.emit(i,e),!0}return!1}add(t){return this.gameObjects=[...this.gameObjects,t],t}remove(t){this.gameObjects=this.gameObjects.filter((i=>i!==t))}update(t){this.gameObjects.filter((t=>t.active)).forEach((i=>i.update(t)))}render(){this.gameObjects.filter((t=>t.visible)).forEach((t=>t.render()))}clear(){this.gameObjects=[]}}class Game{constructor(t){this.canvas=t,this.ctx=t.getContext("2d"),this.events=new EventEmitter,this.lastTime=0,this.running=!1,this.pipeline=new Pipeline(this),Painter.init(this.ctx),this.initIO(),console.log("[Game] Constructor")}init(){console.log("[Game] Initialized")}initMouse(){Mouse.init(this)}initTouch(){Touch.init(this)}initInput(){Input.init(this)}initKeyboard(){Keys.init(this)}initIO(){this.initMouse(),this.initTouch(),this.initInput(),this.initKeyboard()}enableFluidSize(t=window){if(t===window){const t=()=>{this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight};t(),window.addEventListener("resize",t),this._fluidResizeCleanup=()=>{window.removeEventListener("resize",t)}}else{if(!("ResizeObserver"in window))return void console.warn("ResizeObserver not supported in this browser.");const i=()=>{const i=t.getBoundingClientRect();this.canvas.width=i.width,this.canvas.height=i.height},e=new ResizeObserver((()=>{i()}));e.observe(t),i(),this._fluidResizeCleanup=()=>e.disconnect()}}disableFluidSize(){this._fluidResizeCleanup&&(this._fluidResizeCleanup(),this._fluidResizeCleanup=null)}start(){this.running=!0,this.loop=this.loop.bind(this),requestAnimationFrame(this.loop),console.log("[Game] Started")}stop(){this.running=!1,console.log("[Game] Stopped")}restart(){this.pipeline.clear(),this.init(),this.start(),console.log("[Game] Restarted")}loop(t){if(!this.running)return;const i=(t-this.lastTime)/1e3;this.lastTime=t,this.update(i),this.render(),requestAnimationFrame(this.loop)}update(t){this.pipeline.update(t)}render(){this.running&&this.clear(),this.pipeline.render()}clear(){Painter.clear()}get width(){return this.canvas.width}get height(){return this.canvas.height}set backgroundColor(t){this.canvas.style.backgroundColor=t}}class Button extends GameObject{constructor(t,i={}){const{x:e=0,y:s=0,width:o=120,height:n=40,text:r="Button",shape:a=null,label:h=null,onClick:l=null,anchor:c,padding:d,...u}=i;super(t,{anchor:c,padding:d,...u}),this.x=e,this.y=s,this.width=o,this.height=n,this.state="default",this.bg=a??new Rectangle(0,0,o,n,{fillColor:"#eee",strokeColor:"#ccc",lineWidth:2}),this.label=h??new TextShape(0,0,r,{font:"16px monospace",color:"#333",align:"center",baseline:"middle"}),this.group=new Group(e,s),this.group.add(this.bg),this.group.add(this.label),this.enableInteractivity(this.group),this.on("mouseover",this.setState.bind(this,"hover")),this.on("mouseout",this.setState.bind(this,"default")),this.on("inputdown",this.setState.bind(this,"pressed")),this.on("inputup",(()=>{"pressed"===this.state&&"function"==typeof l&&l(),this.setState("hover")})),this.setState("default")}setState(t){if(this.state!==t)switch(this.state=t,t){case"default":this.game.cursor&&setTimeout((()=>{this.game.cursor.activate()}),0),this.bg.fillColor="#eee",this.bg.strokeColor="#ccc",this.label.color="#333",this.game.canvas.style.cursor="default";break;case"hover":this.game.cursor&&this.game.cursor.deactivate(),this.bg.fillColor="#222",this.bg.strokeColor="#16F529",this.label.color="#16F529",this.game.canvas.style.cursor="pointer";break;case"pressed":this.game.cursor&&this.game.cursor.deactivate(),this.bg.fillColor="#111",this.bg.strokeColor="#00aaff",this.label.color="#00aaff",this.game.canvas.style.cursor="pointer"}}update(t){this.group.x=this.x,this.group.y=this.y}render(){this.group.draw()}}class Cursor extends GameObject{constructor(t,i,e=null,s={}){super(t,s),this.normalShape=i,this.pressedShape=e||i,this.active=!1,this.offsetX=0,this.offsetY=0,this.isDown=!1,this.game.events.on("inputmove",(t=>{this.x=t.x,this.y=t.y})),this.game.events.on("inputdown",(()=>{this.isDown=!0})),this.game.events.on("inputup",(()=>{this.isDown=!1}))}activate(){this.active=!0,this.game.canvas.style.cursor="none"}deactivate(){this.active=!1,this.game.canvas.style.cursor="default"}update(t){super.update(t)}render(){if(!this.active)return;const t=this.isDown&&this.pressedShape?this.pressedShape:this.normalShape;t&&(t.x=this.x+this.offsetX,t.y=this.y+this.offsetY,t.draw(),super.render())}}class ToggleButton extends Button{constructor(t,i={}){const e=i.onClick;super(t,{...i,onClick:()=>{this.toggled=!this.toggled,"function"==typeof i.onToggle&&i.onToggle(this.toggled),"function"==typeof e&&e(),this.refreshToggleVisual()}}),this.toggled=!!i.startToggled,this.refreshToggleVisual()}toggle(t){this.toggled=t,this.refreshToggleVisual()}refreshToggleVisual(){this.toggled?(this.bg.fillColor="#444",this.bg.strokeColor="#0f0",this.label.color="#0f0"):(this.bg.fillColor="#eee",this.bg.strokeColor="#ccc",this.label.color="#333")}setState(t){super.setState(t),this.toggled&&(this.bg.fillColor="#444",this.bg.strokeColor="#0f0",this.label.color="#0f0")}}class FPSCounter extends Text{constructor(t,i={}){super(t,"0 FPS",{x:0,y:0,font:i.font||"12px monospace",color:i.color||"#0f0",align:i.align,baseline:i.baseline,stroke:i.stroke||!1,strokeColor:i.strokeColor||"#000",lineWidth:i.lineWidth||1,anchor:i.anchor||"top-left"}),this.fps=0,this._frames=0,this._accum=0}update(t){var i;this._frames++,this._accum+=t,this._accum>=.5&&(this.fps=Math.round(this._frames/this._accum),this.text=`${this.fps} FPS`,this._frames=0,this._accum=0),null==(i=super.update)||i.call(this,t)}}class LayoutGroup extends Scene{constructor(t,i={}){super(t,i),this.spacing=i.spacing??10,this.padding=i.padding??0,this.autoSize=i.autoSize??!0,this.align=i.align??"start",this.debug=i.debug??!1,this.width=0,this.height=0}render(){if(this.debug){new Rectangle(this.x+this.width/2,this.y+this.height/2,this.width,this.height,{strokeColor:"#0f0",fillColor:"rgba(0,0,0,0.1)",lineWidth:1}).draw()}super.render()}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}update(t){var i;null==(i=super.update)||i.call(this,t);for(let i of this.children)i.update&&i.update(t)}}class HorizontalLayout extends LayoutGroup{update(t){let i=this.padding,e=0;for(let t of this.children)e=Math.max(e,t.height??0);for(let t=0;t<this.children.length;t++){const s=this.children[t],o=this.y+(s.height??0)/2;switch(s.x=this.x+i+(s.width??0)/2,this.align){case"center":s.y=o+this.padding+(e-(s.height??0))/2;break;case"end":s.y=o+this.padding+(e-(s.height??0));break;default:s.y=o+this.padding}i+=s.width??0,t<this.children.length-1&&(i+=this.spacing)}this.autoSize&&(this.width=i-this.spacing+2*this.padding,this.height=e+2*this.padding),super.update(t)}}class VerticalLayout extends LayoutGroup{update(t){let i=this.padding,e=0;for(let t of this.children)e=Math.max(e,t.width??0);for(let t=0;t<this.children.length;t++){const s=this.children[t],o=this.x+(s.width??0)/2;switch(s.y=this.y+i+(s.height??0)/2,this.align){case"center":s.x=o+this.padding+(e-(s.width??0))/2;break;case"end":s.x=o+this.padding+(e-(s.width??0));break;default:s.x=o+this.padding}i+=s.height??0,t<this.children.length-1&&(i+=this.spacing)}this.autoSize&&(this.height=i-this.spacing+2*this.padding,this.width=e+2*this.padding),super.update(t)}}class Tween{static tween(t,i,e){return t+(i-t)*e}static tweenColor(t,i,e){return t.map(((t,s)=>Tween.lerp(t,i[s],e)))}static tweenGradient(t,i,e){let s=t[0],o=i[0];Math.abs(o-s)>180&&(s<o?s+=360:o+=360);return[Tween.lerp(s,o,e)%360,Tween.lerp(t[1],i[1],e),Tween.lerp(t[2],i[2],e)]}static easeInQuad(t){return t*t}static easeOutQuad(t){return t*(2-t)}static easeInOutQuad(t){return t<.5?2*t*t:(4-2*t)*t-1}static easeInCubic(t){return t*t*t}static easeOutCubic(t){return--t*t*t+1}static easeInOutCubic(t){return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1}static easeInQuart(t){return t*t*t*t}static easeOutQuart(t){return 1- --t*t*t*t}static easeInOutQuart(t){return t<.5?8*t*t*t*t:1-8*--t*t*t*t}static easeInSine(t){return 1-Math.cos(t*Math.PI/2)}static easeOutSine(t){return Math.sin(t*Math.PI/2)}static easeInOutSine(t){return-(Math.cos(Math.PI*t)-1)/2}static easeInExpo(t){return 0===t?0:Math.pow(2,10*(t-1))}static easeOutExpo(t){return 1===t?1:1-Math.pow(2,-10*t)}static easeInOutExpo(t){return 0===t||1===t?t:t<.5?.5*Math.pow(2,20*t-10):.5*(2-Math.pow(2,-20*t+10))}static easeInCirc(t){return 1-Math.sqrt(1-t*t)}static easeOutCirc(t){return Math.sqrt(1- --t*t)}static easeInOutCirc(t){return t<.5?.5*(1-Math.sqrt(1-4*t*t)):.5*(Math.sqrt(-(2*t-3)*(2*t-1))+1)}static easeInElastic(t,i=1,e=.3){if(0===t||1===t)return t;const s=e/(2*Math.PI)*Math.asin(1/i);return-i*Math.pow(2,10*(t-1))*Math.sin((t-1-s)*(2*Math.PI)/e)}static easeOutElastic(t,i=1,e=.3){if(0===t||1===t)return t;const s=e/(2*Math.PI)*Math.asin(1/i);return i*Math.pow(2,-10*t)*Math.sin((t-s)*(2*Math.PI)/e)+1}static easeInOutElastic(t,i=1,e=.3){if(0===t||1===t)return t;const s=e/(2*Math.PI)*Math.asin(1/i);return t<.5?i*Math.pow(2,10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/e)*-.5:i*Math.pow(2,-10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/e)*.5+1}static easeInBack(t,i=1.70158){return t*t*((i+1)*t-i)}static easeOutBack(t,i=1.70158){return--t*t*((i+1)*t+i)+1}static easeInOutBack(t,i=1.70158){const e=1.525*i;return t<.5?2*t*.5*(2*t)*(2*(e+1)*t-e):.5*((2*t-2)*(2*t-2)*((e+1)*(2*t-2)+e)+2)}static easeOutBounce(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}static easeInBounce(t){return 1-Tween.easeOutBounce(1-t)}static easeInOutBounce(t){return t<.5?.5*Tween.easeInBounce(2*t):.5*Tween.easeOutBounce(2*t-1)+.5}static parabolicArc(t,i,e,s){const o=(t+e-2*i)/2;return o*s*s+(i-t-o)*s+t}static oscillate(t,i,e,s=1){const o=(i-t)/2;return t+o+o*Math.sin(e*Math.PI*2/s)}static pulse(t,i,e){return t+(i-t)*(e<.5?2*e:2-2*e)}static spring(t,i,{velocity:e=0,stiffness:s=.1,damping:o=.8,precision:n=.01}={}){const r=i-t,a=t+(e=e*o+r*s),h=Math.abs(r)<n&&Math.abs(e)<n;return{value:h?i:a,velocity:e,done:h}}}function applyDraggable(t,i,e={}){const s=t.game;t.dragging=!1,t.dragOffset={x:0,y:0},t.target={x:i.x,y:i.y},t.friction=e.friction??.2,t.enableInteractivity(i),t.on("inputdown",(s=>{t.dragging=!0,t.dragOffset.x=i.x-s.x,t.dragOffset.y=i.y-s.y,e.onDragStart&&e.onDragStart()})),s.events.on("inputmove",(i=>{t.dragging&&(t.target.x=i.x+t.dragOffset.x,t.target.y=i.y+t.dragOffset.y)})),s.events.on("inputup",(()=>{t.dragging&&(t.dragging=!1,e.onDragEnd&&e.onDragEnd())}));const o=t.update.bind(t);t.update=function(e){t.x+=(t.target.x-i.x)*t.friction,t.y+=(t.target.y-i.y)*t.friction,o(e)}}export{Arc,Arrow,BezierShape,Button,Circle,Cloud,Cone,Cross,Cube,Cursor,Cylinder,Diamond,EventEmitter,FPSCounter,Game,GameObject,Group,Heart,Hexagon,HorizontalLayout,Input,Keys,LayoutGroup,Line,Mouse,Painter,PieSlice,Pin,Pipeline,Polygon,Prism,Rectangle,Ring,Scene,Shape,ShapeGOFactory,index as Shapes,Sphere,Square,Star,StickFigure,Text,TextShape,ToggleButton,Touch,Transformable,Triangle,Tween,VerticalLayout,applyAnchor,applyDraggable};