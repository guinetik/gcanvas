var _Grad,_grad3,_p,_perm,_gradP,_F2,_G2,_F3,_G3,_Noise_static,fade_fn,lerp_fn,__colors,__effects,__img,__lines,__opacity,__shapes,__text,_Painter_static,checkInitialized_fn,_prevWidth,_prevHeight,__defProp=Object.defineProperty,__typeError=t=>{throw TypeError(t)},__defNormalProp=(t,e,i)=>e in t?__defProp(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i,__publicField=(t,e,i)=>__defNormalProp(t,"symbol"!=typeof e?e+"":e,i),__accessCheck=(t,e,i)=>e.has(t)||__typeError("Cannot "+i),__privateGet=(t,e,i)=>(__accessCheck(t,e,"read from private field"),i?i.call(t):e.get(t)),__privateAdd=(t,e,i)=>e.has(t)?__typeError("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,i),__privateSet=(t,e,i,s)=>(__accessCheck(t,e,"write to private field"),s?s.call(t,i):e.set(t,i),i),__privateMethod=(t,e,i)=>(__accessCheck(t,e,"access private method"),i);class ZOrderedCollection{constructor(t={}){this.children=[],this.sortByZIndex=t.sortByZIndex||!0,this._zOrderDirty=!1}add(t){return this.children.includes(t)?(console.warn("Object is already in this collection"),t):(this.children.push(t),t.parent=this._owner||this,this.sortByZIndex&&(this._zOrderDirty=!0,t.zIndex=this.children.length-1),t)}remove(t){const e=this.children.indexOf(t);return-1!==e&&(this.children.splice(e,1),t.parent=null,!0)}clear(){this.children.forEach((t=>{t.parent=null})),this.children=[]}bringToFront(t){const e=this.children.indexOf(t);if(-1!==e)if(this.sortByZIndex){let e=!0;for(const i of this.children)if(i!==t&&(i.zIndex||0)>=(t.zIndex||0)){e=!1;break}e||(t.zIndex=Number.MAX_SAFE_INTEGER,this._zOrderDirty=!0,this._normalizeZIndices())}else e!==this.children.length-1&&(this.children.splice(e,1),this.children.push(t));else this.add(t)}sendToBack(t){const e=this.children.indexOf(t);if(-1===e)return this.children.unshift(t),void(t.parent=this._owner||this);if(this.sortByZIndex){let e=!0;for(const i of this.children)if(i!==t&&(i.zIndex||0)<=(t.zIndex||0)){e=!1;break}e||(t.zIndex=Number.MIN_SAFE_INTEGER,this._zOrderDirty=!0,this._normalizeZIndices())}else 0!==e&&(this.children.splice(e,1),this.children.unshift(t))}bringForward(t){const e=this.children.indexOf(t);if(-1!==e&&e!==this.children.length-1)if(this.sortByZIndex){const e=[...this.children].sort(((t,e)=>(t.zIndex||0)-(e.zIndex||0))),i=e.indexOf(t);if(i<e.length-1){const s=e[i+1],o=s.zIndex||0,n=t.zIndex||0;o-n>1?t.zIndex=n+Math.floor((o-n)/2):(t.zIndex=o,s.zIndex=n),this._zOrderDirty=!0,this._normalizeZIndices()}}else{const i=this.children[e+1];this.children[e+1]=t,this.children[e]=i}}sendBackward(t){const e=this.children.indexOf(t);if(!(e<=0))if(this.sortByZIndex){const e=[...this.children].sort(((t,e)=>(t.zIndex||0)-(e.zIndex||0))),i=e.indexOf(t);if(i>0){const s=e[i-1],o=s.zIndex||0,n=t.zIndex||0;n-o>1?t.zIndex=o+Math.floor((n-o)/2):(t.zIndex=o,s.zIndex=n),this._zOrderDirty=!0,this._normalizeZIndices()}}else{const i=this.children[e-1];this.children[e-1]=t,this.children[e]=i}}_normalizeZIndices(){if(this.children.length<=1)return;if(this.children.some((t=>(t.zIndex||0)>1e3||(t.zIndex||0)<-1e3))){[...this.children].sort(((t,e)=>(t.zIndex||0)-(e.zIndex||0))).forEach(((t,e)=>{t.zIndex=10*e})),this._zOrderDirty=!0}}getSortedChildren(){return this.sortByZIndex&&this._zOrderDirty&&(this.children.sort(((t,e)=>(t.zIndex||0)-(e.zIndex||0))),this._zOrderDirty=!1),this.children}}const _Position=class t{static calculate(e,i,s,o=10,n=0,a=0){const r=i.width||0,h=i.height||0,l=s.width||0,c=s.height||0,d=s.x||0,u=s.y||0;let p,g,_,f;switch(e){case t.TOP_LEFT:p=d-l/2+o+r/2,g=u-c/2+o+h/2,_="left",f="top";break;case t.TOP_CENTER:p=d,g=u-c/2+o+h/2,_="center",f="top";break;case t.TOP_RIGHT:p=d+l/2-o-r/2,g=u-c/2+o+h/2,_="right",f="top";break;case t.CENTER_LEFT:p=d-l/2+o+r/2,g=u,_="left",f="middle";break;case t.CENTER:p=d,g=u,_="center",f="middle";break;case t.CENTER_RIGHT:p=d+l/2-o-r/2,g=u,_="right",f="middle";break;case t.BOTTOM_LEFT:p=d-l/2+o+r/2,g=u+c/2-o-h/2,_="left",f="bottom";break;case t.BOTTOM_CENTER:p=d,g=u+c/2-o-h/2,_="center",f="bottom";break;case t.BOTTOM_RIGHT:p=d+l/2-o-r/2,g=u+c/2-o-h/2,_="right",f="bottom";break;default:p=d-l/2+o+r/2,g=u-c/2+o+h/2,_="left",f="top"}return p+=n,g+=a,{x:p,y:g,align:_,baseline:f}}static calculateAbsolute(e,i,s,o=10,n=0,a=0){const r={width:s.width,height:s.height,x:s.width/2,y:s.height/2};return t.calculate(e,i,r,o,n,a)}};__publicField(_Position,"TOP_LEFT","top-left"),__publicField(_Position,"TOP_CENTER","top-center"),__publicField(_Position,"TOP_RIGHT","top-right"),__publicField(_Position,"CENTER_LEFT","center-left"),__publicField(_Position,"CENTER","center"),__publicField(_Position,"CENTER_RIGHT","center-right"),__publicField(_Position,"BOTTOM_LEFT","bottom-left"),__publicField(_Position,"BOTTOM_CENTER","bottom-center"),__publicField(_Position,"BOTTOM_RIGHT","bottom-right");let Position=_Position;function applyLayout(t,e,i={}){const s=i.offsetX??0,o=i.offsetY??0,n=i.transform;return t.forEach(((t,i)=>{if(i<e.length){const a=e[i];if(n){const e=n(a);t.x=e.x+s,t.y=e.y+o}else t.x=a.x+s,t.y=a.y+o}})),t}function horizontalLayout(t,e={}){const i=e.spacing??10,s=e.padding??0,o=e.align??"start",n=e.centerItems??!0;let a=s,r=0;const h=[];for(const e of t)r=Math.max(r,e.height??0);for(let e=0;e<t.length;e++){const s=t[e],l=s.width??0,c=s.height??0,d=n?a+l/2:a;let u;switch(o){case"center":u=(r-c)/2;break;case"end":u=r-c;break;default:u=0}h.push({x:d,y:u}),a+=l,e<t.length-1&&(a+=i)}return{positions:h,width:a+s,height:r+2*s}}function verticalLayout(t,e={}){const i=e.spacing??10,s=e.padding??0,o=e.align??"start",n=e.centerItems??!0;let a=s,r=0;const h=[];for(const e of t)r=Math.max(r,e.width??0);for(let e=0;e<t.length;e++){const s=t[e],l=s.width??0,c=s.height??0,d=n?a+c/2:a;let u;switch(o){case"center":u=(r-l)/2;break;case"end":u=r-l;break;default:u=0}h.push({x:u,y:d}),a+=c,e<t.length-1&&(a+=i)}return{positions:h,width:r+2*s,height:a+s}}function tileLayout(t,e={}){if(0===t.length)return{positions:[],width:0,height:0};const i=e.columns??4,s=e.spacing??10,o=e.padding??0,n=e.centerItems??!0,a=t[0].width??0,r=t[0].height??0,h=Math.ceil(t.length/i),l=[],c=i*a+(i-1)*s+2*o,d=h*r+(h-1)*s+2*o;let u=o,p=o,g=0;for(let e=0;e<t.length;e++){const t=n?u+a/2:u,e=n?p+r/2:p;l.push({x:t,y:e}),g++,g<i?u+=a+s:(g=0,u=o,p+=r+s)}return{positions:l,width:c,height:d}}function gridLayout(t,e={}){if(0===t.length)return{positions:[],width:0,height:0};const i=e.columns??4,s=e.spacing??10,o=e.padding??0,n=e.centerItems??!0,a=new Array(i).fill(0),r=[];t.forEach(((t,e)=>{const s=e%i,o=Math.floor(e/i),n=t.width??0,h=t.height??0;a[s]=Math.max(a[s],n),void 0===r[o]?r[o]=h:r[o]=Math.max(r[o],h)}));const h=[];let l=o,c=o,d=0;for(let e=0;e<t.length;e++){const u=t[e],p=u.width??0,g=u.height??0,_=r[Math.floor(e/i)],f=n?l+p/2:l,m=n?c+g/2:c;h.push({x:f,y:m}),d++,d<i?l+=a[d-1]+s:(d=0,l=o,c+=_+s)}return{positions:h,width:2*o+a.reduce(((t,e)=>t+e),0)+s*(i-1),height:2*o+r.reduce(((t,e)=>t+e),0)+s*(r.length-1),cols:i,rows:r.length}}class TaskManager{constructor(t){this.worker=new Worker(t),this.nextTaskId=1,this.pendingTasks=new Map,this.worker.onmessage=this.handleMessage.bind(this)}handleMessage(t){const{taskId:e,status:i,result:s,error:o}=t.data;if(this.pendingTasks.has(e)){const{resolve:t,reject:n}=this.pendingTasks.get(e);"complete"===i?t(s):"error"===i&&n(new Error(o)),this.pendingTasks.delete(e)}}runTask(t,e){return new Promise(((i,s)=>{const o=this.nextTaskId++;this.pendingTasks.set(o,{resolve:i,reject:s}),this.worker.postMessage({taskId:o,taskName:t,params:e})}))}terminate(){this.worker.terminate()}}class Random{static symmetric(t,e,i,s,o=1,n="topleft"){const a="centered"===n?e:e+s/2;return{x:("centered"===n?t:t+i/2)+(Math.random()-.5)*i*o,y:a+(Math.random()-.5)*s*o}}static pointInBox(t,e,i,s,o="topleft"){return"centered"===o?{x:t+(Math.random()-.5)*i,y:e+(Math.random()-.5)*s}:{x:t+Math.random()*i,y:e+Math.random()*s}}static centered(t,e,i,s,o=50,n="topleft"){const a="centered"===n?e:e+s/2;return{x:("centered"===n?t:t+i/2)+2*(Math.random()-.5)*o,y:a+2*(Math.random()-.5)*o}}static gaussian(t,e,i,s,o=40,n="topleft"){const a="centered"===n?e:e+s/2;return{x:("centered"===n?t:t+i/2)+Random._gaussian(0,o),y:a+Random._gaussian(0,o)}}static radial(t,e,i,s,o=100,n="topleft"){const a="centered"===n?t:t+i/2,r="centered"===n?e:e+s/2,h=Math.random()*Math.PI*2,l=Math.random()*o;return{x:a+Math.cos(h)*l,y:r+Math.sin(h)*l}}static pick(t){return t[Math.floor(Math.random()*t.length)]}static pickOther(t,e){const i=t.filter((t=>t!==e));if(0!==i.length)return Random.pick(i)}static float(t,e){return t+Math.random()*(e-t)}static int(t,e){return Math.floor(Random.float(t,e+1))}static chance(t=.5){return Math.random()<t}static coin(){return Math.random()<.5}static _gaussian(t=0,e=1){let i=1-Math.random(),s=1-Math.random();return t+e*Math.sqrt(-2*Math.log(i))*Math.cos(2*Math.PI*s)}}class Complex{constructor(t,e=0){this.real=t,this.imag=e}static fromPolar(t,e){return new Complex(t*Math.cos(e),t*Math.sin(e))}add(t){return new Complex(this.real+t.real,this.imag+t.imag)}subtract(t){return new Complex(this.real-t.real,this.imag-t.imag)}multiply(t){return new Complex(this.real*t.real-this.imag*t.imag,this.real*t.imag+this.imag*t.real)}divide(t){return new Complex(this.real/t,this.imag/t)}scale(t){return new Complex(this.real*t,this.imag*t)}abs(){return Math.sqrt(this.real*this.real+this.imag*this.imag)}}class Fractals{static applyColorScheme(t,e,i,s,o,n){const a=(null==e?void 0:e.data)||[];for(let e=0;e<t.length;e++){const r=t[e],h=4*e;switch(i){case"futuristic":{const i=t[e]/10,s={r:0,g:5,b:10},o={r:0,g:30,b:20};if(i>.7){const t=3.33*(i-.7);a[h]=Math.floor(s.r*(1-t)+o.r*t),a[h+1]=Math.floor(s.g*(1-t)+o.g*t),a[h+2]=Math.floor(s.b*(1-t)+o.b*t)}else{const t=1.43*i;a[h]=Math.floor(s.r*t),a[h+1]=Math.floor(s.g*t),a[h+2]=Math.floor(s.b*t)}a[h+3]=255}break;case"rainbow":if(0===r)a[h]=0,a[h+1]=0,a[h+2]=0,a[h+3]=255;else{const t=(10*r+o)%360,[e,i,s]=n(t,.8,.5);a[h]=e,a[h+1]=i,a[h+2]=s,a[h+3]=255}break;case"grayscale":{const t=0===r?0:255-255*r/s;a[h]=t,a[h+1]=t,a[h+2]=t,a[h+3]=255}break;case"binary":0!==r?(a[h]=0,a[h+1]=0,a[h+2]=0):(a[h]=255,a[h+1]=255,a[h+2]=255),a[h+3]=255;break;case"fire":if(0==r)a[h]=0,a[h+1]=0,a[h+2]=0;else{const t=r/s;if(t<.3){const e=t/.3;a[h]=Math.floor(255*e),a[h+1]=0,a[h+2]=0}else if(t<.6){const e=(t-.3)/.3;a[h]=255,a[h+1]=Math.floor(165*e),a[h+2]=0}else if(t<.9){const e=(t-.6)/.3;a[h]=255,a[h+1]=165+Math.floor(90*e),a[h+2]=Math.floor(255*e)}else a[h]=255,a[h+1]=255,a[h+2]=255}a[h+3]=255;break;case"ocean":if(0===r)a[h]=0,a[h+1]=20,a[h+2]=50;else{const t=r/s;a[h]=Math.floor(10+50*t),a[h+1]=Math.floor(50+150*t),a[h+2]=Math.floor(100+155*t)}a[h+3]=255;break;case"electric":if(0===r)a[h]=0,a[h+1]=0,a[h+2]=0;else{const t=(r+o)%3,e=r%20/20;0===t?(a[h]=Math.floor(255*(.5+.5*Math.sin(e*Math.PI*2))),a[h+1]=Math.floor(128*e),a[h+2]=Math.floor(255*e)):1===t?(a[h]=Math.floor(255*e),a[h+1]=Math.floor(255*(.5+.5*Math.sin(e*Math.PI*2))),a[h+2]=Math.floor(128*e)):(a[h]=Math.floor(128*e),a[h+1]=Math.floor(255*e),a[h+2]=Math.floor(255*(.5+.5*Math.sin(e*Math.PI*2))))}a[h+3]=255;break;case"topographic":if(0===r)a[h]=5,a[h+1]=15,a[h+2]=30;else{const t=r/s;if(t<.1){const e=t/.1;a[h]=Math.floor(5+20*e),a[h+1]=Math.floor(15+40*e),a[h+2]=Math.floor(30+50*e)}else if(t<.3){const e=(t-.1)/.2;a[h]=Math.floor(210+45*e),a[h+1]=Math.floor(180+40*e),a[h+2]=Math.floor(140+30*e)}else if(t<.7){const e=(t-.3)/.4;a[h]=Math.floor(50*(1-e)),a[h+1]=Math.floor(100+80*e),a[h+2]=Math.floor(50*(1-e))}else{const e=(t-.7)/.3;a[h]=Math.floor(150+105*e),a[h+1]=Math.floor(150+105*e),a[h+2]=Math.floor(150+105*e)}}a[h+3]=255;break;default:if(0===r)a[h]=0,a[h+1]=0,a[h+2]=0;else{const t=(r+o)%64;t<16?(a[h]=16*t,a[h+1]=0,a[h+2]=0):t<32?(a[h]=255,a[h+1]=16*(t-16),a[h+2]=0):t<48?(a[h]=255-16*(t-32),a[h+1]=255,a[h+2]=0):(a[h]=0,a[h+1]=255-16*(t-48),a[h+2]=16*(t-48))}a[h+3]=255}}return null!=e?e:a}static pythagorasTree(t,e,i=10,s=-2,o=2,n=-.5,a=3.5){const r=new Uint8Array(t*e),h=e=>Math.floor((e-s)*t/(o-s)),l=t=>Math.floor((t-n)*e/(a-n)),c=(i,s,o,n)=>{const a=h(i),c=l(s),d=h(o),u=l(n);let p=a,g=c;const _=Math.abs(d-a),f=Math.abs(u-c),m=a<d?1:-1,x=c<u?1:-1;let M=_-f;for(;p>=0&&p<t&&g>=0&&g<e&&(r[g*t+p]=255),p!==d||g!==u;){const t=2*M;t>-f&&(M-=f,p+=m),t<_&&(M+=_,g+=x)}},d=(t,e,i,s,o)=>{if(o<=0)return;const n=i-t,a=s-e,r=i+a,h=s-n,l=t+a,u=e-n;((t,e,i,s,o,n,a,r)=>{c(t,e,i,s),c(i,s,o,n),c(o,n,a,r),c(a,r,t,e)})(t,e,i,s,r,h,l,u);const p=Math.PI/4,g=.7*Math.sqrt(n*n+a*a),_=g*Math.cos(Math.atan2(a,n)-p),f=g*Math.sin(Math.atan2(a,n)-p),m=.7*Math.sqrt(n*n+a*a),x=l,M=u,y=x+m*Math.cos(Math.atan2(a,n)+p),b=M+m*Math.sin(Math.atan2(a,n)+p);d(r,h,r+_,h+f,o-1),d(x,M,y,b,o-1)},u=Math.min(i,12);return d(-.5,0,.5,0,u),r}static mandelbrot(t,e,i=100,s=-2.5,o=1,n=-1.5,a=1.5){const r=new Uint8Array(t*e),h=(o-s)/t,l=(a-n)/e;for(let o=0;o<e;o++){const e=o*t,a=n+o*l;for(let o=0;o<t;o++){const t=s+o*h;let n=0,l=0,c=0,d=0,u=0;do{l=2*n*l+a,n=c-d+t,c=n*n,d=l*l,u++}while(c+d<4&&u<i);r[e+o]=u<i?u%256:0}}return r}static julia(t,e,i=100,s=-.7,o=.27,n=1,a=0,r=0){const h=new Uint8Array(t*e),l=2/n,c=-l+a,d=-l+r,u=(l+a-c)/t,p=(l+r-d)/e;for(let n=0;n<e;n++){const e=n*t,a=d+n*p;for(let n=0;n<t;n++){let t=c+n*u,r=a,l=0,d=0,p=0;do{l=t*t,d=r*r;r=2*t*r+o,t=l-d+s,p++}while(l+d<4&&p<i);h[e+n]=p<i?p%256:0}}return h}static tricorn(t,e,i=100,s=-2.5,o=1.5,n=-1.5,a=1.5){const r=new Uint8Array(t*e),h=(o-s)/t,l=(a-n)/e;for(let o=0;o<e;o++){const e=o*t,a=n+o*l;for(let o=0;o<t;o++){const t=s+o*h;let n=0,l=0,c=0,d=0,u=0;do{l=-2*n*l+a,n=c-d+t,c=n*n,d=l*l,u++}while(c+d<4&&u<i);r[e+o]=u<i?u%256:0}}return r}static phoenix(t,e,i=100,s=.5,o=.5,n=-2,a=2,r=-2,h=2){const l=new Uint8Array(t*e),c=(a-n)/t,d=(h-r)/e;for(let a=0;a<e;a++){const e=a*t,h=r+a*d;for(let a=0;a<t;a++){const t=n+a*c;let r=0,d=0,u=0,p=0,g=0,_=0,f=0;do{const e=g-_+t+s*u+o,i=2*r*d+h+s*p;u=r,p=d,r=e,d=i,g=r*r,_=d*d,f++}while(g+_<4&&f<i);l[e+a]=f<i?f%256:0}}return l}static newton(t,e,i=100,s=1e-6,o=-2,n=2,a=-2,r=2){const h=new Uint8Array(t*e),l=s*s,c=n-o,d=r-a,u=new Float64Array(3),p=new Float64Array(3);for(let t=0;t<3;t++){const e=2*Math.PI*t/3;u[t]=Math.cos(e),p[t]=Math.sin(e)}const g=c/t,_=d/e;for(let s=0;s<e;s++){const e=s*t,n=a+s*_;for(let s=0;s<t;s++){let t=o+s*g,a=n,r=0,c=-1;for(;r<i&&c<0;){const e=t*t-a*a,i=2*t*a,s=e*t-i*a-1,o=e*a+i*t,n=3*e,h=3*i,d=n*n+h*h;if(d<l)break;const g=1/d,_=t-(s*n+o*h)*g,f=a-(o*n-s*h)*g;for(let t=0;t<3;t++){const e=_-u[t],i=f-p[t];if(e*e+i*i<l){c=t;break}}t=_,a=f,r++}if(c>=0){const t=1-Math.min(r/i,1),o=85*c;h[e+s]=Math.floor(o+85*t)}else h[e+s]=0}}return h}static sierpinski(t,e,i=6,s=0,o=1,n=0,a=1){const r=new Uint8Array(t*e).fill(1),h=Math.sqrt(3)/2,l=o-s,c=(a-n)/l;if(Math.abs(c-h)>1e-9){const t=(n+a)/2,e=l*h;n=t-e/2,a=t+e/2}const d=(1<<Math.min(i,32))-1,u=(o-s)/t,p=(a-n)/e,g=2/Math.sqrt(3);for(let i=0;i<e;++i){const e=n+i*p,o=Math.floor(e*g),a=.5*o;for(let e=0;e<t;++e){const n=s+e*u;Math.floor(n-a)&o&d&&(r[i*t+e]=0)}}return r}static sierpinskiCarpet(t,e,i=5,s=0,o=1,n=0,a=1){const r=new Uint8Array(t*e).fill(1),h=o-s,l=a-n,c=Math.max(h,l),d=(s+o)/2,u=(n+a)/2;s=d-c/2,o=d+c/2,n=u-c/2,a=u+c/2;const p=Math.pow(3,i),g=(t,e)=>{let i=t,s=e;for(;i>0||s>0;){if(i%3==1&&s%3==1)return!0;i=Math.floor(i/3),s=Math.floor(s/3)}return!1};for(let i=0;i<e;++i){const h=(n+i/e*(a-n))*p,l=(Math.floor(h)%p+p)%p;for(let e=0;e<t;++e){const n=(s+e/t*(o-s))*p;g((Math.floor(n)%p+p)%p,l)&&(r[i*t+e]=0)}}return r}static barnsleyFern(t,e,i=1e5){const s=new Uint8Array(t*e).fill(0);let o=0,n=0;const a=Math.min(t,e)/10,r=t/2;for(let h=0;h<i;h++){const i=Math.random();let h,l;i<.01?(h=0,l=.16*n):i<.86?(h=.85*o+.04*n,l=-.04*o+.85*n+1.6):i<.93?(h=.2*o-.26*n,l=.23*o+.22*n+1.6):(h=-.15*o+.28*n,l=.26*o+.24*n+.44),o=h,n=l;const c=Math.floor(o*a+r),d=Math.floor(e-n*a);if(c>=0&&c<t&&d>=0&&d<e){const e=d*t+c;s[e]<255&&s[e]++}}return s}static lyapunov(t,e,i=1e3,s="AB",o=3.4,n=4,a=3.4,r=4){console.time("lyapunov");const h=(s=s.toUpperCase().replace(/[^AB]/g,"")||"AB").length,l=new Float32Array(t*e);let c=1/0,d=-1/0;for(let u=0;u<e;u++){const p=a+(r-a)*u/e;for(let e=0;e<t;e++){const a=o+(n-o)*e/t;let r=.5;for(let t=0;t<100;t++){r=("A"===s[t%h]?a:p)*r*(1-r)}let g=0,_=0;for(;_<i;){const t="A"===s[_%h]?a:p;r=t*r*(1-r);const e=Math.abs(t*(1-2*r));if(g+=Math.log(Math.max(e,1e-10)),_++,Math.abs(g/_)>10)break}const f=g/_;l[u*t+e]=f,f>-10&&f<10&&(f<c&&(c=f),f>d&&(d=f))}}c===d&&(c-=1,d+=1);const u=d-c,p=new Uint8Array(t*e);for(let t=0;t<l.length;t++){let e=l[t];e=Math.max(-10,Math.min(10,e));let i=(e-c)/u;p[t]=Math.floor(255*i)}return console.timeEnd("lyapunov"),p}static koch(t,e,i=4,s=-2,o=2,n=-2,a=2){const r=new Uint8Array(t*e),h=e=>Math.floor((e-s)*t/(o-s)),l=t=>Math.floor((t-n)*e/(a-n)),c=(i,s,o,n,a)=>{if(a<=0)return void((i,s,o,n)=>{const a=h(i),c=l(s),d=h(o),u=l(n);let p=a,g=c;const _=Math.abs(d-a),f=Math.abs(u-c),m=a<d?1:-1,x=c<u?1:-1;let M=_-f;for(;p>=0&&p<t&&g>=0&&g<e&&(r[g*t+p]=255),p!==d||g!==u;){const t=2*M;t>-f&&(M-=f,p+=m),t<_&&(M+=_,g+=x)}})(i,s,o,n);const d=(o-i)/3,u=(n-s)/3,p=i+d,g=s+u,_=i+2*d,f=s+2*u,m=Math.PI/3,x=p+d*Math.cos(m)-u*Math.sin(m),M=g+d*Math.sin(m)+u*Math.cos(m);c(i,s,p,g,a-1),c(p,g,x,M,a-1),c(x,M,_,f,a-1),c(_,f,o,n,a-1)},d=Math.min(i,10),u=3*Math.sqrt(3)/2,p=[0,-u/2+.5],g=[-1.5,u/2+.5],_=[1.5,u/2+.5];return c(p[0],p[1],g[0],g[1],d),c(g[0],g[1],_[0],_[1],d),c(_[0],_[1],p[0],p[1],d),r}}__publicField(Fractals,"types",{MANDELBROT:"mandelbrot",TRICORN:"tricorn",PHOENIX:"phoenix",JULIA:"julia",SIERPINSKI:"sierpinski",SCARPET:"sierpinskiCarpet",BARNSEY_FERN:"barnsleyFern",KOCH:"koch",PYTHAGORAS_TREE:"pythagorasTree",NEWTON:"newton",LYAPUNOV:"lyapunov"}),__publicField(Fractals,"colors",{FUTURISTIC:"futuristic",RAINBOW:"rainbow",GRAYSCALE:"grayscale",TOPOGRAPHIC:"topographic",FIRE:"fire",OCEAN:"ocean",ELECTRIC:"electric",BINARY:"binary",HISTORIC:"historic"});const _Noise=class{static seed(t){t>0&&t<1&&(t*=65536),(t=Math.floor(t))<256&&(t|=t<<8);for(let e=0;e<256;e++){let i;i=1&e?__privateGet(this,_p)[e]^255&t:__privateGet(this,_p)[e]^t>>8&255,__privateGet(this,_perm)[e]=__privateGet(this,_perm)[e+256]=i,__privateGet(this,_gradP)[e]=__privateGet(this,_gradP)[e+256]=__privateGet(this,_grad3)[i%12]}}static simplex2(t,e){let i,s,o;const n=(t+e)*__privateGet(this,_F2),a=Math.floor(t+n),r=Math.floor(e+n),h=(a+r)*__privateGet(this,_G2),l=t-a+h,c=e-r+h;let d,u;l>c?(d=1,u=0):(d=0,u=1);const p=l-d+__privateGet(this,_G2),g=c-u+__privateGet(this,_G2),_=l-1+2*__privateGet(this,_G2),f=c-1+2*__privateGet(this,_G2),m=255&a,x=255&r,M=__privateGet(this,_gradP)[m+__privateGet(this,_perm)[x]],y=__privateGet(this,_gradP)[m+d+__privateGet(this,_perm)[x+u]],b=__privateGet(this,_gradP)[m+1+__privateGet(this,_perm)[x+1]];let w=.5-l*l-c*c;w<0?i=0:(w*=w,i=w*w*M.dot2(l,c));let P=.5-p*p-g*g;P<0?s=0:(P*=P,s=P*P*y.dot2(p,g));let v=.5-_*_-f*f;return v<0?o=0:(v*=v,o=v*v*b.dot2(_,f)),70*(i+s+o)}static simplex3(t,e,i){let s,o,n,a;const r=(t+e+i)*__privateGet(this,_F3),h=Math.floor(t+r),l=Math.floor(e+r),c=Math.floor(i+r),d=(h+l+c)*__privateGet(this,_G3),u=t-h+d,p=e-l+d,g=i-c+d;let _,f,m,x,M,y;u>=p?p>=g?(_=1,f=0,m=0,x=1,M=1,y=0):u>=g?(_=1,f=0,m=0,x=1,M=0,y=1):(_=0,f=0,m=1,x=1,M=0,y=1):p<g?(_=0,f=0,m=1,x=0,M=1,y=1):u<g?(_=0,f=1,m=0,x=0,M=1,y=1):(_=0,f=1,m=0,x=1,M=1,y=0);const b=u-_+__privateGet(this,_G3),w=p-f+__privateGet(this,_G3),P=g-m+__privateGet(this,_G3),v=u-x+2*__privateGet(this,_G3),k=p-M+2*__privateGet(this,_G3),C=g-y+2*__privateGet(this,_G3),T=u-1+3*__privateGet(this,_G3),S=p-1+3*__privateGet(this,_G3),I=g-1+3*__privateGet(this,_G3),B=255&h,D=255&l,G=255&c,F=__privateGet(this,_gradP)[B+__privateGet(this,_perm)[D+__privateGet(this,_perm)[G]]],O=__privateGet(this,_gradP)[B+_+__privateGet(this,_perm)[D+f+__privateGet(this,_perm)[G+m]]],E=__privateGet(this,_gradP)[B+x+__privateGet(this,_perm)[D+M+__privateGet(this,_perm)[G+y]]],L=__privateGet(this,_gradP)[B+1+__privateGet(this,_perm)[D+1+__privateGet(this,_perm)[G+1]]];let A=.6-u*u-p*p-g*g;A<0?s=0:(A*=A,s=A*A*F.dot3(u,p,g));let z=.6-b*b-w*w-P*P;z<0?o=0:(z*=z,o=z*z*O.dot3(b,w,P));let R=.6-v*v-k*k-C*C;R<0?n=0:(R*=R,n=R*R*E.dot3(v,k,C));let W=.6-T*T-S*S-I*I;return W<0?a=0:(W*=W,a=W*W*L.dot3(T,S,I)),32*(s+o+n+a)}static perlin2(t,e){const i=Math.floor(t),s=Math.floor(e);t-=i,e-=s;const o=255&i,n=255&s,a=__privateGet(this,_gradP)[o+__privateGet(this,_perm)[n]].dot2(t,e),r=__privateGet(this,_gradP)[o+__privateGet(this,_perm)[n+1]].dot2(t,e-1),h=__privateGet(this,_gradP)[o+1+__privateGet(this,_perm)[n]].dot2(t-1,e),l=__privateGet(this,_gradP)[o+1+__privateGet(this,_perm)[n+1]].dot2(t-1,e-1),c=__privateMethod(this,_Noise_static,fade_fn).call(this,t);return __privateMethod(this,_Noise_static,lerp_fn).call(this,__privateMethod(this,_Noise_static,lerp_fn).call(this,a,h,c),__privateMethod(this,_Noise_static,lerp_fn).call(this,r,l,c),__privateMethod(this,_Noise_static,fade_fn).call(this,e))}static perlin3(t,e,i){const s=Math.floor(t),o=Math.floor(e),n=Math.floor(i);t-=s,e-=o,i-=n;const a=255&s,r=255&o,h=255&n,l=__privateGet(this,_gradP)[a+__privateGet(this,_perm)[r+__privateGet(this,_perm)[h]]].dot3(t,e,i),c=__privateGet(this,_gradP)[a+__privateGet(this,_perm)[r+__privateGet(this,_perm)[h+1]]].dot3(t,e,i-1),d=__privateGet(this,_gradP)[a+__privateGet(this,_perm)[r+1+__privateGet(this,_perm)[h]]].dot3(t,e-1,i),u=__privateGet(this,_gradP)[a+__privateGet(this,_perm)[r+1+__privateGet(this,_perm)[h+1]]].dot3(t,e-1,i-1),p=__privateGet(this,_gradP)[a+1+__privateGet(this,_perm)[r+__privateGet(this,_perm)[h]]].dot3(t-1,e,i),g=__privateGet(this,_gradP)[a+1+__privateGet(this,_perm)[r+__privateGet(this,_perm)[h+1]]].dot3(t-1,e,i-1),_=__privateGet(this,_gradP)[a+1+__privateGet(this,_perm)[r+1+__privateGet(this,_perm)[h]]].dot3(t-1,e-1,i),f=__privateGet(this,_gradP)[a+1+__privateGet(this,_perm)[r+1+__privateGet(this,_perm)[h+1]]].dot3(t-1,e-1,i-1),m=__privateMethod(this,_Noise_static,fade_fn).call(this,t),x=__privateMethod(this,_Noise_static,fade_fn).call(this,e),M=__privateMethod(this,_Noise_static,fade_fn).call(this,i);return __privateMethod(this,_Noise_static,lerp_fn).call(this,__privateMethod(this,_Noise_static,lerp_fn).call(this,__privateMethod(this,_Noise_static,lerp_fn).call(this,l,p,m),__privateMethod(this,_Noise_static,lerp_fn).call(this,c,g,m),M),__privateMethod(this,_Noise_static,lerp_fn).call(this,__privateMethod(this,_Noise_static,lerp_fn).call(this,d,_,m),__privateMethod(this,_Noise_static,lerp_fn).call(this,u,f,m),M),x)}};_Grad=new WeakMap,_grad3=new WeakMap,_p=new WeakMap,_perm=new WeakMap,_gradP=new WeakMap,_F2=new WeakMap,_G2=new WeakMap,_F3=new WeakMap,_G3=new WeakMap,_Noise_static=new WeakSet,fade_fn=function(t){return t*t*t*(t*(6*t-15)+10)},lerp_fn=function(t,e,i){return(1-i)*t+i*e},__privateAdd(_Noise,_Noise_static),__privateAdd(_Noise,_Grad,class{constructor(t,e,i){this.x=t,this.y=e,this.z=i}dot2(t,e){return this.x*t+this.y*e}dot3(t,e,i){return this.x*t+this.y*e+this.z*i}}),__privateAdd(_Noise,_grad3,[new(__privateGet(_Noise,_Grad))(1,1,0),new(__privateGet(_Noise,_Grad))(-1,1,0),new(__privateGet(_Noise,_Grad))(1,-1,0),new(__privateGet(_Noise,_Grad))(-1,-1,0),new(__privateGet(_Noise,_Grad))(1,0,1),new(__privateGet(_Noise,_Grad))(-1,0,1),new(__privateGet(_Noise,_Grad))(1,0,-1),new(__privateGet(_Noise,_Grad))(-1,0,-1),new(__privateGet(_Noise,_Grad))(0,1,1),new(__privateGet(_Noise,_Grad))(0,-1,1),new(__privateGet(_Noise,_Grad))(0,1,-1),new(__privateGet(_Noise,_Grad))(0,-1,-1)]),__privateAdd(_Noise,_p,[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]),__privateAdd(_Noise,_perm,new Array(512)),__privateAdd(_Noise,_gradP,new Array(512)),__privateAdd(_Noise,_F2,.5*(Math.sqrt(3)-1)),__privateAdd(_Noise,_G2,(3-Math.sqrt(3))/6),__privateAdd(_Noise,_F3,1/3),__privateAdd(_Noise,_G3,1/6),_Noise.seed(0);let Noise=_Noise;function generatePenroseTilingPixels(t=800,e=800,i){const{divisions:s=5,zoomType:o="in",color1:n=[255,0,0,255],color2:a=[0,0,255,255],color3:r=[0,0,0,255],backgroundColor:h=[255,255,255,255]}=i||{},l=new Uint8ClampedArray(t*e*4);for(let t=0;t<l.length;t+=4)l[t]=h[0],l[t+1]=h[1],l[t+2]=h[2],l[t+3]=h[3]||255;const c="in"===o?1:2,d=Math.max(t,e),u=d/c,p=d/c,g=.5*c,_=.5*c,f=(Math.sqrt(5)+1)/2;let m=[];for(let t=0;t<10;t++){const e=Complex.fromPolar(1,(2*t-1)*Math.PI/10),i=Complex.fromPolar(1,(2*t+1)*Math.PI/10);t%2==0?m.push(["thin",new Complex(0),i,e]):m.push(["thin",new Complex(0),e,i])}for(let t=0;t<s;t++){const t=[];for(const[e,i,s,o]of m)if("thin"===e){const e=i.add(s.subtract(i).scale(1/f));t.push(["thin",o,e,s]),t.push(["thicc",e,o,i])}else{const e=s.add(i.subtract(s).scale(1/f)),n=s.add(o.subtract(s).scale(1/f));t.push(["thicc",n,o,i]),t.push(["thicc",e,n,s]),t.push(["thin",n,e,i])}m=t}function x(i){return{x:Math.floor((i.real*u+g*u)*t/d),y:Math.floor((i.imag*p+_*p)*e/d)}}for(const[i,s,o,r]of m){fillTriangle(l,x(s),x(o),x(r),"thin"===i?n:a,t,e)}if(r&&r[3]>0)for(const[i,s,o,n]of m){const i=x(s),a=x(o),h=x(n);drawLine(l,i,a,r,t,e),drawLine(l,a,h,r,t,e),drawLine(l,h,i,r,t,e)}return l}function fillTriangle(t,e,i,s,o,n,a){e.y>i.y&&([e,i]=[i,e]),e.y>s.y&&([e,s]=[s,e]),i.y>s.y&&([i,s]=[s,i]);const r=o[0],h=o[1],l=o[2],c=o[3]||255;if(i.y===s.y)fillFlatBottomTriangle(t,e,i,s,r,h,l,c,n,a);else if(e.y===i.y)fillFlatTopTriangle(t,e,i,s,r,h,l,c,n,a);else{const o={x:Math.floor(e.x+(i.y-e.y)/(s.y-e.y)*(s.x-e.x)),y:i.y};fillFlatBottomTriangle(t,e,i,o,r,h,l,c,n,a),fillFlatTopTriangle(t,i,o,s,r,h,l,c,n,a)}}function fillFlatBottomTriangle(t,e,i,s,o,n,a,r,h,l){const c=(i.x-e.x)/(i.y-e.y||1),d=(s.x-e.x)/(s.y-e.y||1);let u=e.x,p=e.x;for(let s=e.y;s<=i.y;s++){if(s>=0&&s<l){const e=Math.max(0,Math.min(Math.floor(u),h-1)),i=Math.max(0,Math.min(Math.floor(p),h-1));for(let l=Math.min(e,i);l<=Math.max(e,i);l++){const e=4*(s*h+l);e>=0&&e<t.length-3&&(t[e]=o,t[e+1]=n,t[e+2]=a,t[e+3]=r)}}u+=c,p+=d}}function fillFlatTopTriangle(t,e,i,s,o,n,a,r,h,l){const c=(s.x-e.x)/(s.y-e.y||1),d=(s.x-i.x)/(s.y-i.y||1);let u=s.x,p=s.x;for(let i=s.y;i>e.y;i--)if(i>=0&&i<l){u-=c,p-=d;const e=Math.max(0,Math.min(Math.floor(u),h-1)),s=Math.max(0,Math.min(Math.floor(p),h-1));for(let l=Math.min(e,s);l<=Math.max(e,s);l++){const e=4*(i*h+l);e>=0&&e<t.length-3&&(t[e]=o,t[e+1]=n,t[e+2]=a,t[e+3]=r)}}}function drawLine(t,e,i,s,o,n){const a=s[0],r=s[1],h=s[2],l=s[3]||255;let c=e.x,d=e.y,u=i.x,p=i.y;const g=Math.abs(u-c),_=Math.abs(p-d),f=c<u?1:-1,m=d<p?1:-1;let x=g-_;for(;;){if(c>=0&&c<o&&d>=0&&d<n){const e=4*(d*o+c);if(e>=0&&e<t.length-3){const i=l/255;t[e]=Math.round(t[e]*(1-i)+a*i),t[e+1]=Math.round(t[e+1]*(1-i)+r*i),t[e+2]=Math.round(t[e+2]*(1-i)+h*i),t[e+3]=255}}if(c===u&&d===p)break;const e=2*x;e>-_&&(x-=_,c+=f),e<g&&(x+=g,d+=m)}}class Patterns{static void(t,e,i={}){const{background:s=[255,255,255,255],foreground:o=[0,0,200,255]}=i,n=new Uint8ClampedArray(t*e*4);for(let t=0;t<n.length;t+=4)n[t]=s[0],n[t+1]=s[1],n[t+2]=s[2],n[t+3]=s[3];return n}static solidGrid(t,e,i={}){const{spacing:s=8,background:o=[0,0,0,0],foreground:n=[128,128,128,255]}=i,a=new Uint8ClampedArray(t*e*4);for(let i=0;i<e;i++){const e=i%s==0;for(let r=0;r<t;r++){const h=4*(i*t+r),l=r%s==0||e?n:o;a[h]=l[0],a[h+1]=l[1],a[h+2]=l[2],a[h+3]=l[3]}}return a}static checkerboard(t,e,i={}){const{cellSize:s=8,color1:o=[0,0,0,255],color2:n=[255,255,255,255]}=i,a=new Uint8ClampedArray(t*e*4);for(let i=0;i<e;i++){const e=Math.floor(i/s);for(let r=0;r<t;r++){const h=(Math.floor(r/s)+e)%2==0?o:n,l=4*(i*t+r);a.set(h,l)}}return a}static stripes(t,e,i={}){const{spacing:s=4,thickness:o=1,background:n=[0,0,0,0],foreground:a=[255,255,0,255]}=i,r=new Uint8ClampedArray(t*e*4);for(let i=0;i<e;i++)for(let e=0;e<t;e++){const h=(e+i)%s<o,l=4*(i*t+e);r.set(h?a:n,l)}return r}static honeycomb(t,e,i={}){const{radius:s=10,lineWidth:o=1,foreground:n=[255,255,255,255],background:a=[0,0,0,255]}=i,r=new Uint8ClampedArray(t*e*4);for(let t=0;t<r.length;t+=4)r[t]=a[0],r[t+1]=a[1],r[t+2]=a[2],r[t+3]=a[3];const h=Math.floor(t/2),l=Math.floor(e/2),c=(t,e,i,s,o)=>{const n=Math.abs(t-i),a=Math.abs(e-s),r=o*Math.sqrt(3)/2;return!(a>r)&&(!(n>o)&&o*r*2>=o*a*2+r*n)},d=s-o,u=s*Math.sqrt(3),p=Math.max(0,Math.floor(h-s-1)),g=Math.min(t-1,Math.ceil(h+s+1)),_=Math.max(0,Math.floor(l-u/2-1)),f=Math.min(e-1,Math.ceil(l+u/2+1));for(let e=_;e<=f;e++)for(let i=p;i<=g;i++){const o=c(i,e,h,l,s),a=d>0&&c(i,e,h,l,d);if(o&&!a){const s=4*(e*t+i);r[s]=n[0],r[s+1]=n[1],r[s+2]=n[2],r[s+3]=n[3]}}return r}static harlequin(t,e,i={}){const{size:s=20,spacing:o=0,background:n=[255,255,255,255],foreground:a=[0,0,0,255]}=i,r=new Uint8ClampedArray(t*e*4);for(let t=0;t<r.length;t+=4)r[t]=n[0],r[t+1]=n[1],r[t+2]=n[2],r[t+3]=n[3];const h=2*s,l=2*s,c=h+o,d=l+o;for(let i=-1;i<e/d+1;i++)for(let s=-1;s<t/c+1;s++){const o=s*c+c/2,n=i*d+d/2;if(!((i+s)%2==0))continue;const f=Math.max(0,Math.floor(o-h/2)),m=Math.min(t-1,Math.ceil(o+h/2)),x=Math.max(0,Math.floor(n-l/2)),M=Math.min(e-1,Math.ceil(n+l/2));for(let e=x;e<=M;e++)for(let i=f;i<=m;i++)if(u=i,p=e,g=o,_=n,Math.abs(u-g)/(h/2)+Math.abs(p-_)/(l/2)<=1){const s=4*(e*t+i);r[s]=a[0],r[s+1]=a[1],r[s+2]=a[2],r[s+3]=a[3]}}var u,p,g,_;return r}static circles(t,e,i={}){const{radius:s=10,lineWidth:o=2,spacing:n=5,background:a=[0,0,0,255],foreground:r=[255,255,255,255]}=i,h=new Uint8ClampedArray(t*e*4);for(let t=0;t<h.length;t+=4)h[t]=a[0],h[t+1]=a[1],h[t+2]=a[2],h[t+3]=a[3];const l=2*s+n,c=(t,e,i,s,o)=>{const n=t-i,a=e-s;return n*n+a*a<=o*o};for(let i=0;i<Math.ceil(e/l)+1;i++)for(let n=0;n<Math.ceil(t/l)+1;n++){const a=n*l+s,d=i*l+s;if(a<-s||a>t+s||d<-s||d>e+s)continue;const u=Math.max(0,Math.floor(a-s)),p=Math.min(t-1,Math.ceil(a+s)),g=Math.max(0,Math.floor(d-s)),_=Math.min(e-1,Math.ceil(d+s)),f=s-o;for(let e=g;e<=_;e++)for(let i=u;i<=p;i++){const o=c(i,e,a,d,s),n=c(i,e,a,d,f);if(o&&!n){const s=4*(e*t+i);h[s]=r[0],h[s+1]=r[1],h[s+2]=r[2],h[s+3]=r[3]}}}return h}static diamonds(t,e,i={}){const{size:s=16,squareSize:o=6,background:n=[255,255,255,255],foreground:a=[0,0,0,255],innerColor:r=[255,255,255,255]}=i,h=new Uint8ClampedArray(t*e*4);for(let t=0;t<h.length;t+=4)h[t]=n[0],h[t+1]=n[1],h[t+2]=n[2],h[t+3]=n[3];const l=s,c=(t,e,i,s,o)=>Math.abs(t-i)<=o/2&&Math.abs(e-s)<=o/2;for(let i=-1;i<e/l+1;i++)for(let s=-1;s<t/l+1;s++){const n=s*l+l/2,f=i*l+l/2;if(n<-l||n>t+l||f<-l||f>e+l)continue;const m=Math.max(0,Math.floor(n-l/2)),x=Math.min(t-1,Math.ceil(n+l/2)),M=Math.max(0,Math.floor(f-l/2)),y=Math.min(e-1,Math.ceil(f+l/2));for(let e=M;e<=y;e++)for(let i=m;i<=x;i++){const s=(d=i,u=e,p=n,g=f,_=l,Math.abs(d-p)+Math.abs(u-g)<=_/2),m=c(i,e,n,f,o);if(s){const s=4*(e*t+i);m?(h[s]=r[0],h[s+1]=r[1],h[s+2]=r[2],h[s+3]=r[3]):(h[s]=a[0],h[s+1]=a[1],h[s+2]=a[2],h[s+3]=a[3])}}}var d,u,p,g,_;return h}static cubes(t,e,i={}){const{size:s=10,spacing:o=2,background:n=[0,0,0,255],foreground:a=[255,100,0,255]}=i,r=new Uint8ClampedArray(t*e*4);for(let t=0;t<r.length;t+=4)r[t]=n[0],r[t+1]=n[1],r[t+2]=n[2],r[t+3]=n[3];const h=s+o;for(let i=0;i<Math.ceil(e/h)+1;i++)for(let o=0;o<Math.ceil(t/h)+1;o++){const n=o*h,l=i*h;if(!(n>=t||l>=e))for(let i=l;i<Math.min(l+s,e);i++)for(let e=n;e<Math.min(n+s,t);e++){const s=4*(i*t+e);r[s]=a[0],r[s+1]=a[1],r[s+2]=a[2],r[s+3]=a[3]}}return r}static cross(t,e,i={}){const{size:s=8,thickness:o=2,spacing:n=16,background:a=[255,255,255,255],foreground:r=[80,80,80,255]}=i,h=new Uint8ClampedArray(t*e*4);for(let t=0;t<h.length;t+=4)h[t]=a[0],h[t+1]=a[1],h[t+2]=a[2],h[t+3]=a[3];for(let i=0;i<Math.ceil(e/n)+1;i++)for(let a=0;a<Math.ceil(t/n)+1;a++){const l=a*n,c=i*n;if(l<-s||l>t+s||c<-s||c>e+s)continue;const d=l-s/2,u=l+s/2,p=c-o/2,g=c+o/2;for(let i=Math.max(0,Math.floor(p));i<Math.min(e,Math.ceil(g));i++)for(let e=Math.max(0,Math.floor(d));e<Math.min(t,Math.ceil(u));e++){const s=4*(i*t+e);h[s]=r[0],h[s+1]=r[1],h[s+2]=r[2],h[s+3]=r[3]}const _=l-o/2,f=l+o/2,m=c-s/2,x=c+s/2;for(let i=Math.max(0,Math.floor(m));i<Math.min(e,Math.ceil(x));i++)for(let e=Math.max(0,Math.floor(_));e<Math.min(t,Math.ceil(f));e++){const s=4*(i*t+e);h[s]=r[0],h[s+1]=r[1],h[s+2]=r[2],h[s+3]=r[3]}}return h}static mesh(t,e,i={}){const{spacing:s=20,lineWidth:o=2,background:n=[255,255,255,0],foreground:a=[0,0,0,255]}=i,r=new Uint8ClampedArray(t*e*4);for(let t=0;t<r.length;t+=4)r[t]=n[0],r[t+1]=n[1],r[t+2]=n[2],r[t+3]=n[3];for(let i=0;i<e;i++)for(let n=0;n<t;n++){const h=(n+i)%s,l=(n-i+e)%s;if(h<o||h>s-o||(l<o||l>s-o)){const e=4*(i*t+n);r[e]=a[0],r[e+1]=a[1],r[e+2]=a[2],r[e+3]=a[3]}}return r}static isometric(t,e,i={}){const{cellSize:s=20,lineWidth:o=1,background:n=[0,0,0,0],foreground:a=[0,255,0,255]}=i,r=new Uint8ClampedArray(t*e*4);for(let t=0;t<r.length;t+=4)r[t]=n[0],r[t+1]=n[1],r[t+2]=n[2],r[t+3]=n[3];const h=s,l=s/2;for(let i=0;i<e;i++)for(let e=0;e<t;e++){const s=e%h,n=i%l,c=n-s/2,d=n+s/2-l,u=Math.abs(c)<o/2,p=Math.abs(d)<o/2;if(u||p){const s=4*(i*t+e);r[s]=a[0],r[s+1]=a[1],r[s+2]=a[2],r[s+3]=a[3]}}return r}static weave(t,e,i={}){const{tileSize:s=40,lineWidth:o=2,background:n=[255,255,255,255],foreground:a=[0,0,0,255]}=i,r=new Uint8ClampedArray(t*e*4);for(let t=0;t<r.length;t+=4)r[t]=n[0],r[t+1]=n[1],r[t+2]=n[2],r[t+3]=n[3];for(let i=0;i<e;i++)for(let e=0;e<t;e++){const n=e%s,h=i%s,l=Math.abs((h+s/2)%s-s/2)<o/2,c=Math.abs((n+2*h+1.5*s)%s-s/2)<o/2,d=Math.abs((n-2*h+1.5*s)%s-s/2)<o/2;if(l||c||d){const s=4*(i*t+e);r[s]=a[0],r[s+1]=a[1],r[s+2]=a[2],r[s+3]=a[3]}}return r}static perlinNoise(t,e,i={}){const{background:s=[0,0,0,0],foreground:o=[255,255,255,255],scale:n=.1,octaves:a=4,persistence:r=.5,lacunarity:h=2,seed:l=65536*Math.random()}=i,c=new Uint8ClampedArray(t*e*4);Noise.seed(l);for(let i=0;i<e;i++)for(let e=0;e<t;e++){let l=1,d=1,u=0,p=0;for(let t=0;t<a;t++){const t=e*n*d,s=i*n*d;u+=Noise.perlin2(t,s)*l,p+=l,l*=r,d*=h}u/=p;const g=.5*(u+1),_=[Math.floor(s[0]+g*(o[0]-s[0])),Math.floor(s[1]+g*(o[1]-s[1])),Math.floor(s[2]+g*(o[2]-s[2])),Math.floor(s[3]+g*(o[3]-s[3]))],f=4*(i*t+e);c.set(_,f)}return c}static circularGradient(t,e,i={}){const{innerColor:s=[255,255,255,255],outerColor:o=[0,0,0,255],centerX:n=t/2,centerY:a=e/2,radius:r=Math.min(t,e)/2,fadeExponent:h=1}=i,l=new Uint8ClampedArray(t*e*4);for(let i=0;i<e;i++)for(let e=0;e<t;e++){const c=4*(i*t+e),d=e-n,u=i-a,p=Math.sqrt(d*d+u*u);let g=Math.min(p/r,1);g=Math.pow(g,h);const _=[Math.floor(s[0]+g*(o[0]-s[0])),Math.floor(s[1]+g*(o[1]-s[1])),Math.floor(s[2]+g*(o[2]-s[2])),Math.floor(s[3]+g*(o[3]-s[3]))];l.set(_,c)}return l}static noiseDisplacement(t,e,i={}){const{gridSpacing:s=16,gridColor:o=[255,255,255,255],background:n=[0,0,0,0],displacementScale:a=8,noiseScale:r=.05,gridThickness:h=1,seed:l=65536*Math.random()}=i,c=new Uint8ClampedArray(t*e*4);Noise.seed(l);for(let t=0;t<c.length;t+=4)c.set(n,t);for(let i=0;i<e;i++)for(let e=0;e<t;e++){const n=e+Noise.perlin2(e*r,i*r)*a,l=i+Noise.perlin2((e+31.416)*r,(i+27.182)*r)*a;if(n%s<h||n%s>s-h||(l%s<h||l%s>s-h)){const s=4*(i*t+e);c.set(o,s)}}return c}static dotPattern(t,e,i={}){const{dotSize:s=3,spacing:o=12,dotColor:n=[0,0,0,255],background:a=[255,255,255,255],useNoise:r=!1,noiseScale:h=.1,noiseDensity:l=.4,seed:c=65536*Math.random()}=i,d=new Uint8ClampedArray(t*e*4);r&&Noise.seed(c);for(let t=0;t<d.length;t+=4)d.set(a,t);if(r)for(let i=0;i<e;i++)for(let o=0;o<t;o++){if(.5*(Noise.perlin2(o*h,i*h)+1)>l)for(let a=-s;a<=s;a++)for(let r=-s;r<=s;r++){const h=o+r,l=i+a;if(h>=0&&h<t&&l>=0&&l<e){if(r*r+a*a<=s*s){const e=4*(l*t+h);d.set(n,e)}}}}else for(let i=Math.floor(o/2);i<e;i+=o)for(let a=Math.floor(o/2);a<t;a+=o)for(let o=-s;o<=s;o++)for(let r=-s;r<=s;r++){const h=a+r,l=i+o;if(h>=0&&h<t&&l>=0&&l<e){if(r*r+o*o<=s*s){const e=4*(l*t+h);d.set(n,e)}}}return d}static voronoi(t,e,i={}){const{cellCount:s=20,cellColors:o=null,edgeColor:n=[0,0,0,255],edgeThickness:a=1.5,seed:r=1e3*Math.random(),jitter:h=.5,baseColor:l=null,colorVariation:c=.3}=i,d=new Uint8ClampedArray(t*e*4);Noise.seed(r);const u=[],p=[],g=()=>{let t=1e4*Math.sin(.167*r+.423*u.length);return t-Math.floor(t)},_=Math.sqrt(s),f=t/_,m=e/_,x=t=>{if(l){const[e,i,s,o]=l,n=Math.max(e,i,s)/255,a=Math.min(e,i,s)/255,r=(n+a)/2;let h,d;if(n===a)h=d=0;else{const t=n-a;d=r>.5?t/(2-n-a):t/(n+a),h=n===e/255?(i/255-s/255)/t+(i/255<s/255?6:0):n===i/255?(s/255-e/255)/t+2:(e/255-i/255)/t+4,h/=6}const u=Noise.perlin2(.15*t,0)*c*.3,p=Noise.perlin2(0,.15*t)*c,_=Noise.perlin2(.15*t,.15*t)*c*.5;h=(h+u)%1,d=Math.min(1,Math.max(0,d*(1+p)));const f=Math.min(.9,Math.max(.1,r*(1+_)));let m,x,M;if(0===d)m=x=M=f;else{const t=(t,e,i)=>(i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+(e-t)*(2/3-i)*6:t),e=f<.5?f*(1+d):f+d-f*d,i=2*f-e;m=t(i,e,h+1/3),x=t(i,e,h),M=t(i,e,h-1/3)}const y=.05,b=()=>(2*g()-1)*y;return[Math.min(255,Math.max(0,Math.floor(255*m*(1+b())))),Math.min(255,Math.max(0,Math.floor(255*x*(1+b())))),Math.min(255,Math.max(0,Math.floor(255*M*(1+b())))),o]}{let e,i,s;const o=6*(.618033988749895*t%1),n=Math.floor(o),a=o-n,r=.5,h=.5*(1-a),l=.5*(1-(1-a));switch(n%6){case 0:e=.5,i=l,s=r;break;case 1:e=h,i=.5,s=r;break;case 2:e=r,i=.5,s=l;break;case 3:e=r,i=h,s=.5;break;case 4:e=l,i=r,s=.5;break;case 5:e=.5,i=r,s=h}return[Math.floor(255*e+50+100*g()),Math.floor(255*i+50+100*g()),Math.floor(255*s+50+100*g()),255]}};for(let t=0;t<_;t++)for(let e=0;e<_&&!(u.length>=s);e++){const i=e*f+f/2,s=t*m+m/2,n=(2*g()-1)*h*f,a=(2*g()-1)*h*m;u.push({x:Math.floor(i+n),y:Math.floor(s+a)}),o&&u.length-1<o.length?p.push(o[u.length-1]):p.push(x(u.length-1))}const M=(i,s,o,n)=>{let a=Math.abs(i-o),r=Math.abs(s-n);a=Math.min(a,t-a),r=Math.min(r,e-r);return.8*Math.sqrt(a*a+r*r)+.2*(a+r)};for(let i=0;i<e;i++)for(let s=0;s<t;s++){const o=4*(i*t+s);let r=1/0,h=1/0,l=0;for(let t=0;t<u.length;t++){const e=M(s,i,u[t].x,u[t].y);e<r?(h=r,r=e,l=t):e<h&&(h=e)}for(let o=0;o<u.length;o++)for(let n=-1;n<=1;n++)for(let a=-1;a<=1;a++){if(0===n&&0===a)continue;const c=u[o].x+n*t,d=u[o].y+a*e,p=Math.sqrt(Math.pow(s-c,2)+Math.pow(i-d,2));p<r?(h=r,r=p,l=o):p<h&&(h=p)}h-r<a?d.set(n,o):d.set(p[l],o)}return d}static penrose(t,e,i={}){return generatePenroseTilingPixels(t,e,i)}}const _Logger=class t{static disableAll(){t.enabledClasses=new Set,t.globalLevel=0}static disable(){t.enabled=!1}static enable(){t.enabled=!0}static setLevel(e){t.globalLevel=e}static enableFor(e){t.enabledClasses.add(e)}static disableFor(e){t.enabledClasses.delete(e)}static setOutput(e){t.output=e}constructor(t){this.className=t}static getLogger(e){return t.loggerz[e]||(t.loggerz[e]=new t(e)),t.loggerz[e]}_log(e,i,...s){t.enabled&&(t.globalLevel>=e||t.enabledClasses.has(this.className))&&t.output[i](`[${this.className}]`,...s)}log(...e){this._log(t.INFO,"log",...e)}warn(...e){this._log(t.WARN,"warn",...e)}error(...e){this._log(t.ERROR,"error",...e)}debug(...e){this._log(t.DEBUG,"log",...e)}table(...e){this._log(t.INFO,"table",...e)}groupCollapsed(e){t.enabled&&t.output.groupCollapsed(`[${this.className}] ${e}`)}groupEnd(){t.enabled&&t.output.groupEnd()}time(e){t.enabled&&t.output.time(`[${this.className}] ${e}`)}timeEnd(e){t.enabled&&t.output.timeEnd(`[${this.className}] ${e}`)}clear(){t.output.clear()}};__publicField(_Logger,"ERROR",1),__publicField(_Logger,"WARN",2),__publicField(_Logger,"INFO",3),__publicField(_Logger,"DEBUG",4),__publicField(_Logger,"globalLevel",_Logger.ERROR),__publicField(_Logger,"enabledClasses",new Set),__publicField(_Logger,"output",console),__publicField(_Logger,"enabled",!0),__publicField(_Logger,"loggerz",[]);let Logger=_Logger;class Loggable{constructor(t={}){this.name=t.name||this.constructor.name,this._logger=this.getLogger(t)}get logger(){return null==this._logger?this.getLogger():this._logger}trace(t="render"){this.logger.log(null==this.name?this.constructor.name:this.name,t,"x",this.x,"y",this.y,"w",this.width,"h",this.height,"opacity",this._opacity,"visible",this._visible,"active",this._active,"debug",this.debug)}getLogger(t){return Logger.getLogger(t.name||this.constructor.name)}}const _DebugTab=class t{static getInstance(){return t.instance||(t.instance=new t),t.instance}constructor(){this.createTab()}createTab(){this.tab=document.createElement("div"),Object.assign(this.tab.style,{position:"fixed",bottom:"0",left:"0",right:"0",height:"30px",backgroundColor:"#333",color:"#fff",padding:"5px",cursor:"pointer",fontFamily:"monospace",zIndex:"10000",display:"flex",justifyContent:"space-between",alignItems:"center"}),this.tab.innerText="Console";const t=document.createElement("div"),e=(t,e)=>{const i=document.createElement("button");return i.innerText=t,Object.assign(i.style,{marginLeft:"5px",padding:"2px 5px",fontFamily:"monospace",cursor:"pointer"}),i.onclick=e,i};this.paused=!1,this.scrollLock=!0,t.appendChild(e("Clear",(()=>this.consoleArea.value=""))),t.appendChild(e("Pause",(()=>this.paused=!this.paused))),t.appendChild(e("Scroll Lock",(()=>this.scrollLock=!this.scrollLock))),this.tab.appendChild(t),document.body.appendChild(this.tab),this.consoleArea=document.createElement("textarea"),Object.assign(this.consoleArea.style,{position:"fixed",bottom:"30px",left:"0",right:"0",height:"200px",display:"none",backgroundColor:"#111",color:"#0f0",fontFamily:"monospace",zIndex:"9999",padding:"10px",resize:"none"}),this.consoleArea.readOnly=!0,document.body.appendChild(this.consoleArea),this.tab.onclick=t=>{t.target===this.tab&&(this.consoleArea.style.display="none"===this.consoleArea.style.display?"block":"none")}}appendMessage(t,e,...i){if(this.paused)return;const s=`[${t.toUpperCase()}] ${e} ${i.join(" ")}\n`;this.consoleArea.value+=s,this.scrollLock&&(this.consoleArea.scrollTop=this.consoleArea.scrollHeight)}log(t,...e){this.appendMessage("log",t,...e)}warn(t,...e){this.appendMessage("warn",t,...e)}error(t,...e){this.appendMessage("error",t,...e)}table(t){const e=JSON.stringify(t,null,2);this.appendMessage("table",e)}groupCollapsed(t){this.appendMessage("group",`Group Start: ${t}`)}groupEnd(){this.appendMessage("group","Group End")}time(t){this[`time_${t}`]=performance.now()}timeEnd(t){const e=(performance.now()-this[`time_${t}`]).toFixed(2);this.appendMessage("time",`${t}: ${e} ms`)}};__publicField(_DebugTab,"instance");let DebugTab=_DebugTab;const _PainterEffects=class t{static dropShadow(t,e,i=0,s=0){Painter.ctx.shadowColor=t,Painter.ctx.shadowBlur=e,Painter.ctx.shadowOffsetX=i,Painter.ctx.shadowOffsetY=s}static clearShadow(){Painter.ctx.shadowColor="rgba(0, 0, 0, 0)",Painter.ctx.shadowBlur=0,Painter.ctx.shadowOffsetX=0,Painter.ctx.shadowOffsetY=0}static setAlpha(t){Painter.ctx.globalAlpha=t}static setBlendMode(t){Painter.ctx.globalCompositeOperation=t}static clipRect(t,e,i,s){Painter.ctx.beginPath(),Painter.ctx.rect(t,e,i,s),Painter.ctx.clip()}static clipCircle(t,e,i){Painter.ctx.beginPath(),Painter.shapes.arc(t,e,i,0,2*Math.PI),Painter.ctx.clip()}static blurRegion(t,e,i,s,o){const n=Painter.ctx.filter;Painter.ctx.filter=`blur(${o}px)`;const a=Painter.ctx.getImageData(t,e,i,s);Painter.ctx.putImageData(a,t,e),Painter.ctx.filter=n}static createGlow(e,i,s={}){const o="glow-"+Math.random().toString(36).substr(2,9),n={id:o,type:"glow",active:!0,time:0,color:e,blur:i,options:{...{pulseSpeed:0,pulseMin:.5*i,pulseMax:1.5*i,colorShift:0},...s},update(t){return Object.assign(this,t),this},stop(){return this.active=!1,t._activeEffects.delete(this.id),this},apply(){if(!this.active)return;let t=this.blur,e=this.color;if(this.options.pulseSpeed>0){const e=.5*Math.sin(this.time*this.options.pulseSpeed)+.5;t=this.options.pulseMin+e*(this.options.pulseMax-this.options.pulseMin)}return this.options.colorShift>0&&(e=e.replace("hue",this.time*this.options.colorShift%360)),Painter.ctx.shadowColor=e,Painter.ctx.shadowBlur=t,Painter.ctx.shadowOffsetX=0,Painter.ctx.shadowOffsetY=0,this.time+=1/60,this}};return t._activeEffects.set(o,n),t._startAnimationLoop(),n}static _startAnimationLoop(){if(null!==t._animationId)return;const e=()=>{if(t._activeEffects.forEach((t=>{t.active&&t.apply()})),0===t._activeEffects.size)return cancelAnimationFrame(t._animationId),void(t._animationId=null);t._animationId=requestAnimationFrame(e)};t._animationId=requestAnimationFrame(e)}static clearAllEffects(){t._activeEffects.forEach((t=>t.stop())),t._activeEffects.clear(),Painter.ctx.shadowColor="rgba(0, 0, 0, 0)",Painter.ctx.shadowBlur=0,Painter.ctx.shadowOffsetX=0,Painter.ctx.shadowOffsetY=0,Painter.ctx.filter="none",Painter.ctx.globalAlpha=1,Painter.ctx.globalCompositeOperation="source-over"}};__publicField(_PainterEffects,"_activeEffects",new Map),__publicField(_PainterEffects,"_animationId",null);let PainterEffects=_PainterEffects;class PainterImages{static draw(t,e=0,i=0,{width:s,height:o,crop:n=null,anchor:a="topâ€‘left",rotation:r=0,scaleX:h=1,scaleY:l=1,flipX:c=!1,flipY:d=!1,alpha:u=1,smoothing:p=!0}={}){const g=Painter.ctx;if(!g||!t)return;const _=s??(n?n.sw:t.width??t.videoWidth),f=o??(n?n.sh:t.height??t.videoHeight),m=-_*({left:0,center:.5,right:1}[a.split("-").pop()]??0),x=-f*({top:0,center:.5,bottom:1}[a.split("-")[0]]??0);if(g.save(),g.imageSmoothingEnabled=p,g.globalAlpha*=u,g.translate(e,i),r&&g.rotate(r),(c||d)&&g.scale(c?-1:1,d?-1:1),g.scale(h,l),n){const{sx:e,sy:i,sw:s,sh:o}=n;g.drawImage(t,e,i,s,o,m,x,_,f)}else g.drawImage(t,m,x,_,f);g.restore()}static blit(t,e,i,s,o){this.draw(t,e,i,{width:s,height:o})}static createPattern(t,e="repeat"){return Painter.ctx.createPattern(t,e)}static fillPattern(t,e,i,s,o){const n=Painter.ctx;n.save(),n.fillStyle=t,n.fillRect(e,i,s,o),n.restore()}static createImageData(t,e){return Painter.ctx.createImageData(t,e)}static cloneImageData(t){return new ImageData(new Uint8ClampedArray(t.data),t.width,t.height)}static getImageData(t,e,i,s){return Painter.ctx.getImageData(t,e,i,s)}static putImageData(t,e,i,s=0,o=0,n=t.width,a=t.height){Painter.ctx.putImageData(t,e,i,s,o,n,a)}static mapPixels(t,e){const i=t.data;for(let t=0;t<i.length;t+=4){const s=t>>2,o=e(i[t],i[t+1],i[t+2],i[t+3],s);o&&([i[t],i[t+1],i[t+2],i[t+3]]=o)}return t}static setPixel(t,e,i,s,o,n,a=255){const r=4*(i*t.width+e),h=t.data;h[r]=s,h[r+1]=o,h[r+2]=n,h[r+3]=a}static async toBitmap({type:t="image/png",quality:e=.92}={}){const i=Painter.ctx.canvas,s=await i.convertToBlob({type:t,quality:e});return createImageBitmap(s)}static async createBitmap(t){return createImageBitmap(t)}static toImageData(t,e,i){if(t.length!==e*i*4)throw new Error("Invalid RGBA array size for given dimensions");return new ImageData(t,e,i)}static async createImageBitmapFromPixels(t,e,i){const s=this.toImageData(t,e,i);return await createImageBitmap(s)}static createPatternFromImageData(t,e="repeat"){const i=document.createElement("canvas");i.width=t.width,i.height=t.height;const s=i.getContext("2d");return s.putImageData(t,0,0),s.createPattern(i,e)}static createPatternFromPixels(t,e,i,s="repeat"){const o=this.toImageData(t,e,i);return this.createPatternFromImageData(o,s)}}class PainterLines{static path(t,e,i,s=1){const o=Painter.ctx;o.beginPath();for(const e of t){const[t,...i]=e;"M"===t?o.moveTo(...i):"L"===t?o.lineTo(...i):"C"===t?o.bezierCurveTo(...i):"Q"===t?o.quadraticCurveTo(...i):"Z"===t&&o.closePath()}e&&(o.fillStyle=e,Painter.colors.fill(e)),i&&(o.strokeStyle=i,o.lineWidth=s,Painter.colors.stroke())}static line(t,e,i,s,o,n){Painter.ctx.beginPath(),Painter.ctx.moveTo(t,e),Painter.ctx.lineTo(i,s),Painter.colors.stroke(o,n)}static beginPath(){Painter.ctx.beginPath()}static closePath(){Painter.ctx.closePath()}static moveTo(t,e){Painter.ctx.moveTo(t,e)}static lineTo(t,e){Painter.ctx.lineTo(t,e)}static bezierCurveTo(t,e,i,s,o,n){Painter.ctx.bezierCurveTo(t,e,i,s,o,n)}static dashedLine(t,e,i,s,o,n,a){Painter.ctx.beginPath(),n&&(Painter.ctx.strokeStyle=n),void 0!==a&&(Painter.ctx.lineWidth=a),Painter.ctx.setLineDash(o),Painter.ctx.moveTo(t,e),Painter.ctx.lineTo(i,s),Painter.colors.stroke(),Painter.ctx.setLineDash([])}static dottedLine(t,e,i,s,o=2,n=5,a){return Painter.lines.dashedLine(t,e,i,s,[o,n],a,o)}static setLineDash(t){Painter.ctx.setLineDash(t)}static resetLineDash(){Painter.ctx.setLineDash([])}static setLineWidth(t){Painter.ctx.lineWidth=t}static quadraticCurve(t,e,i,s,o,n,a,r){Painter.ctx.beginPath(),Painter.ctx.moveTo(t,e),Painter.ctx.quadraticCurveTo(i,s,o,n),a&&(Painter.ctx.strokeStyle=a),void 0!==r&&(Painter.ctx.lineWidth=r),Painter.colors.stroke()}}class PainterOpacity{static pushOpacity(t){const e=this._opacityStack[this._opacityStack.length-1]*t;this._opacityStack.push(e),Painter.logger.log("NEXT OPACITY WILL BE",e),Painter.effects.setAlpha(e)}static popOpacity(){if(this._opacityStack.length>1){this._opacityStack.pop();const t=this._opacityStack[this._opacityStack.length-1];Painter.logger.log("NEXT OPACITY WILL BE",t),Painter.effects.setAlpha(t)}}static _clone(){this._opacityStack=[...this._opacityStack]}static saveOpacityState(){this._opacityStateBackup=[...this._opacityStack]}static restoreOpacityState(){this._opacityStateBackup&&(this._opacityStack=this._opacityStateBackup,delete this._opacityStateBackup)}}__publicField(PainterOpacity,"_opacityStack",[1]);class PainterShapes{static rect(t,e,i,s,o){const n=Painter.ctx.fillStyle;Painter.colors.fill(o),Painter.ctx.fillRect(t,e,i,s),Painter.ctx.fillStyle=n}static outlineRect(t,e,i,s,o,n=1){const a=Painter.ctx.strokeStyle,r=Painter.ctx.lineWidth;Painter.ctx.strokeStyle=o,Painter.ctx.lineWidth=n,Painter.ctx.strokeRect(t,e,i,s),Painter.ctx.strokeStyle=a,Painter.ctx.lineWidth=r}static roundRect(t,e,i,s,o=0,n,a,r){let h;h="number"==typeof o?[o,o,o,o]:Array.isArray(o)?4===o.length?o:[o[0]||0,o[1]||o[0]||0,o[2]||o[0]||0,o[3]||o[1]||o[0]||0]:[0,0,0,0];const[l,c,d,u]=h,p=t+i,g=e+s;Painter.lines.beginPath(),Painter.lines.moveTo(t+l,e),Painter.lines.lineTo(p-c,e),this.arc(p-c,e+c,c,-Math.PI/2,0),Painter.lines.lineTo(p,g-d),this.arc(p-d,g-d,d,0,Math.PI/2),Painter.lines.lineTo(t+u,g),this.arc(t+u,g-u,u,Math.PI/2,Math.PI),Painter.lines.lineTo(t,e+l),this.arc(t+l,e+l,l,Math.PI,-Math.PI/2),Painter.lines.closePath(),n&&(Painter.fillStyle=n,Painter.colors.fill(n)),a&&Painter.colors.stroke(a,r)}static fillRoundRect(t,e,i,s,o=0,n){this.roundRect(t,e,i,s,o,n,null)}static strokeRoundRect(t,e,i,s,o=0,n,a){this.roundRect(t,e,i,s,o,null,n,a)}static fillCircle(t,e,i,s){Painter.logger.log("PainterShapes.fillCircle",t,e,i,s),Painter.lines.beginPath(),this.arc(t,e,i,0,2*Math.PI),Painter.colors.fill(s)}static arc(t,e,i,s,o,n){Painter.ctx.arc(t,e,i,s,o,n)}static strokeCircle(t,e,i,s,o){Painter.lines.beginPath(),this.arc(t,e,i,0,2*Math.PI),Painter.colors.stroke(s,o)}static fillEllipse(t,e,i,s,o=0,n){Painter.lines.beginPath(),this.ellipse(t,e,i,s,o,0,2*Math.PI),n&&(Painter.fillStyle=n),Painter.colors.fill(n)}static strokeEllipse(t,e,i,s,o=0,n,a){Painter.lines.beginPath(),this.ellipse(t,e,i,s,o,0,2*Math.PI),n&&(Painter.strokeStyle=n),void 0!==a&&(Painter.lineWidth=a),Painter.colors.stroke(n,a)}static ellipse(t,e,i,s,o,n,a,r){Painter.ctx.ellipse(t,e,i,s,o,n,a,r)}static polygon(t,e,i,s){if(!(t.length<2)){Painter.lines.beginPath(),Painter.lines.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++)Painter.lines.lineTo(t[e].x,t[e].y);Painter.lines.closePath(),e&&Painter.colors.fill(e),i&&Painter.colors.stroke(i,s)}}}class PainterText{static font(){return Painter.ctx.font}static setFont(t){Painter.ctx.font=t}static setTextAlign(t){Painter.ctx.textAlign=t}static setTextBaseline(t){Painter.ctx.textBaseline=t}static fillText(t,e,i,s,o){s&&(Painter.ctx.fillStyle=s),o&&(Painter.ctx.font=o),Painter.ctx.fillText(t,e,i)}static strokeText(t,e,i,s,o,n){s&&(Painter.ctx.strokeStyle=s),void 0!==o&&(Painter.ctx.lineWidth=o),n&&(Painter.ctx.font=n),Painter.ctx.strokeText(t,e,i)}static measureTextDimensions(t,e,i="start",s="alphabetic"){e&&(Painter.ctx.font=e);const o=Painter.ctx.measureText(t);let n=0;return"middle"===s&&(n=-1.5),{width:o.width,height:o.actualBoundingBoxAscent+o.actualBoundingBoxDescent,verticalAdjustment:n}}static measureTextWidth(t,e){return e&&(Painter.ctx.font=e),Painter.ctx.measureText(t).width}static outlinedText(t,e,i,s,o,n,a){a&&(Painter.ctx.font=a),Painter.ctx.strokeStyle=o,Painter.ctx.lineWidth=n,Painter.ctx.strokeText(t,e,i),Painter.ctx.fillStyle=s,Painter.ctx.fillText(t,e,i)}static wrappedText(t,e,i,s,o,n,a){n&&(Painter.ctx.fillStyle=n),a&&(Painter.ctx.font=a);const r=t.split(" ");let h="",l="",c=1;for(let t=0;t<r.length;t++){l=h+r[t]+" ";Painter.ctx.measureText(l).width>s&&t>0?(Painter.ctx.fillText(h,e,i),h=r[t]+" ",i+=o,c++):h=l}return Painter.ctx.fillText(h,e,i),c*o}static textOnPath(t,e,i,s,o=!1){if(e.length<2)return;i&&(Painter.ctx.fillStyle=i),s&&(Painter.ctx.font=s);const n=t.split(""),a=n.map((t=>Painter.ctx.measureText(t).width));o&&(n.reverse(),a.reverse(),e.reverse());let r=0;for(let t=1;t<e.length;t++){const i=e[t].x-e[t-1].x,s=e[t].y-e[t-1].y;r+=Math.sqrt(i*i+s*s)}let h=(r-a.reduce(((t,e)=>t+e),0))/2;h<0&&(h=0);let l=h;for(let t=0;t<n.length;t++){const i=a[t],{x:s,y:o,angle:r}=getPositionOnPath(e,l);Painter.ctx.save(),Painter.ctx.translate(s,o),Painter.ctx.rotate(r),Painter.ctx.fillText(n[t],0,0),Painter.ctx.restore(),l+=i}}static getPositionOnPath(t,e){let i=0;for(let s=1;s<t.length;s++){const o=t[s-1],n=t[s],a=n.x-o.x,r=n.y-o.y,h=Math.sqrt(a*a+r*r);if(i+h>=e){const t=(e-i)/h;return{x:o.x+a*t,y:o.y+r*t,angle:Math.atan2(r,a)}}i+=h}const s=t[t.length-1],o=t[t.length-2],n=Math.atan2(s.y-o.y,s.x-o.x);return{x:s.x,y:s.y,angle:n}}}const _Painter=class t{static get colors(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"colors",__privateGet(this,__colors)),__privateGet(this,__colors)}static get effects(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"effects",__privateGet(this,__effects)),__privateGet(this,__effects)}static get img(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"img",__privateGet(this,__img)),__privateGet(this,__img)}static get lines(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"lines",__privateGet(this,__lines)),__privateGet(this,__lines)}static get opacity(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"opacity",__privateGet(this,__opacity)),__privateGet(this,__opacity)}static get shapes(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"shapes",__privateGet(this,__shapes)),__privateGet(this,__shapes)}static get text(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"text",__privateGet(this,__text)),__privateGet(this,__text)}static set ctx(t){this._ctx=t}static get ctx(){if(!this._ctx)throw new Error("Cannot access Painter.ctx before initialization!");return this._ctx}static init(e){this._ctx=e,this.saveStack=[],__privateSet(this,__colors,PainterColors),__privateSet(this,__effects,PainterEffects),__privateSet(this,__img,PainterImages),__privateSet(this,__lines,PainterLines),__privateSet(this,__opacity,PainterOpacity),__privateSet(this,__shapes,PainterShapes),__privateSet(this,__text,PainterText),t.logger=Logger.getLogger("Painter"),t.saveStack=[]}static save(){const e=((new Error).stack.split("\n")[2]||"").match(/at\s+(\w+)\.(\w+)/),i=e?`${e[1]}.${e[2]}`:"unknown";this.saveStack.push(i),this.logger.log(`Painter.save() by: ${i}`),this.ctx.save(),t.opacity.saveOpacityState()}static restore(){if(0===this.saveStack.length)return void console.error("PAINTER ERROR: restore() without matching save()!");const e=this.saveStack.pop();this.logger.log(`Painter.restore() balancing save from: ${e}`),this.ctx.restore(),this.ctx.fillStyle=null,this.ctx.strokeStyle=null,t.opacity.restoreOpacityState()}static translateTo(t,e){(isNaN(t)||void 0===t)&&(t=0),(isNaN(e)||void 0===e)&&(e=0),this.logger.log("moveTo",t,e),this.ctx.translate(t,e)}static resetPosition(){this.logger.log("resetPosition");const t=this.ctx.getTransform();this.ctx.setTransform(t.a,t.b,t.c,t.d,0,0)}static withPosition(t,e,i){this.logger.log("withPosition",t,e),this.save(),this.translateTo(t,e),i(),this.restore()}static clear(e=0,i=0,s=t.ctx.canvas.width,o=t.ctx.canvas.height){t.ctx.clearRect(e,i,s,o)}static translate(e,i){t.ctx.translate(e,i)}static rotate(e){t.logger.log("Painter.rotate",e),t.ctx.rotate(e)}static scale(e,i){t.logger.log("Painter.scale",e,i),t.ctx.scale(e,i)}};__colors=new WeakMap,__effects=new WeakMap,__img=new WeakMap,__lines=new WeakMap,__opacity=new WeakMap,__shapes=new WeakMap,__text=new WeakMap,_Painter_static=new WeakSet,checkInitialized_fn=function(t,e){if(!e)throw new Error(`Painter.${t} is not initialized. Call Painter.init(ctx) first.`)},__privateAdd(_Painter,_Painter_static),__privateAdd(_Painter,__colors,null),__privateAdd(_Painter,__effects,null),__privateAdd(_Painter,__img,null),__privateAdd(_Painter,__lines,null),__privateAdd(_Painter,__opacity,null),__privateAdd(_Painter,__shapes,null),__privateAdd(_Painter,__text,null),__publicField(_Painter,"logger");let Painter=_Painter;class PainterColors{static fill(t){Painter.logger.log("PainterColors.fill - before:",Painter.ctx.fillStyle,"setting to:",t),Painter.ctx.fillStyle,Painter.ctx.fillStyle=t,Painter.ctx.fill(),Painter.logger.log("PainterColors.fill - after:",Painter.ctx.fillStyle)}static strokeOptions(t){t.color&&(Painter.ctx.strokeStyle=t.color),void 0!==t.lineWidth&&(Painter.ctx.lineWidth=t.lineWidth),t.lineCap&&(Painter.ctx.lineCap=t.lineCap),t.lineJoin&&(Painter.ctx.lineJoin=t.lineJoin),t.strokeStyle&&(Painter.ctx.strokeStyle=t.strokeStyle)}static stroke(t,e){t&&(Painter.ctx.strokeStyle=t),void 0!==e&&(Painter.ctx.lineWidth=e),Painter.ctx.stroke()}static setFillColor(t){Painter.ctx.fillStyle=t}static setStrokeColor(t){Painter.ctx.strokeStyle=t}static randomColorRGB(){const t=Math.floor(360*Math.random()),e=70+Math.floor(30*Math.random()),i=50+Math.floor(20*Math.random());return Painter.colors.hslToRgb(t,e,i)}static randomColorRGBA(t=255){const[e,i,s]=this.randomColorRGB();return[e,i,s,t]}static randomColorHSL(){return`hsl(${360*Math.random()}, 100%, 50%)`}static randomColorHSL_RGBA(t=255){const e=360*Math.random(),i=60+40*Math.random(),s=40+40*Math.random(),[o,n,a]=Painter.colors.hslToRgb(e,i,s);return[o,n,a,t]}static randomColorHEX(){return"#"+(1048575*Math.random()*1e6).toString(16).slice(0,6)}static parseColorString(t){if((t=t.trim().toLowerCase()).startsWith("hsl")){const e=t.replace(/hsla?\(|\)/g,""),[i,s,o]=e.split(",").map((t=>t.trim())),n=parseFloat(i),a=parseFloat(s)/100,r=parseFloat(o)/100;return Painter.colors.hslToRgb(n,a,r)}if(t.startsWith("#"))return hexToRgb(t);if(t.startsWith("rgb")){const e=t.replace(/rgba?\(|\)/g,""),[i,s,o]=e.split(",").map((t=>parseInt(t.trim())));return[i,s,o]}return[0,0,0]}static rgbArrayToCSS([t,e,i]){return`rgb(${Math.round(t)}, ${Math.round(e)}, ${Math.round(i)})`}static hslToRgb(t,e,i){i/=100;const s=e=>(e+t/30)%12,o=(e/=100)*Math.min(i,1-i),n=t=>i-o*Math.max(-1,Math.min(s(t)-3,Math.min(9-s(t),1)));return[Math.round(255*n(0)),Math.round(255*n(8)),Math.round(255*n(4))]}static rgbToHsl(t,e,i){t/=255,e/=255,i/=255;const s=Math.max(t,e,i),o=Math.min(t,e,i),n=s-o;let a=0,r=0,h=(s+o)/2;if(0!==n)switch(r=n/(1-Math.abs(2*h-1)),s){case t:a=((e-i)/n+6)%6*60;break;case e:a=60*((i-t)/n+2);break;case i:a=60*((t-e)/n+4)}return[a%360,r,h]}static hexToRgb(t){const e=t.replace("#","");return[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}static linearGradient(t,e,i,s,o){const n=Painter.ctx.createLinearGradient(t,e,i,s);for(const t of o)n.addColorStop(t.offset,t.color);return n}static radialGradient(t,e,i,s,o,n,a){const r=Painter.ctx.createRadialGradient(t,e,i,s,o,n);for(const t of a)r.addColorStop(t.offset,t.color);return r}static verticalGradient(t,e,i,s,o){return Painter.colors.linearGradient(t,e,t,e+s,o)}static horizontalGradient(t,e,i,s,o){return Painter.colors.linearGradient(t,e,t+i,e,o)}static conicGradient(t,e,i,s){if("function"==typeof Painter.ctx.createConicGradient){const o=Painter.ctx.createConicGradient(i,t,e);for(const t of s)o.addColorStop(t.offset,t.color);return o}return null}static rgba(t,e,i,s=1){return`rgba(${Math.round(t)}, ${Math.round(e)}, ${Math.round(i)}, ${s})`}static hsl(t,e,i){return`hsl(${t}, ${e}%, ${i}%)`}static hsla(t,e,i,s){return`hsla(${t}, ${e}%, ${i}%, ${s})`}}class Euclidian extends Loggable{constructor(t={}){super(t),this._x="number"==typeof t.x?t.x:0,this._y="number"==typeof t.y?t.y:0,this._width="number"==typeof t.width?t.width:0,this._height="number"==typeof t.height?t.height:0,this.logger.log("Euclidian",this._x,this._y,this._width,this._height)}get x(){return this._x}set x(t){this.validateProp(t,"x"),this._x=t}get y(){return this._y}set y(t){this.validateProp(t,"y"),this._y=t}get width(){return this._width}set width(t){this.validateProp(t,"width"),this._width=Math.max(0,t)}get height(){return this._height}set height(t){this.validateProp(t,"height"),this._height=Math.max(0,t)}get debug(){return this._debug}set debug(t){this.validateProp(t,"debug"),this._debug=Boolean(t)}get debugColor(){return this._debugColor}set debugColor(t){this.validateProp(t,"debugColor"),this._debugColor=t}validateProp(t,e){if(null==t)throw new Error("Invalid property value: "+e+" "+t)}}class Geometry2d extends Euclidian{constructor(t={}){super(t),this._minX=t.minX,this._maxX=t.maxX,this._minY=t.minY,this._maxY=t.maxY,this._boundsDirty=!0,this._cachedBounds=null,this.crisp=t.crisp??!0,this.logger.log("Geometry2d",this.x,this.y,this.width,this.height)}update(){this.trace("Geometry2d.update"),this.applyConstraints(),this.getBounds()}get minX(){return this._minX}set minX(t){this._minX=t}get maxX(){return this._maxX}set maxX(t){this._maxX=t}get minY(){return this._minY}set minY(t){this._minY=t}get maxY(){return this._maxY}set maxY(t){this._maxY=t}get boundsDirty(){return this._boundsDirty}applyConstraints(){void 0!==this._minX&&(this.x=Math.max(this.x,this._minX)),void 0!==this._maxX&&(this.x=Math.min(this.x,this._maxX)),void 0!==this._minY&&(this.y=Math.max(this.y,this._minY)),void 0!==this._maxY&&(this.y=Math.min(this.y,this._maxY)),this.crisp&&(this.x=Math.round(this.x),this.y=Math.round(this.y),this.width=Math.round(this.width),this.height=Math.round(this.height))}getBounds(){return!this._boundsDirty&&this._cachedBounds||(this._cachedBounds=this.calculateBounds(),this._boundsDirty=!1),this._cachedBounds}calculateBounds(){return{width:this.width,height:this.height,x:this.x,y:this.y}}getLocalPosition(){let t=0,e=0;return this.parent&&(t=this.parent.x,e=this.parent.y),{x:this.x-t-this.width/2,y:this.y-e-this.height/2}}markBoundsDirty(){this._boundsDirty=!0}validateProp(t,e){super.validateProp(t,e);t!==this[e]&&this.markBoundsDirty()}setTopLeft(t,e){return this.x=t+this.width/2,this.y=e+this.height/2,this}setCenter(t,e){return this.x=t,this.y=e,this}}class Traceable extends Geometry2d{constructor(t={}){super(t),this._debug=Boolean(t.debug),this._debugColor="string"==typeof t.debugColor?t.debugColor:"#0f0",this.logger.log("Traceable",this.x,this.y,this.width,this.height)}async drawDebug(){if(!this._debug)return;const t=this.getDebugBounds();this.logger.log(this.constructor.name,"drawDebug",t.x,t.y,t.width,t.height),Painter.save(),Painter.scale(this.scaleX,this.scaleY),Painter.rotate(this.rotation),Painter.shapes.outlineRect(t.x,t.y,t.width,t.height,this._debugColor,2),Painter.restore()}getDebugBounds(){return{width:this.width,height:this.height,x:this.x-this.width/2,y:this.y-this.height/2}}trace(t="render"){this.logger.log(null==this.name?this.constructor.name:this.name,t,"x",this.x,"y",this.y,"w",this.width,"h",this.height,"opacity",this._opacity,"visible",this._visible,"active",this._active,"debug",this.debug)}}class Renderable extends Traceable{constructor(t={}){super(t),this._visible=!1!==t.visible,this._opacity="number"==typeof t.opacity?t.opacity:1,this._active=!1!==t.active,this.zIndex=t.zIndex??0,this._shadowColor=t.shadowColor??void 0,this._shadowBlur=t.shadowBlur??0,this._shadowOffsetX=t.shadowOffsetX??0,this._shadowOffsetY=t.shadowOffsetY??0,this._tick=0,this.logger.log("Renderable",this.x,this.y,this.width,this.height)}render(){var t;if(!this._visible||this._opacity<=0)return;const e=null!=(null==(t=this._anchor)?void 0:t.position);this._debug&&!e&&this.drawDebug(),Painter.save(),Painter.effects.setBlendMode(this._blendMode),Painter.opacity.pushOpacity(this._opacity),this.crisp?Painter.translateTo(Math.round(this.x),Math.round(this.y)):Painter.translateTo(this.x,this.y),this.applyShadow(Painter.ctx),"Renderable"!==this.constructor.name&&this.draw(),Painter.opacity.popOpacity(),Painter.restore(),this._debug&&e&&this.drawDebug()}draw(){this.drawDebug()}update(t){this.trace("Renderable.update"),this._tick+=t,super.update(t)}applyShadow(t){this._shadowColor&&(t.shadowColor=this._shadowColor,t.shadowBlur=this._shadowBlur,t.shadowOffsetX=this._shadowOffsetX,t.shadowOffsetY=this._shadowOffsetY)}get visible(){return this._visible}set visible(t){this._visible=Boolean(t)}get active(){return this._active}set active(t){this._active=Boolean(t)}get opacity(){return this._opacity}set opacity(t){this._opacity=Math.min(1,Math.max(0,"number"==typeof t?t:1))}get shadowColor(){return this._shadowColor}set shadowColor(t){this._shadowColor=t}get shadowBlur(){return this._shadowBlur}set shadowBlur(t){this._shadowBlur=t}get shadowOffsetX(){return this._shadowOffsetX}set shadowOffsetX(t){this._shadowOffsetX=t}get shadowOffsetY(){return this._shadowOffsetY}set shadowOffsetY(t){this._shadowOffsetY=t}get tick(){return this._tick}}class Transformable extends Renderable{constructor(t={}){super(t),this._rotation=t.rotation*Math.PI/180,this._scaleX=t.scaleX??1,this._scaleY=t.scaleY??1,this.logger.log("Transformable",this.x,this.y,this.width,this.height)}draw(){this.applyTransforms()}applyTransforms(){Painter.rotate(this._rotation),Painter.scale(this._scaleX,this._scaleY)}get rotation(){return this._rotation}set rotation(t){this._rotation=t*Math.PI/180,this.markBoundsDirty()}get scaleX(){return this._scaleX}set scaleX(t){this._scaleX=t,this.markBoundsDirty()}get scaleY(){return this._scaleY}set scaleY(t){this._scaleY=t,this.markBoundsDirty()}calculateBounds(){const t=this.width/2,e=this.height/2,i=[{x:-t,y:-e},{x:t,y:-e},{x:t,y:e},{x:-t,y:e}],s=Math.cos(this._rotation),o=Math.sin(this._rotation),n=i.map((({x:t,y:e})=>{t*=this._scaleX,e*=this._scaleY;const i=t*o+e*s;return{x:t*s-e*o+this.x,y:i+this.y}})),a=n.map((t=>t.x)),r=n.map((t=>t.y)),h=Math.min(...a),l=Math.max(...a),c=Math.min(...r),d=Math.max(...r);return{x:(h+l)/2,y:(c+d)/2,width:l-h,height:d-c}}}class Shape extends Transformable{constructor(t={}){super(t),this._color=t.color??null,this._stroke=t.stroke??null,this._lineWidth=t.lineWidth??1,this._lineJoin=t.lineJoin??"miter",this._lineCap=t.lineCap??"butt",this._miterLimit=t.miterLimit??10,this.logger.log("Shape",this.x,this.y,this.width,this.height)}get color(){return this._color}set color(t){this._color=t}get stroke(){return this._stroke}set stroke(t){this._stroke=t}get lineWidth(){return this._lineWidth}set lineWidth(t){this._lineWidth=Math.max(0,t)}get lineJoin(){return this._lineJoin}set lineJoin(t){this._lineJoin=t}get lineCap(){return this._lineCap}set lineCap(t){this._lineCap=t}get miterLimit(){return this._miterLimit}set miterLimit(t){this._miterLimit=t}}class Group extends Transformable{constructor(t={}){super(t),this._collection=new ZOrderedCollection({sortByZIndex:t.sortByZIndex||!0}),this._collection._owner=this,this._childrenVersion=0,this._cachedBounds=null,t.width=Math.max(0,t.width||0),t.height=Math.max(0,t.height||0),this.userDefinedWidth=t.width,this.userDefinedHeight=t.height,this.userDefinedDimensions=void 0!==t.width&&void 0!==t.height&&(t.width>0||t.height>0)}add(t){if(null==t||null==t)throw new Error("Object is null or undefined");if(!(t instanceof Transformable))throw new TypeError("Group can only add Transformable instances");return t.parent=this,this._collection.add(t),this._childrenVersion++,this.markBoundsDirty(),t}remove(t){const e=this._collection.remove(t);return e&&(t.parent=null,this._childrenVersion++,this.markBoundsDirty()),e}clear(){this._collection.clear(),this._childrenVersion++,this.markBoundsDirty()}bringToFront(t){return this._collection.bringToFront(t)}sendToBack(t){return this._collection.sendToBack(t)}bringForward(t){return this._collection.bringForward(t)}sendBackward(t){return this._collection.sendBackward(t)}draw(){super.draw(),this.logger.log("Group.draw chilren:",this.children.length);const t=this._collection.getSortedChildren();for(let e=0;e<t.length;e++){const i=t[e];i.visible&&(Painter.save(),i.render(),Painter.restore())}}update(t){this.logger.groupCollapsed("Group.update");const e=this._collection.getSortedChildren();for(let i=0;i<e.length;i++){const s=e[i];s.active&&"function"==typeof s.update&&s.update(t)}super.update(t),this.logger.groupEnd()}get children(){var t;return(null==(t=this._collection)?void 0:t.children)||[]}get width(){return this.userDefinedDimensions?this._width:this.getBounds().width}set width(t){const e=Math.max(0,t);this._width=e,this.userDefinedWidth=e,this.userDefinedDimensions=(this.userDefinedWidth>0||this.userDefinedHeight>0)&&void 0!==this.userDefinedWidth&&void 0!==this.userDefinedHeight,this.markBoundsDirty()}get height(){return this.userDefinedDimensions?this._height:this.getBounds().height}set height(t){const e=Math.max(0,t);this._height=e,this.userDefinedHeight=e,this.userDefinedDimensions=(this.userDefinedWidth>0||this.userDefinedHeight>0)&&void 0!==this.userDefinedWidth&&void 0!==this.userDefinedHeight,this.markBoundsDirty()}calculateBounds(){var t;if(this.userDefinedDimensions)return{x:this.x,y:this.y,width:this._width,height:this._height};if(!(null==(t=this.children)?void 0:t.length))return{x:this.x,y:this.y,width:0,height:0};let e=1/0,i=1/0,s=-1/0,o=-1/0;for(const t of this.children){const n=t.x,a=t.y,r=t.width,h=t.height,l=n-r/2,c=n+r/2,d=a-h/2,u=a+h/2;e=Math.min(e,l),s=Math.max(s,c),i=Math.min(i,d),o=Math.max(o,u)}const n=s-e,a=o-i;return{x:this.x,y:this.y,width:n,height:a}}getDebugBounds(){var t;const e=this.calculateBounds();let i=1/0,s=1/0;for(const t of this.children){const e=t.x,o=t.y,n=e-t.width/2,a=o-t.height/2;i=Math.min(i,n),s=Math.min(s,a)}return(null==(t=this.children)?void 0:t.length)||(i=this.x-e.width/2,s=this.y-e.height/2),{width:e.width,height:e.height,x:i,y:s}}}class Arc extends Shape{constructor(t,e,i,s={}){super(s),this.radius=t,this.startAngle=e,this.endAngle=i}draw(){super.draw(),Painter.lines.beginPath(),Painter.shapes.arc(0,0,this.radius,this.startAngle,this.endAngle,!1),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}getBounds(){const t=this.radius;return{x:this.x,y:this.y,width:2*t,height:2*t}}}class Circle extends Shape{constructor(t,e={}){super(e),this._radius=t,this.width=2*t,this.height=2*t}draw(){super.draw(),this.color&&Painter.shapes.fillCircle(0,0,this._radius,this.color),this.stroke&&Painter.shapes.strokeCircle(0,0,this._radius,this.stroke,this.lineWidth)}calculateBounds(){const t=2*this._radius;return this.trace("Circle.calculateBounds:"+t),{x:this.x,y:this.y,width:t,height:t}}get radius(){return this._radius}set radius(t){this.validateProp(t,"radius"),t!=this._radius&&(this._radius=t,this.width=2*t,this.height=2*t,this._boundsDirty=!0,this.calculateBounds())}}class Cloud extends Shape{constructor(t,e,i=40,s={}){super(t,e,s),this.size=i}draw(){super.draw();const t=this.size,e=[["M",-t,0],["C",-t,-t,0,-t,0,0],["C",0,1.2*-t,1.2*t,-t,t,0],["C",1.5*t,.5*t,.5*t,1.2*t,0,t],["C",.8*-t,1.3*t,1.2*-t,.3*t,-t,0],["Z"]];Painter.lines.path(e,this.fillColor,this.strokeColor,this.lineWidth)}getBounds(){const t=2*this.size;return{x:this.x,y:this.y,width:t,height:t}}}class BezierShape extends Shape{constructor(t=[],e={}){super(e),this.path=t}draw(){super.draw(),Painter.lines.path(this.path,this.color,this.stroke,this.lineWidth)}getBounds(){return{x:this.x,y:this.y,width:100,height:100}}}class Rectangle extends Shape{constructor(t={}){super(t)}draw(){super.draw(),this.drawRect()}drawRect(){const t=-this.width/2,e=-this.height/2;this.color&&Painter.shapes.rect(t,e,this.width,this.height,this.color),this.stroke&&Painter.shapes.outlineRect(t,e,this.width,this.height,this.stroke,this.lineWidth)}}class RoundedRectangle extends Shape{constructor(t=0,e={}){super(e),"number"==typeof t?this.radii=[t,t,t,t]:Array.isArray(t)?this.radii=4===t.length?t:[t[0]||0,t[1]||t[0]||0,t[2]||t[0]||0,t[3]||t[1]||t[0]||0]:this.radii=[0,0,0,0]}draw(){super.draw();const t=-this.width/2,e=-this.height/2;this.color&&this.stroke?Painter.shapes.roundRect(t,e,this.width,this.height,this.radii,this.color,this.stroke,this.lineWidth):this.color?Painter.shapes.fillRoundRect(t,e,this.width,this.height,this.radii,this.color):this.stroke&&Painter.shapes.strokeRoundRect(t,e,this.width,this.height,this.radii,this.stroke,this.lineWidth)}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class PatternRectangle extends Shape{constructor(t=null,e="repeat",i={}){super(i),this.image=t,this.repetition=e,this.pattern=null,t&&this._tryCreatePattern(t)}_tryCreatePattern(t){t instanceof HTMLImageElement||"boolean"==typeof t.complete?t.complete?this._createPattern():t.addEventListener("load",(()=>this._createPattern()),{once:!0}):this._createPattern()}_createPattern(){this.pattern=Painter.img.createPattern(this.image,this.repetition)}setImage(t,e){this.image=t,e&&(this.repetition=e),this.pattern=null,this._tryCreatePattern(t)}draw(){super.draw(),!this.pattern&&this.image&&this._tryCreatePattern(this.image);const t=-this.width/2,e=-this.height/2;this.pattern?Painter.img.fillPattern(this.pattern,t,e,this.width,this.height):this.strokeColor&&Painter.shapes.outlineRect(t,e,this.width,this.height,this.strokeColor,this.lineWidth)}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class Square extends Rectangle{constructor(t,e={}){super(e),this.width=t,this.height=t}}class Cube extends Shape{constructor(t=50,e={}){super(e),this.size=t,this.faceTopColor=e.faceTopColor||"#eee",this.faceBottomColor=e.faceBottomColor||"#ccc",this.faceLeftColor=e.faceLeftColor||"#aaa",this.faceRightColor=e.faceRightColor||"#888",this.faceFrontColor=e.faceFrontColor||"#666",this.faceBackColor=e.faceBackColor||"#444",this.strokeColor=e.strokeColor||null,this.lineWidth=e.lineWidth||1,this.rotationX=e.rotationX||0,this.rotationY=e.rotationY||0,this.rotationZ=e.rotationZ||0,this.visibleFaces=e.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.size/2,e=(t,e,i)=>{let s=e,o=i;e=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=i=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),i=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=e,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},i=(t,i,s)=>{const o=e(t,i,s);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z}},s={p0:i(-t,-t,-t),p1:i(t,-t,-t),p2:i(t,t,-t),p3:i(-t,t,-t),p4:i(-t,-t,t),p5:i(t,-t,t),p6:i(t,t,t),p7:i(-t,t,t)},o={top:{points:[s.p4,s.p5,s.p6,s.p7],color:this.faceTopColor,normal:[0,0,1]},bottom:{points:[s.p0,s.p1,s.p2,s.p3],color:this.faceBottomColor,normal:[0,0,-1]},left:{points:[s.p0,s.p4,s.p7,s.p3],color:this.faceLeftColor,normal:[-1,0,0]},right:{points:[s.p1,s.p5,s.p6,s.p2],color:this.faceRightColor,normal:[1,0,0]},front:{points:[s.p0,s.p1,s.p5,s.p4],color:this.faceFrontColor,normal:[0,-1,0]},back:{points:[s.p3,s.p2,s.p6,s.p7],color:this.faceBackColor,normal:[0,1,0]}};this.visibleFaces.map((t=>{const e=o[t];if(!e)return null;const i=e.points.reduce(((t,e)=>({x:t.x+e.x,y:t.y+e.y})),{x:0,y:0});i.x/=e.points.length,i.y/=e.points.length;return{key:t,face:e,depth:i.x*i.x+i.y*i.y}})).filter((t=>null!==t)).sort(((t,e)=>e.depth-t.depth)).forEach((({key:t,face:e})=>{(null==e?void 0:e.color)&&Painter.shapes.polygon(e.points,e.color,this.strokeColor,this.lineWidth)}))}getBounds(){const t=1.5*this.size;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cone extends Shape{constructor(t=50,e=100,i={}){super(i),this.radius=t,this.height=e||i.height||100,this.segments=i.segments||24,this.bottomColor=i.bottomColor||"#eee",this.sideColor=i.sideColor||"#aaa",this.stroke=i.stroke||null,this.lineWidth=i.lineWidth||1,this.rotationX=i.rotationX||0,this.rotationY=i.rotationY||0,this.rotationZ=i.rotationZ||0,this.visibleFaces=i.visibleFaces||["bottom","side"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.radius,e=this.height/2,i=(t,e,i)=>{let s=e,o=i;e=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=i=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),i=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=e,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},s=(t,e,s)=>{const o=i(t,e,s);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z,z:o.z}},o=s(0,0,e),n=[],a=2*Math.PI/this.segments;for(let i=0;i<this.segments;i++){const o=i*a,r=Math.cos(o)*t,h=Math.sin(o)*t;n.push(s(r,h,-e))}const r=[];for(let t=0;t<this.segments;t++){const e=(t+1)%this.segments;r.push({points:[o,n[t],n[e]],z:(o.z+n[t].z+n[e].z)/3})}const h=[];this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...n].reverse(),z:-e}),this.visibleFaces.includes("side")&&h.push(...r.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,e)=>e.z-t.z));for(const t of h){const e="bottom"===t.type?this.bottomColor:this.sideColor;Painter.shapes.polygon(t.points,e,this.stroke,this.lineWidth)}}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Prism extends Shape{constructor(t=100,e={}){super(e),this.depth=t,this.faceTopColor=e.faceTopColor||"#eee",this.faceBottomColor=e.faceBottomColor||"#ccc",this.faceLeftColor=e.faceLeftColor||"#aaa",this.faceRightColor=e.faceRightColor||"#888",this.faceFrontColor=e.faceFrontColor||"#666",this.faceBackColor=e.faceBackColor||"#444",this.stroke=e.stroke||null,this.lineWidth=e.lineWidth||1,this.rotationX=e.rotationX||0,this.rotationY=e.rotationY||0,this.rotationZ=e.rotationZ||0,this.visibleFaces=e.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.width/2,e=this.height/2,i=this.depth/2,s=(t,e,i)=>{let s=e,o=i;e=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=i=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),i=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=e,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},o=(t,e,i)=>{const o=s(t,e,i);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z,z:o.z}},n={p0:o(-t,-i,-e),p1:o(t,-i,-e),p2:o(0,-i,e),p3:o(-t,i,-e),p4:o(t,i,-e),p5:o(0,i,e)},a={front:{points:[n.p0,n.p1,n.p2],color:this.faceFrontColor},back:{points:[n.p3,n.p4,n.p5],color:this.faceBackColor},bottom:{points:[n.p0,n.p1,n.p4,n.p3],color:this.faceBottomColor},right:{points:[n.p1,n.p2,n.p5,n.p4],color:this.faceRightColor},left:{points:[n.p0,n.p2,n.p5,n.p3],color:this.faceLeftColor}};this.visibleFaces.filter((t=>a[t])).map((t=>{const e=a[t],i=e.points.reduce(((t,e)=>t+e.x),0)/e.points.length,s=e.points.reduce(((t,e)=>t+e.y),0)/e.points.length,o=e.points.reduce(((t,e)=>t+(e.z||0)),0)/e.points.length;return{key:t,face:e,depth:i*i+s*s+o*o}})).sort(((t,e)=>e.depth-t.depth)).forEach((({key:t,face:e})=>{(null==e?void 0:e.color)&&Painter.shapes.polygon(e.points,e.color,this.stroke,this.lineWidth)}))}getBounds(){const t=1.5*Math.max(this.width,this.height,this.depth);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cylinder extends Shape{constructor(t=40,e={}){super(e),this.radius=t,this.height=e.height||80,this.segments=e.segments||24,this.topColor=e.topColor||"#FF00FF",this.bottomColor=e.bottomColor||"#FF0FFF",this.sideColor=e.sideColor||"#00FF00",this.stroke=e.stroke||"#000000",this.lineWidth=e.lineWidth||1,this.rotationX=e.rotationX||0,this.rotationY=e.rotationY||0,this.rotationZ=e.rotationZ||0,this.visibleFaces=e.visibleFaces||["top","bottom","side"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.radius,e=this.height/2,i=(t,e,i)=>{let s=e,o=i;e=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=i=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),i=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=e,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},s=(t,e,s)=>{const o=i(t,e,s);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z,z:o.z}},o=[],n=[],a=2*Math.PI/this.segments;for(let i=0;i<this.segments;i++){const r=i*a,h=Math.cos(r)*t,l=Math.sin(r)*t;o.push(s(h,l,e)),n.push(s(h,l,-e))}const r=[];for(let t=0;t<this.segments;t++){const e=(t+1)%this.segments;r.push({points:[n[t],n[e],o[e],o[t]],z:(o[t].z+o[e].z+n[t].z+n[e].z)/4})}const h=[];this.visibleFaces.includes("top")&&h.push({type:"top",points:o,z:e}),this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...n].reverse(),z:-e}),this.visibleFaces.includes("side")&&h.push(...r.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,e)=>e.z-t.z));for(const t of h){let e;switch(t.type){case"top":e=this.topColor;break;case"bottom":e=this.bottomColor;break;case"side":e=this.sideColor}Painter.shapes.polygon(t.points,e,this.stroke,this.lineWidth)}}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Diamond extends Shape{constructor(t={}){super(t)}draw(){super.draw();const t=this.width/2,e=this.height/2,i=[{x:0,y:-e},{x:t,y:0},{x:0,y:e},{x:-t,y:0}];Painter.shapes.polygon(i,this.color,this.stroke,this.lineWidth)}}class Line extends Shape{constructor(t=40,e={}){super(e),this.length=t}draw(){super.draw();const t=this.length/2;Painter.lines.line(-t,-t,t,t,this.stroke,this.lineWidth)}}class Triangle extends Shape{constructor(t=50,e={}){super(e),this.size=t}draw(){super.draw();const t=this.size/2,e=[{x:0,y:-t},{x:t,y:t},{x:-t,y:t}];Painter.shapes.polygon(e,this.color,this.stroke,this.lineWidth)}}class Star extends Shape{constructor(t=40,e=5,i=.5,s={}){super(s),this.radius=t,this.spikes=e,this.inset=i}draw(){super.draw();const t=Math.PI/this.spikes,e=-Math.PI/2;Painter.lines.beginPath();for(let i=0;i<2*this.spikes;i++){const s=i%2==0?this.radius:this.radius*this.inset,o=i*t+e,n=Math.cos(o)*s,a=Math.sin(o)*s;0===i?Painter.lines.moveTo(n,a):Painter.lines.lineTo(n,a)}Painter.lines.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}}class Sphere extends Shape{constructor(t=50,e={}){super(e),this.radius=t,this.hSegments=e.hSegments||16,this.vSegments=e.vSegments||12,this.color=e.color||"#6495ED",this.highlightColor=e.highlightColor||"#FFFFFF",this.wireframe=e.wireframe||!1,this.stroke=e.stroke||"#333333",this.lineWidth=e.lineWidth||1,this.rotationX=e.rotationX||0,this.rotationY=e.rotationY||0,this.rotationZ=e.rotationZ||0}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}calculateSurfaceColor(t,e,i){let s=t*(1/Math.sqrt(3))+e*(1/Math.sqrt(3))+i*(1/Math.sqrt(3));if(s=Math.max(.3,s),this.highlightColor){const t=this.hexToRgb(this.color),e=this.hexToRgb(this.highlightColor);return`rgb(${Math.round(t.r*(1-s)+e.r*s)}, ${Math.round(t.g*(1-s)+e.g*s)}, ${Math.round(t.b*(1-s)+e.b*s)})`}const o=this.hexToRgb(this.color);return`rgb(${Math.min(255,Math.round(o.r*s))}, ${Math.min(255,Math.round(o.g*s))}, ${Math.min(255,Math.round(o.b*s))})`}hexToRgb(t){const e={r:100,g:100,b:255};if(!t||"string"!=typeof t)return e;const i=t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,((t,e,i,s)=>e+e+i+i+s+s)),s=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(i);return s?{r:parseInt(s[1],16),g:parseInt(s[2],16),b:parseInt(s[3],16)}:e}draw(){super.draw();const t=this.radius,e=(t,e,i)=>{let s=e,o=i;e=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=i=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),i=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=e,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},i=(i,s,o)=>{const n=e(i,s,o);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z,nx:n.x/t,ny:n.y/t,nz:n.z/t}},s=[];for(let e=0;e<=this.vSegments;e++){const o=[],n=e/this.vSegments,a=Math.PI*n-Math.PI/2;for(let e=0;e<=this.hSegments;e++){const s=e/this.hSegments,n=2*Math.PI*s,r=t*Math.cos(a)*Math.cos(n),h=t*Math.cos(a)*Math.sin(n),l=t*Math.sin(a);o.push(i(r,h,l))}s.push(o)}const o=[];for(let t=0;t<this.vSegments;t++)for(let e=0;e<this.hSegments;e++){const i=s[t][e],n=s[t][e+1],a=s[t+1][e],r=s[t+1][e+1],h=(i.z+n.z+a.z+r.z)/4,l=(i.nx+n.nx+a.nx+r.nx)/4,c=(i.ny+n.ny+a.ny+r.ny)/4,d=(i.nz+n.nz+a.nz+r.nz)/4;o.push({points:[i,n,r,a],z:h,color:this.calculateSurfaceColor(l,c,d)})}if(o.sort(((t,e)=>e.z-t.z)),this.wireframe)for(const t of o){const e=t.points;for(let t=0;t<e.length;t++){const i=(t+1)%e.length;Painter.lines.line(e[t].x,e[t].y,e[i].x,e[i].y,this.stroke,this.lineWidth)}}for(const t of o)Painter.shapes.polygon(t.points,t.color,this.stroke,this.lineWidth)}getBounds(){const t=2*this.radius*1.5;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class SVGShape extends Shape{constructor(t,e={}){console.log("SVGShape",e.x),super(e),this.scale=e.scale||1,this.centerPath=void 0===e.centerPath||e.centerPath,this.animationProgress=void 0!==e.animationProgress?e.animationProgress:1,this.svgPathData=t,this.pathCommands=this.parseSVGPath(t),this.centerPath?this.pathCommands=this.centerAndScalePath(this.pathCommands,this.scale):this.pathCommands=this.scalePath(this.pathCommands,this.scale),this.prevX=0,this.prevY=0,this.currentPoint={x:0,y:0}}parseSVGPath(t){const e=/M\s*([-\d.]+)[,\s]*([-\d.]+)/g,i=/L\s*([-\d.]+)[,\s]*([-\d.]+)/g,s=/C\s*([-\d.]+)[,\s]*([-\d.]+)\s*([-\d.]+)[,\s]*([-\d.]+)\s*([-\d.]+)[,\s]*([-\d.]+)/g,o=[];let n;for(;null!==(n=e.exec(t));)o.push(["M",parseFloat(n[1]),parseFloat(n[2])]);for(;null!==(n=i.exec(t));){const t=parseFloat(n[1]),e=parseFloat(n[2]);let i=0,s=0;for(let t=o.length-1;t>=0;t--){const e=o[t];if("M"===e[0]){i=e[1],s=e[2];break}if("C"===e[0]){i=e[5],s=e[6];break}}const a=i+(t-i)/3,r=s+(e-s)/3,h=i+2*(t-i)/3,l=s+2*(e-s)/3;o.push(["C",a,r,h,l,t,e])}for(;null!==(n=s.exec(t));)o.push(["C",parseFloat(n[1]),parseFloat(n[2]),parseFloat(n[3]),parseFloat(n[4]),parseFloat(n[5]),parseFloat(n[6])]);return/Z/g.test(t)&&o.push(["Z"]),o}centerAndScalePath(t,e){let i=1/0,s=1/0,o=-1/0,n=-1/0;for(const e of t)"M"===e[0]?(i=Math.min(i,e[1]),s=Math.min(s,e[2]),o=Math.max(o,e[1]),n=Math.max(n,e[2])):"C"===e[0]&&(i=Math.min(i,e[1],e[3],e[5]),s=Math.min(s,e[2],e[4],e[6]),o=Math.max(o,e[1],e[3],e[5]),n=Math.max(n,e[2],e[4],e[6]));const a=(i+o)/2,r=(s+n)/2;return this.originalWidth=(o-i)*e,this.originalHeight=(n-s)*e,t.map((t=>"M"===t[0]?["M",(t[1]-a)*e,(t[2]-r)*e]:"C"===t[0]?["C",(t[1]-a)*e,(t[2]-r)*e,(t[3]-a)*e,(t[4]-r)*e,(t[5]-a)*e,(t[6]-r)*e]:[...t]))}scalePath(t,e){let i=1/0,s=1/0,o=-1/0,n=-1/0;for(const e of t)"M"===e[0]?(i=Math.min(i,e[1]),s=Math.min(s,e[2]),o=Math.max(o,e[1]),n=Math.max(n,e[2])):"C"===e[0]&&(i=Math.min(i,e[1],e[3],e[5]),s=Math.min(s,e[2],e[4],e[6]),o=Math.max(o,e[1],e[3],e[5]),n=Math.max(n,e[2],e[4],e[6]));return this.originalWidth=(o-i)*e,this.originalHeight=(n-s)*e,t.map((t=>"M"===t[0]?["M",t[1]*e,t[2]*e]:"C"===t[0]?["C",t[1]*e,t[2]*e,t[3]*e,t[4]*e,t[5]*e,t[6]*e]:[...t]))}getBezierPoint(t,e){if("M"===t[0])return{x:t[1],y:t[2]};if("C"===t[0]){const i=this.prevX,s=this.prevY,o=t[1],n=t[2],a=t[3],r=t[4],h=t[5],l=t[6];return{x:Math.pow(1-e,3)*i+3*Math.pow(1-e,2)*e*o+3*(1-e)*Math.pow(e,2)*a+Math.pow(e,3)*h,y:Math.pow(1-e,3)*s+3*Math.pow(1-e,2)*e*n+3*(1-e)*Math.pow(e,2)*r+Math.pow(e,3)*l}}return{x:0,y:0}}getPartialPath(){const t=[];let e=this.pathCommands.length,i=Math.floor(this.animationProgress*e),s=this.animationProgress*e%1,o=!1;this.prevX=0,this.prevY=0;for(let e=0;e<i;e++){const i=this.pathCommands[e];t.push([...i]),"M"===i[0]?(this.prevX=i[1],this.prevY=i[2],o=!0):"C"===i[0]&&(this.prevX=i[5],this.prevY=i[6],o=!0)}if(i<e){const e=this.pathCommands[i];if("M"===e[0])t.push([...e]),this.prevX=e[1],this.prevY=e[2],this.currentPoint={x:e[1],y:e[2]},o=!0;else if("C"===e[0]){if(!o){for(let t=i-1;t>=0;t--)if("M"===this.pathCommands[t][0]){this.prevX=this.pathCommands[t][1],this.prevY=this.pathCommands[t][2],o=!0;break}o||(this.prevX=0,this.prevY=0)}const n=this.getBezierPoint(e,s);t.push(["C",e[1],e[2],e[3],e[4],n.x,n.y]),this.currentPoint=n}}return t}draw(){super.draw();const t=this.getPartialPath();Painter.lines.path(t,this.color,this.stroke,this.lineWidth)}getCurrentPoint(){return{x:this.currentPoint.x,y:this.currentPoint.y}}setAnimationProgress(t){this.animationProgress=Math.max(0,Math.min(1,t))}calculateBounds(){return{x:this.x,y:this.y,width:this.originalWidth||100,height:this.originalHeight||100}}}class StickFigure extends Shape{constructor(t=1,e={}){super(e),this.scale=t,this.stroke=e.stroke||"#000",this.headColor=e.headColor||this.stroke,this.jointColor=e.jointColor||this.stroke,this.lineWidth=e.lineWidth||2,this.showJoints=!1!==e.showJoints}draw(){super.draw();const t=this.scale,e=10*t,i=-30*t,s=i+e,o=s+40*t,n=s+10*t,a=15*t,r=10*t,h=o+40*t,l=3*t;if(Painter.shapes.fillCircle(0,i,e,this.headColor),Painter.shapes.strokeCircle(0,i,e,this.stroke,this.lineWidth),Painter.lines.line(0,s,0,o,this.stroke,this.lineWidth),Painter.lines.line(-a,n,a,n,this.stroke,this.lineWidth),Painter.lines.line(0,o,-r,h,this.stroke,this.lineWidth),Painter.lines.line(0,o,r,h,this.stroke,this.lineWidth),this.showJoints){[[0,s],[-a,n],[a,n],[0,o],[-r,h],[r,h]].forEach((([t,e])=>Painter.shapes.fillCircle(t,e,l,this.jointColor)))}}getBounds(){const t=100*this.scale,e=40*this.scale;return{x:this.x,y:this.y,width:e,height:t}}}class Ring extends Shape{constructor(t,e,i={}){super(i),this.outerRadius=t,this.innerRadius=e}draw(){super.draw(),Painter.lines.beginPath(),Painter.shapes.arc(0,0,this.outerRadius,0,2*Math.PI),Painter.shapes.arc(0,0,this.innerRadius,0,2*Math.PI,!0),Painter.lines.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}}class Polygon extends Shape{constructor(t=6,e=40,i={}){super(i),this.sides=t,this.radius=e}draw(){super.draw();const t=[],e=2*Math.PI/this.sides;for(let i=0;i<this.sides;i++){const s=i*e;t.push({x:Math.cos(s)*this.radius,y:Math.sin(s)*this.radius})}Painter.shapes.polygon(t,this.color,this.stroke,this.lineWidth)}}class Arrow extends Shape{constructor(t,e={}){super(e),this.length=t}draw(){super.draw();const t=this.width/2,e=.4*this.length,i=this.length-e;Painter.lines.beginPath(),Painter.lines.moveTo(-i/2,-t),Painter.lines.lineTo(i/2,-t),Painter.lines.lineTo(i/2,-this.width),Painter.lines.lineTo(this.length/2,0),Painter.lines.lineTo(i/2,this.width),Painter.lines.lineTo(i/2,t),Painter.lines.lineTo(-i/2,t),Painter.lines.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}}class Pin extends Shape{constructor(t=20,e={}){super(e),this.radius=t}draw(){super.draw();const t=this.radius,e=2.5*t;Painter.lines.beginPath(),Painter.shapes.arc(0,0,t,Math.PI,0),Painter.lines.lineTo(t,0),Painter.lines.lineTo(0,e),Painter.lines.lineTo(-t,0),Painter.lines.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}getBounds(){return{x:this.x,y:this.y+.98*this.radius,width:2*this.radius,height:2.5*this.radius}}}class PieSlice extends Shape{constructor(t,e,i,s={}){super(s),this.radius=t,this.startAngle=e,this.endAngle=i}draw(){super.draw(),Painter.lines.beginPath(),Painter.lines.moveTo(0,0),Painter.shapes.arc(0,0,this.radius,this.startAngle,this.endAngle),Painter.lines.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}}class Hexagon extends Shape{constructor(t,e={}){super(e),this.radius=t}draw(){super.draw();const t=Array.from({length:6},((t,e)=>{const i=Math.PI/3*e;return{x:Math.cos(i)*this.radius,y:Math.sin(i)*this.radius}}));Painter.shapes.polygon(t,this.color,this.stroke,this.lineWidth)}}class Heart extends Shape{constructor(t={}){super(t)}draw(){super.draw();const t=this.width,e=this.height,i=.3*e,s=Painter.lines;s.beginPath(),s.moveTo(0,i),s.bezierCurveTo(0,0,-t/2,0,-t/2,i),s.bezierCurveTo(-t/2,.8*e,0,e,0,e),s.bezierCurveTo(0,e,t/2,.8*e,t/2,i),s.bezierCurveTo(t/2,0,0,0,0,i),s.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}getBounds(){return{x:this.x,y:this.y+this.height/2,width:this.width,height:this.height}}}class Cross extends Shape{constructor(t,e,i={}){super(i),this.size=t,this.thickness=e,this.diagonal=i.diagonal||!1}draw(){super.draw();const t=this.size/2,e=this.thickness/2;this.diagonal?(Painter.lines.beginPath(),Painter.lines.moveTo(-t,-t+e),Painter.lines.lineTo(-t+e,-t),Painter.lines.lineTo(0,-e),Painter.lines.lineTo(t-e,-t),Painter.lines.lineTo(t,-t+e),Painter.lines.lineTo(e,0),Painter.lines.lineTo(t,t-e),Painter.lines.lineTo(t-e,t),Painter.lines.lineTo(0,e),Painter.lines.lineTo(-t+e,t),Painter.lines.lineTo(-t,t-e),Painter.lines.lineTo(-e,0),Painter.lines.closePath()):(Painter.lines.beginPath(),Painter.lines.moveTo(-e,-t),Painter.lines.lineTo(e,-t),Painter.lines.lineTo(e,-e),Painter.lines.lineTo(t,-e),Painter.lines.lineTo(t,e),Painter.lines.lineTo(e,e),Painter.lines.lineTo(e,t),Painter.lines.lineTo(-e,t),Painter.lines.lineTo(-e,e),Painter.lines.lineTo(-t,e),Painter.lines.lineTo(-t,-e),Painter.lines.lineTo(-e,-e),Painter.lines.closePath()),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}}class TextShape extends Shape{constructor(t,e={}){super(e),this._text=t,this._font=e.font||"12px monospace",this._color=e.color||"yellow",this._align=e.align||"center",this._baseline=e.baseline||"middle",this._calculateBounds(),this._calculateAlignmentOffsets()}draw(){super.draw(),this.logger.log("draw",this.font,this.color,this.opacity),Painter.text.setFont(this.font),Painter.text.setTextAlign(this.align),Painter.text.setTextBaseline(this.baseline),Painter.text.fillText(this.text,0,0,this.color)}_calculateAlignmentOffsets(){if(!Painter.text)return;const t=Painter.text.measureTextDimensions(this.text,this.font);switch(this._align){case"left":this._centerOffsetX=t.width/2;break;case"center":this._centerOffsetX=0;break;case"right":this._centerOffsetX=-t.width/2-5}switch(this._baseline){case"top":this._centerOffsetY=t.height/4;break;case"middle":this._centerOffsetY=-2;break;case"bottom":this._centerOffsetY=-t.height}}getTextBounds(){if(Painter.text){const t=Painter.text.measureTextDimensions(this.text,this.font),e=2;return{x:this._centerOffsetX-t.width/2,y:this._centerOffsetY-t.height/2,width:t.width+2*e,height:t.height+2*e}}return{x:this._centerOffsetX,y:this._centerOffsetY,width:this._width,height:this._height}}_calculateBounds(){if(Painter.text){const t=Painter.text.measureTextDimensions(this.text,this.font);this._width=t.width,this._height=t.height,this._calculateAlignmentOffsets()}else this._width=this.text?8*this.text.length:0,this._height=16;this.trace("TextShape.calculateBounds: "+this._width+"x"+this._height)}getDebugBounds(){const t=this.getTextBounds();return{x:t.x,y:t.y,width:t.width,height:t.height}}checkDirty(t,e){t!==e&&(this._boundsDirty=!0,this._calculateBounds())}get text(){return this._text}set text(t){this.checkDirty(t,this._text),this._text=t}get font(){return this._font}set font(t){this.checkDirty(t,this._font),this._font=t}get color(){return this._color}set color(t){this._color=t}get align(){return this._align}set align(t){this.checkDirty(t,this._align),this._align=t}get baseline(){return this._baseline}set baseline(t){this.checkDirty(t,this._baseline),this._baseline=t}}class OutlinedText extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.text=i,this.centered=s.centered||!1,this.color=s.color||"#000000",this.stroke=s.stroke||"#FFFFFF",this.lineWidth=s.lineWidth||1,this.font=s.font||null,this.align=s.align||"left",this.baseline=s.baseline||"alphabetic",this.calculateDimensions()}calculateDimensions(){if(!Painter.ctx)return console.warn("Painter context not initialized. Cannot calculate text dimensions."),this.width=0,void(this.height=0);const t=Painter.text.font();this.font&&Painter.text.setFont(this.font);const e=Painter.text.measureText(this.text);if(this.width=e.width,this.font){const t=parseInt(this.font);this.height=isNaN(t)?20:t}else this.height=e.actualBoundingBoxAscent+e.actualBoundingBoxDescent||20;this.width+=2*this.lineWidth,this.height+=2*this.lineWidth,Painter.text.setFont(t)}setText(t){this.text=t,this.calculateDimensions()}draw(){if(super.draw(),!Painter.ctx)return void console.warn("Painter context not initialized. Cannot draw text.");let t=0;this.font&&Painter.text.setFont(this.font),Painter.text.setTextAlign(this.align),Painter.text.setTextBaseline(this.baseline),this.centered&&("middle"===this.baseline||"alphabetic"===this.baseline?t=0:"top"===this.baseline?t=this.height/2:"bottom"===this.baseline&&(t=-this.height/2)),Painter.outlinedText(this.text,0,t,this.color,this.stroke,this.lineWidth,this.font)}getBounds(){if(!Painter.ctx)return super.getBounds();const t=Painter.text.font();Painter.text.setFont(this.font);const e=Painter.text.measureText(this.text),i=e.width,s=e.actualBoundingBoxAscent+e.actualBoundingBoxDescent||parseInt(this.font)||20;return Painter.text.setFont(t),this.width=i,this.height=s,{x:this.x,y:this.y,width:i,height:s}}}class WrappedText extends Shape{constructor(t,e,i,s,o=20,n={}){super(t,e,n),this.text=i,this.maxWidth=s,this.lineHeight=o,this.centered=n.centered||!1,this.color=n.color||"#000000",this.font=n.font||null,this.align=n.align||"left",this.baseline=n.baseline||"top",this.outlineColor=n.outlineColor||null,this.outlineWidth=n.outlineWidth||1,this.calculateDimensions()}calculateDimensions(){if(!Painter.ctx)return console.warn("Painter context not initialized. Cannot calculate text dimensions."),this.width=this.maxWidth,this.height=this.lineHeight,void(this.lines=[this.text]);const t=Painter.text.font(),e=Painter.text.textAlign(),i=Painter.text.textBaseline();this.font&&Painter.text.setFont(this.font),Painter.text.setTextAlign("left"),Painter.text.setTextBaseline("top");const s=this.text.split(" ");let o="",n="";this.lines=[],this.width=0;for(let t=0;t<s.length;t++){n=o+s[t]+" ";Painter.text.measureText(n).width>this.maxWidth&&t>0?(this.lines.push(o),this.width=Math.max(this.width,Painter.text.measureText(o).width),o=s[t]+" "):o=n}this.lines.push(o),this.width=Math.max(this.width,Painter.text.measureText(o).width),this.height=this.lines.length*this.lineHeight,Painter.text.setFont(t),Painter.text.setTextAlign(e),Painter.text.setTextBaseline(i)}setText(t){this.text=t,this.calculateDimensions()}draw(){if(super.draw(),!Painter.ctx)return void console.warn("Painter context not initialized. Cannot draw text.");let t=0,e=0;this.centered&&(t=-this.width/2,e=-this.height/2),this.font&&Painter.text.setFont(this.font),Painter.text.setTextAlign(this.align),Painter.text.setTextBaseline(this.baseline);let i=t;"center"===this.align?i=0:"right"===this.align&&(i=t+this.width);for(let t=0;t<this.lines.length;t++){const s=e+t*this.lineHeight;this.outlineColor?Painter.outlinedText(this.lines[t],i,s,this.color,this.outlineColor,this.outlineWidth,this.font):Painter.text.fillText(this.lines[t],i,s,this.color,this.font)}}getBounds(){return this.centered?{x:this.x,y:this.y,width:this.width,height:this.height}:{x:this.x+this.width/2,y:this.y+this.height/2,width:this.width,height:this.height}}}class EventEmitter{constructor(){this.listeners={}}on(t,e){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e)}off(t,e){this.listeners[t]&&(this.listeners[t]=this.listeners[t].filter((t=>t!==e)))}emit(t,e){this.listeners[t]&&this.listeners[t].forEach((t=>t(e)))}}const _Input=class t{static init(e){t.game=e,t.x=0,t.y=0,t.down=!1,e.events.on("mousedown",t._onDown),e.events.on("mouseup",t._onUp),e.events.on("mousemove",t._onMove),e.events.on("touchstart",t._onTouchStart),e.events.on("touchend",t._onTouchEnd),e.events.on("touchmove",t._onTouchMove)}static _setPosition(e,i){t.x=e,t.y=i}};__publicField(_Input,"_onDown",(t=>{_Input.down=!0,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onUp",(t=>{_Input.down=!1,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onMove",(t=>{_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputmove",t)})),__publicField(_Input,"_onTouchStart",(t=>{const e=t.touches[0],i=_Input.game.canvas.getBoundingClientRect();_Input.down=!0,_Input._setPosition(e.clientX-i.left,e.clientY-i.top),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onTouchEnd",(t=>{_Input.down=!1,_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onTouchMove",(t=>{const e=t.touches[0],i=_Input.game.canvas.getBoundingClientRect();_Input._setPosition(e.clientX-i.left,e.clientY-i.top),_Input.game.events.emit("inputmove",t)}));let Input=_Input;const _Mouse=class t{static init(e){t.game=e,t.canvas=e.canvas,t.x=0,t.y=0,t.leftDown=!1,t.middleDown=!1,t.rightDown=!1,t.canvas.addEventListener("mousemove",t._onMove),t.canvas.addEventListener("mousedown",t._onDown),t.canvas.addEventListener("mouseup",t._onUp),t.canvas.addEventListener("click",t._onClick),t.canvas.addEventListener("wheel",t._onWheel)}static _updatePosition(e){const i=t.canvas.getBoundingClientRect();t.x=e.clientX-i.left,t.y=e.clientY-i.top}};__publicField(_Mouse,"_onMove",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("mousemove",t)})),__publicField(_Mouse,"_onDown",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!0),1===t.button&&(_Mouse.middleDown=!0),2===t.button&&(_Mouse.rightDown=!0),_Mouse.game.events.emit("mousedown",t)})),__publicField(_Mouse,"_onUp",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!1),1===t.button&&(_Mouse.middleDown=!1),2===t.button&&(_Mouse.rightDown=!1),_Mouse.game.events.emit("mouseup",t)})),__publicField(_Mouse,"_onClick",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("click",t)})),__publicField(_Mouse,"_onWheel",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("wheel",t)}));let Mouse=_Mouse;const _Keys=class t{static init(e){t.game=e,window.addEventListener("keydown",t._onKeyDown),window.addEventListener("keyup",t._onKeyUp)}static isDown(e){return t._down.has(e)}static _onKeyDown(e){const i=t._codeMap[e.code];i&&(t._down.has(i)||(t._down.add(i),t.game.events.emit(i,e))),t.game.events.emit(e.type,e)}static _onKeyUp(e){const i=t._codeMap[e.code];i&&t._down.has(i)&&(t._down.delete(i),t.game.events.emit(i+"_up",e)),t.game.events.emit(e.type,e)}};__publicField(_Keys,"W","W"),__publicField(_Keys,"A","A"),__publicField(_Keys,"S","S"),__publicField(_Keys,"D","D"),__publicField(_Keys,"UP","UP"),__publicField(_Keys,"DOWN","DOWN"),__publicField(_Keys,"LEFT","LEFT"),__publicField(_Keys,"RIGHT","RIGHT"),__publicField(_Keys,"SPACE","SPACE"),__publicField(_Keys,"SHIFT","SHIFT"),__publicField(_Keys,"ENTER","ENTER"),__publicField(_Keys,"ESC","ESC"),__publicField(_Keys,"_codeMap",{KeyW:_Keys.W,KeyA:_Keys.A,KeyS:_Keys.S,KeyD:_Keys.D,ArrowUp:_Keys.UP,ArrowDown:_Keys.DOWN,ArrowLeft:_Keys.LEFT,ArrowRight:_Keys.RIGHT,Space:_Keys.SPACE,ShiftLeft:_Keys.SHIFT,ShiftRight:_Keys.SHIFT,Enter:_Keys.ENTER,NumpadEnter:_Keys.ENTER,Escape:_Keys.ESC}),__publicField(_Keys,"_down",new Set),__publicField(_Keys,"game",null);let Keys=_Keys;const _Touch=class t{static init(e){t.game=e,t.canvas=e.canvas,t.x=0,t.y=0,t.active=!1,t.canvas.addEventListener("touchstart",t._onStart),t.canvas.addEventListener("touchend",t._onEnd),t.canvas.addEventListener("touchmove",t._onMove)}static _updatePosition(e){const i=t.canvas.getBoundingClientRect();t.x=e.clientX-i.left,t.y=e.clientY-i.top}};__publicField(_Touch,"_onStart",(t=>{t.touches.length>0&&(_Touch.active=!0,_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchstart",t))})),__publicField(_Touch,"_onEnd",(t=>{_Touch.active=!1,_Touch.game.events.emit("touchend",t)})),__publicField(_Touch,"_onMove",(t=>{t.touches.length>0&&(_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchmove",t))}));let Touch=_Touch;function applyAnchor(t,e={}){var i;if(!(t&&t instanceof GameObject))return console.warn("applyAnchor can only be applied to GameObject instances"),t;t._anchor={position:e.anchor??null,margin:e.anchorMargin??10,offsetX:e.anchorOffsetX??0,offsetY:e.anchorOffsetY??0,relative:e.anchorRelative??!1,setTextAlign:!1!==e.anchorSetTextAlign,lastUpdate:0};const s=null==(i=t.update)?void 0:i.bind(t);return t.update=function(e){const i=!0===t._anchor.relative&&t.parent?t.parent:t._anchor.relative;if(t._anchor.position&&(t.boundsDirty||i&&i.boundsDirty||t.parent&&t.parent.boundsDirty)){let e;if(i){const s={x:i.x,y:i.y,width:i.width,height:i.height};e=Position.calculate(t._anchor.position,t,s,t._anchor.margin,t._anchor.offsetX,t._anchor.offsetY)}else e=Position.calculateAbsolute(t._anchor.position,t,t.game,t._anchor.margin,t._anchor.offsetX,t._anchor.offsetY);!t.parent||(o=t).game&&o.game.pipeline&&o.game.pipeline.gameObjects&&o.game.pipeline.gameObjects.includes(o)?(t.x=e.x,t.y=e.y):i===t.parent?(t.x=e.x-i.x,t.y=e.y-i.y):(t.x=e.x-t.parent.x,t.y=e.y-t.parent.y),t._anchor.setTextAlign&&("align"in t&&(t.align=e.align),"baseline"in t&&(t.baseline=e.baseline)),t._anchor.lastUpdate=t.game?t.game.lastTime:Date.now()}var o;s&&s(e)},t}class GameObject extends Transformable{constructor(t,e={}){super(e),this.game=t,this.parent=null,this.events=new EventEmitter,this._interactive=e.interactive??!1,this._hovered=!1,e.anchor&&applyAnchor(this,e)}update(t){this.logger.groupCollapsed("GameObject.update: "+(null==this.name?this.constructor.name:this.name)),super.update(t),this.logger.groupEnd()}get interactive(){return this._interactive}set interactive(t){const e=Boolean(t);this._interactive!==e&&(this._interactive=e,!0===e?this._enableEvents():(this._disableEvents(),this._hovered&&(this._hovered=!1,this.events.emit("mouseout"))))}_enableEvents(){this.logger.log(`${this.constructor.name} is now interactive`)}_disableEvents(){this.logger.log(`${this.constructor.name} is no longer interactive`)}get hovered(){return this._hovered}set hovered(t){this._hovered=Boolean(t)}_setHovered(t){this._hovered=Boolean(t)}_hitTest(t,e){var i;if(!this._interactive)return!1;if(!(null==(i=this.getBounds)?void 0:i.call(this)))return!1;let s=t,o=e;const n=[];let a=this;for(;a;)n.unshift(a),a=a.parent;for(const t of n){if(s-=t.x||0,o-=t.y||0,t.rotation){const e=Math.cos(-t.rotation),i=Math.sin(-t.rotation),n=s;s=n*e-o*i,o=n*i+o*e}void 0!==t.scaleX&&0!==t.scaleX&&(s/=t.scaleX),void 0!==t.scaleY&&0!==t.scaleY&&(o/=t.scaleY)}const r=this.width/2,h=this.height/2;return s>=-r&&s<=r&&o>=-h&&o<=h}on(t,e){this.events.on(t,e)}off(t,e){this.events.off(t,e)}emit(t,...e){this.events.emit(t,...e)}}function applyDraggable(t,e={}){const i=t.game;return t.dragging=!1,t.dragOffset={x:0,y:0},t._dragInputMoveHandler&&i.events.off("inputmove",t._dragInputMoveHandler),t._dragInputUpHandler&&i.events.off("inputup",t._dragInputUpHandler),"function"==typeof t.enableInteractivity?t.enableInteractivity(t):t.interactive=!0,t._dragInputDownHandler=i=>{t.dragging=!0,t.dragOffset.x=t.x-i.x,t.dragOffset.y=t.y-i.y,e.onDragStart&&e.onDragStart()},t._dragInputMoveHandler=e=>{t.dragging&&(t.x=e.x+t.dragOffset.x,t.y=e.y+t.dragOffset.y)},t._dragInputUpHandler=i=>{t.dragging&&(t.dragging=!1,e.onDragEnd&&e.onDragEnd())},t.on("inputdown",t._dragInputDownHandler),i.events.on("inputmove",t._dragInputMoveHandler),i.events.on("inputup",t._dragInputUpHandler),()=>{t.off("inputdown",t._dragInputDownHandler),i.events.off("inputmove",t._dragInputMoveHandler),i.events.off("inputup",t._dragInputUpHandler),delete t._dragInputDownHandler,delete t._dragInputMoveHandler,delete t._dragInputUpHandler,delete t.dragging,delete t.dragOffset}}class ShapeGOFactory{static create(t,e,i={}){const s={x:(null==e?void 0:e.x)??0,y:(null==e?void 0:e.y)??0,width:(null==e?void 0:e.width)??0,height:(null==e?void 0:e.height)??0,rotation:(null==e?void 0:e.rotation)??0,scaleX:(null==e?void 0:e.scaleX)??1,scaleY:(null==e?void 0:e.scaleY)??1,opacity:(null==e?void 0:e.opacity)??1,visible:(null==e?void 0:e.visible)??!0,active:!0,debug:(null==e?void 0:e.debug)??!1,color:(null==e?void 0:e.color)??null,stroke:(null==e?void 0:e.stroke)??null,lineWidth:(null==e?void 0:e.lineWidth)??1,lineJoin:(null==e?void 0:e.lineJoin)??"miter",lineCap:(null==e?void 0:e.lineCap)??"butt",miterLimit:(null==e?void 0:e.miterLimit)??10,...i,name:i.name??(null==e?void 0:e.constructor.name)??"ShapeWrapper"};return new GameObjectShapeWrapper(t,e,s)}}class GameObjectShapeWrapper extends GameObject{constructor(t,e,i={}){if(super(t,i),!e||null==e||null==e)throw new Error("GameObjectShapeWrapper requires a shape");this.shape=e,void 0!==i.color&&(e.color=i.color),void 0!==i.stroke&&(e.stroke=i.stroke),void 0!==i.lineWidth&&(e.lineWidth=i.lineWidth),void 0!==i.lineJoin&&(e.lineJoin=i.lineJoin),void 0!==i.lineCap&&(e.lineCap=i.lineCap),void 0!==i.miterLimit&&(e.miterLimit=i.miterLimit),this.syncPropertiesToShape(),this.logger.log(`Created GameObject(${this.constructor.name}):`,{x:this.x,y:this.y,width:this.width,height:this.height,color:this.color,stroke:this.stroke})}syncPropertiesToShape(){if(!this.shape)return;const t=["width","height","rotation","scaleX","scaleY","visible","debug","debugColor"];for(const e of t)e in this&&e in this.shape&&this[e]!==this.shape[e]&&(this.shape[e]=this[e])}get color(){return this.shape?this.shape.color:null}set color(t){this.shape&&(this.shape.color=t)}get stroke(){return this.shape?this.shape.stroke:null}set stroke(t){this.shape&&(this.shape.stroke=t)}get lineWidth(){return this.shape?this.shape.lineWidth:1}set lineWidth(t){this.shape&&(this.shape.lineWidth=t)}get lineJoin(){return this.shape?this.shape.lineJoin:"miter"}set lineJoin(t){this.shape&&(this.shape.lineJoin=t)}get lineCap(){return this.shape?this.shape.lineCap:"butt"}set lineCap(t){this.shape&&(this.shape.lineCap=t)}get miterLimit(){return this.shape?this.shape.miterLimit:10}set miterLimit(t){this.shape&&(this.shape.miterLimit=t)}update(t){var e;this.active&&(null==(e=this.onUpdate)||e.call(this,t),(this._boundsDirty||this.tweening)&&(this.syncPropertiesToShape(),this._boundsDirty=!1),super.update(t))}draw(){super.draw(),this.shape.render()}}class Scene extends GameObject{constructor(t,e={}){super(t,e),this._collection=new ZOrderedCollection({sortByZIndex:e.sortByZIndex||!0}),this._collection._owner=this,this._width=e.width??0,this._height=e.height??0,this.forceWidth=null,this.forceHeight=null,this._naturalWidth=null,this._naturalHeight=null,this.userDefinedDimensions=!1,null!=e.width&&null!=e.height&&(this.userDefinedWidth=e.width,this.userDefinedHeight=e.height,this.userDefinedDimensions=!0)}update(t){this.logger.groupCollapsed("Scene.update: "+(null==this.name?this.constructor.name:this.name));for(let e=0;e<this.children.length;e++){const i=this.children[e];i.active&&i.update&&i.update(t)}super.update(t),this.logger.groupEnd()}add(t){if(null==t||null==t)throw new Error("GameObject is null or undefined");return null!=t.parent&&console.warn("This GameObject already has a parent. Consider removing it first."),t.parent=this,this._collection.add(t),this.markBoundsDirty(),t.init&&t.init(),t}markBoundsDirty(){super.markBoundsDirty(),this.children.forEach((t=>{t.markBoundsDirty()}))}remove(t){const e=this._collection.remove(t);return e&&(t.parent=null,this.markBoundsDirty()),e}draw(){super.draw(),this.logger.log("Scene.draw chilren:"),this._collection.getSortedChildren().filter((t=>t.visible)).map((function(t){return Painter.save(),t.render(),Painter.restore(),t}))}getDebugBounds(){return{width:this.width,height:this.height,x:this.x-this.width/2,y:this.y-this.height/2}}bringToFront(t){return this._collection.bringToFront(t)}sendToBack(t){return this._collection.sendToBack(t)}bringForward(t){return this._collection.bringForward(t)}sendBackward(t){return this._collection.sendBackward(t)}clear(){return this._collection.children.forEach((t=>this.remove(t))),this._collection.clear()}get children(){return this._collection.children}}class LayoutScene extends Scene{constructor(t,e={}){super(t,e),this.spacing=e.spacing??10,this.padding=e.padding??0,this.autoSize=e.autoSize??!0,this.align=e.align??"start",this.debug=e.debug??!1,this._layoutDirty=!0}calculateLayout(){throw new Error("Subclasses must implement calculateLayout()")}update(t){if(this._boundsDirty||this._layoutDirty){const t=this.width,e=this.height,i=this.calculateLayout();this.autoSize&&i&&(Math.abs(this.width-i.width)>.1&&(this.width=i.width),Math.abs(this.height-i.height)>.1&&(this.height=i.height)),i&&i.positions&&this.applyPositionsToChildren(i.positions),this._boundsDirty=!1,this._layoutDirty=!1,t===this.width&&e===this.height||this._updatingBoundsFromLayout||(this._updatingBoundsFromLayout=!0,Scene.prototype.markBoundsDirty.call(this),this._updatingBoundsFromLayout=!1)}super.update(t)}markBoundsDirty(){this._updatingBoundsFromLayout?this._boundsDirty=!0:(super.markBoundsDirty(),this._layoutDirty=!0)}applyPositionsToChildren(t){applyLayout(this.children,t,this.getLayoutOffset())}getLayoutOffset(){return{offsetX:0,offsetY:0}}add(t){const e=super.add(t);return this._layoutDirty=!0,e}remove(t){const e=super.remove(t);return this._layoutDirty=!0,e}}class HorizontalLayout extends LayoutScene{calculateLayout(){return horizontalLayout(this.children,{spacing:this.spacing,padding:this.padding,align:this.align,centerItems:!0})}getLayoutOffset(){return{offsetX:-this.width/2,offsetY:0}}}class VerticalLayout extends LayoutScene{calculateLayout(){return verticalLayout(this.children,{spacing:this.spacing,padding:this.padding,align:this.align,centerItems:!0})}getLayoutOffset(){return{offsetX:0,offsetY:-this.height/2}}}class TileLayout extends LayoutScene{constructor(t,e={}){super(t,e),this.columns=e.columns??4}calculateLayout(){return this.children.length?tileLayout(this.children,{columns:this.columns,spacing:this.spacing,padding:this.padding,centerItems:!0}):null}getLayoutOffset(){return{offsetX:-this.width/2,offsetY:-this.height/2}}}class GridLayout extends LayoutScene{constructor(t,e={}){super(t,e),this.columns=e.columns??4,this.debug=e.debug??!1}calculateLayout(){return this.children.length?gridLayout(this.children,{columns:this.columns,spacing:this.spacing,padding:this.padding,centerItems:this.centerItems,width:this.autoSize?void 0:this.width,height:this.autoSize?void 0:this.height}):null}getLayoutOffset(){return{offsetX:-this.width/2,offsetY:-this.height/2}}}class Text extends GameObjectShapeWrapper{constructor(t,e,i={}){super(t,new TextShape(e,{font:i.font||"16px monospace",color:i.color||"yellow",align:i.align||"left",baseline:i.baseline||"top",strokeColor:i.strokeColor||"#000",lineWidth:i.lineWidth||1,debugColor:i.debugColor||"yellow"}),i),this._textOptions={font:i.font||"16px monospace",color:i.color||"yellow",align:i.align||"left",baseline:i.baseline||"top"}}get text(){return this.shape.text}set text(t){this.shape.text=t,this.markBoundsDirty()}get font(){return this.shape.font}set font(t){this.shape.font=t,this._textOptions.font=t,this.markBoundsDirty()}get color(){return this.shape.color}set color(t){this.shape.color=t,this._textOptions.color=t}get align(){return this.shape.align}set align(t){this.shape.align=t,this._textOptions.align=t,this.markBoundsDirty()}get baseline(){return this.shape.baseline}set baseline(t){this.shape.baseline=t,this._textOptions.baseline=t,this.markBoundsDirty()}measureWidth(){if(!Painter.ctx)return 0;return Painter.text.measureTextWidth(this.text,this.font)}measureHeight(){if(!this.font)return 16;const t=parseInt(this.font);return isNaN(t)?16:t}getBounds(){const t=super.getBounds();if(this.shape.getTextBounds){const t=this.shape.getTextBounds();return{x:this.x,y:this.y,width:t.width,height:t.height}}return t}update(t){super.update(t),this.shape&&(this.width=this.shape.width||this.measureWidth(),this.height=this.shape.height||this.measureHeight())}}class ImageShape extends Shape{constructor(t,e={}){if(!t&&!e.width&&!e.height)throw new Error("ImageShape must be initialized with either a bitmap or width and height");super(e),this._bitmap=t??Painter.img.createImageData(e.width,e.height),this._width=e.width??(null==t?void 0:t.width)??0,this._height=e.height??(null==t?void 0:t.height)??0,this.anchor=e.anchor??"center",this._anchorX=.5,this._anchorY=.5,this._updateAnchorOffsets(),this.smoothing=!1!==e.smoothing,t instanceof ImageData&&this.buffer(t)}_updateAnchorOffsets(){var t;const e=(null==(t=this.anchor)?void 0:t.toLowerCase())??"center";e.includes("left")?this._anchorX=0:e.includes("right")?this._anchorX=1:this._anchorX=.5,e.includes("top")?this._anchorY=0:e.includes("bottom")?this._anchorY=1:this._anchorY=.5}get bitmap(){return this._bitmap}set bitmap(t){t&&(this._bitmap=t,!this._width&&t.width&&(this._width=t.width),!this._height&&t.height&&(this._height=t.height),t instanceof ImageData&&this.buffer(t))}buffer(t){if(!t)return;this._buffer||(this._buffer=document.createElement("canvas")),this._buffer.width===t.width&&this._buffer.height===t.height||(this._buffer.width=t.width,this._buffer.height=t.height);this._buffer.getContext("2d").putImageData(t,0,0)}reset(){this._buffer=null,this._bitmap=Painter.img.createImageData(this.width,this.height)}setAnchor(t){this.anchor=t,this._updateAnchorOffsets()}draw(){if(!this.visible)return;if(!this._bitmap&&!this._buffer)return;super.draw();let t=this._bitmap instanceof ImageData?this._buffer:this._bitmap;(!t||this._bitmap instanceof ImageData&&!this._buffer)&&(this._bitmap instanceof ImageData&&(this.buffer(this._bitmap),t=this._buffer),!t)||Painter.img.draw(t,0,0,{width:this.width,height:this.height,anchor:this.anchor,rotation:this.rotation,scaleX:this.scaleX,scaleY:this.scaleY,alpha:this.opacity,smoothing:this.smoothing,flipX:this.scaleX<0,flipY:this.scaleY<0})}calculateBounds(){return{x:-this._anchorX*this.width,y:-this._anchorY*this.height,width:this.width,height:this.height}}}class ImageGo extends GameObjectShapeWrapper{constructor(t,e,i={}){super(t,e instanceof ImageShape?e:new ImageShape(e,i),i)}reset(){this.shape.reset()}}class Tween{static lerp(t,e,i){return t+(e-t)*i}static lerpAngle(t,e,i){let s=e-t;for(;s<-Math.PI;)s+=2*Math.PI;for(;s>Math.PI;)s-=2*Math.PI;return t+s*i}static tweenColor(t,e,i){return t.map(((t,s)=>Tween.lerp(t,e[s],i)))}static tweenGradient(t,e,i){let s=t[0],o=e[0];Math.abs(o-s)>180&&(s<o?s+=360:o+=360);return[Tween.lerp(s,o,i)%360,Tween.lerp(t[1],e[1],i),Tween.lerp(t[2],e[2],i)]}}class Easing{static easeInQuad(t){return t*t}static easeOutQuad(t){return t*(2-t)}static easeInOutQuad(t){return t<.5?2*t*t:(4-2*t)*t-1}static easeInCubic(t){return t*t*t}static easeOutCubic(t){return--t*t*t+1}static easeInOutCubic(t){return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1}static easeInQuart(t){return t*t*t*t}static easeOutQuart(t){return 1- --t*t*t*t}static easeInOutQuart(t){return t<.5?8*t*t*t*t:1-8*--t*t*t*t}static easeInSine(t){return 1-Math.cos(t*Math.PI/2)}static easeOutSine(t){return Math.sin(t*Math.PI/2)}static easeInOutSine(t){return-(Math.cos(Math.PI*t)-1)/2}static easeInExpo(t){return 0===t?0:Math.pow(2,10*(t-1))}static easeOutExpo(t){return 1===t?1:1-Math.pow(2,-10*t)}static easeInOutExpo(t){return 0===t||1===t?t:t<.5?.5*Math.pow(2,20*t-10):.5*(2-Math.pow(2,-20*t+10))}static easeInCirc(t){return 1-Math.sqrt(1-t*t)}static easeOutCirc(t){return Math.sqrt(1- --t*t)}static easeInOutCirc(t){return t<.5?.5*(1-Math.sqrt(1-4*t*t)):.5*(Math.sqrt(-(2*t-3)*(2*t-1))+1)}static easeInElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return-e*Math.pow(2,10*(t-1))*Math.sin((t-1-s)*(2*Math.PI)/i)}static easeOutElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return e*Math.pow(2,-10*t)*Math.sin((t-s)*(2*Math.PI)/i)+1}static easeInOutElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return t<.5?e*Math.pow(2,10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/i)*-.5:e*Math.pow(2,-10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/i)*.5+1}static easeInBack(t,e=1.70158){return t*t*((e+1)*t-e)}static easeOutBack(t,e=1.70158){return--t*t*((e+1)*t+e)+1}static easeInOutBack(t,e=1.70158){const i=1.525*e;return t<.5?2*t*.5*(2*t)*(2*(i+1)*t-i):.5*((2*t-2)*(2*t-2)*((i+1)*(2*t-2)+i)+2)}static easeOutBounce(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}static easeInBounce(t){return 1-Easing.easeOutBounce(1-t)}static easeInOutBounce(t){return t<.5?.5*Easing.easeInBounce(2*t):.5*Easing.easeOutBounce(2*t-1)+.5}}function bounceV1(t,e,i,s,o,n=!1,a=null,r={},h=null){const{t:l,easedT:c,completed:d,state:u}=Motion._frame(s,o,n,a,r,h),p=1/(i+1),g=Math.min(Math.floor(c/p),i),_=c%p/p,f=t*Math.pow(.6,g),m=e-Math.sin(_*Math.PI)*(e-f);return Motion.animationResult({y:m,segment:g,bounceHeight:f},l,n,d,u)}function floatV1(t,e,i,s,o,n,a=!0,r=null,h={},l=null){if(i<=0)return Motion.animationResult({x:t.x,y:t.y,moving:!1},1,!1,!0);l||(l={initialX:t.x,initialY:t.y,started:!1,completed:!1,loopCount:0});const c=l.initialX,d=l.initialY,{t:u,easedT:p,completed:g,state:_}=Motion._frame(e,i,a,r,h,l);l={...l,..._};const f=e*s,m=Math.max(0,Math.min(1,o)),x=c+(Math.sin(.7*f)+.4*m*Math.sin(2.3*f+.5))*n,M=d+(Math.cos(.9*f)+.4*m*Math.cos(1.9*f+.7))*n,y=.7*Math.cos(.7*f)+.4*m*2.3*Math.cos(2.3*f+.5),b=-.9*Math.sin(.9*f)+.4*m*-1.9*Math.sin(1.9*f+.7),w=Math.sqrt(y*y+b*b),P=w>.8,v=Math.sqrt((x-c)*(x-c)+(M-d)*(M-d));return Motion.animationResult({x:x,y:M,centerX:c,centerY:d,offsetX:x-c,offsetY:M-d,distance:v,moving:P,velocity:w},u,a,g,l)}function followPath(t,e=!1,i,s,o=!1,n=null,a={},r=null){if(!t||t.length<2)return this._createResult({x:0,y:0},0,o,!1);const{t:h,easedT:l,completed:c,state:d}=Motion._frame(i,s,o,n,a,r);if(!r||!r.pathData){const i={segmentLengths:[],totalLength:0,points:[...t]};for(let e=0;e<t.length-1;e++){const s=t[e],o=t[e+1],n=o[0]-s[0],a=o[1]-s[1],r=Math.sqrt(n*n+a*a);i.segmentLengths.push(r),i.totalLength+=r}if(e){const e=t[t.length-1],s=t[0],o=s[0]-e[0],n=s[1]-e[1],a=Math.sqrt(o*o+n*n);i.segmentLengths.push(a),i.totalLength+=a}d.pathData=i}const{segmentLengths:u,totalLength:p,points:g}=d.pathData,_=l*p;let f=0,m=0;for(let t=0;t<u.length;t++){if(f+u[t]>=_){m=t;break}f+=u[t]}const x=(_-f)/u[m],M=g[m],y=m<g.length-1?g[m+1]:g[0],b=Tween.lerp(M[0],y[0],x),w=Tween.lerp(M[1],y[1],x),P=Math.atan2(y[1]-M[1],y[0]-M[0]);return Motion.animationResult({x:b,y:w,angle:P,segmentIndex:m,segmentProgress:x,pathProgress:l},h,o,c,d)}function orbitV1(t,e,i,s,o,n,a,r=!0,h=!0,l=null,c={},d=null){const{t:u,easedT:p,completed:g,state:_}=Motion._frame(n,a,r,l,c,d),f=o+(h?1:-1)*p*Math.PI*2,m=t+i*Math.cos(f),x=e+s*Math.sin(f);return Motion.animationResult({x:m,y:x,angle:f},u,r,g,_)}function oscillateV1(t,e,i,s,o=!0,n=null,a={},r=null){const{t:h,easedT:l,completed:c,state:d}=Motion._frame(i,s,o,n,a,r),u=(e-t)/2,p=t+u+u*Math.sin(l*Math.PI*2);return Motion.animationResult({value:p},h,o,c,d)}function parabolicV1(t,e,i,s,o,n=!1,a=!1,r=null,h={},l=null){l||(l={started:!1,loopCount:0,direction:1,lastDirection:1,completed:!1});let c=o>0?s/o:1,d=!1,u={...h};if(a||n)if(n)if(a){const t=2*o,e=s%t,i=Math.floor(s/t),n=e<o?1:-1;c=1===n?e/o:2-e/o,n!==l.direction&&(l.direction=n,1===l.direction&&u.onLoop&&u.onLoop(i)),i>l.loopCount&&(l.loopCount=i)}else{c%=1;const t=Math.floor(s/o);t>l.loopCount&&u.onLoop&&(u.onLoop(t),l.loopCount=t)}else a&&!n&&(c<=1?l.direction=1:c<=2?(c=2-c,l.direction=-1):(c=0,d=!0,l.direction=1));else c>=1&&(c=1,d=!0);!l.started&&u.onStart&&(u.onStart(),l.started=!0),d&&!l.completed&&u.onComplete&&(u.onComplete(),l.completed=!0);const p=r?r(c):c,g=(t+i-2*e)*p*p+2*(e-t)*p+t,_={...l,lastDirection:l.direction,completed:d||l.completed};return Motion.animationResult({value:g,direction:l.direction},c,n||a&&!d,d,_)}function patrolV1(t,e,i,s,o,n,a=!0,r=null){r||(r={currentX:t,currentY:e,targetX:t,targetY:e,isWaiting:!0,waitStartTime:0,moveStartTime:0,moveCount:0,direction:"idle"});const h=()=>Math.random();let l=r.isWaiting,c=r.currentX,d=r.currentY,u=r.direction;if(l){if(i-r.waitStartTime>=o){l=!1,r.moveStartTime=i;u=["up","down","left","right"][Math.floor(4*h())];let s=r.currentX,o=r.currentY;const a=n*(.2+.6*h());switch(u){case"up":o=r.currentY-a;break;case"down":o=r.currentY+a;break;case"left":s=r.currentX-a;break;case"right":s=r.currentX+a}Math.pow(s-t,2)+Math.pow(o-e,2)>n*n&&("up"===u||"down"===u?(o=e,u=r.currentY>e?"up":"down"):(s=t,u=r.currentX>t?"left":"right")),r.targetX=s,r.targetY=o,r.direction=u,r.moveCount++}}else{const t=(i-r.moveStartTime)/s;t>=1?(l=!0,r.waitStartTime=i,r.currentX=r.targetX,r.currentY=r.targetY,u="idle"):(c=r.currentX+(r.targetX-r.currentX)*t,d=r.currentY+(r.targetY-r.currentY)*t)}r.isWaiting=l,r.direction=u,l||(r.currentX=c,r.currentY=d);const p=s+o,g=i%p/p,_=Math.sqrt(Math.pow(c-t,2)+Math.pow(d-e,2));return Motion.animationResult({x:c,y:d,moving:!l,direction:u,distanceFromCenter:_},g,a,!1,r)}function pendulumV1(t,e,i,s,o=!0,n=!1,a=null,r={},h=null){const{t:l,easedT:c,completed:d,state:u}=Motion._frame(i,s,o,null,r,h),p=n&&!o?Math.exp(-4*l):1;let g=t+e*Math.cos(2*c*Math.PI)*p;if(a){g=t+a(((g-t)/(e*p)+1)/2)*e*p*2-e*p}return Motion.animationResult({angle:g},l,o,d,u)}function pulseV1(t,e,i,s,o=!0,n=!1,a=null,r={}){let h,l=i/s,c="forward";if(o){const t=Math.floor(l);l%=1,t>0&&r.onLoop&&r.onLoop(t)}else l>1&&(l=1);if(l>0&&i<=s&&r.onStart&&r.onStart(),n)if(l<.5){const i=2*l;h=t+(e-t)*(a?a(i):i),c="forward"}else{const i=2*(l-.5);h=e-(e-t)*(a?a(i):i),c="return",l>=.5&&l<.51&&r.onYoyoTurn&&r.onYoyoTurn()}else{const i=a?a(l):l;h=t+(e-t)*(i<.5?2*i:2-2*i)}const d=!o&&l>=1;return d&&r.onComplete&&r.onComplete(),Motion.animationResult({value:h,phase:c},l,o,d)}function hopV1(t,e,i,s,o=!0,n=!0,a=null,r={},h=null){const{t:l,easedT:c,completed:d,state:u}=Motion._frame(i,s,o,a,r,h,n);let p=0;p=o||n?n?Math.sin(c*Math.PI):Math.sin(Math.min(l,1)*Math.PI*.5):d?1:Math.sin(Math.min(l,1)*Math.PI*.5);const g=t-e*p;return Motion.animationResult({y:g},l,o,d,u)}function shakeV1(t,e,i,s,o,n,a,r,h=!1,l=null,c={},d=null){const{t:u,easedT:p,completed:g,state:_}=Motion._frame(a,r,h,l,c,d),f=Math.pow(1-p,n),m=p*Math.PI*2*o,x=p*Math.PI*2*o*1.3,M=f*i*(.6*Math.sin(m)+.3*Math.sin(2.5*m)+.1*Math.sin(5.6*m)),y=f*s*(.6*Math.cos(x)+.3*Math.cos(2.7*x)+.1*Math.cos(6.3*x));let b=t+M,w=e+y;if(p>.9){const i=(p-.9)/.1;b=t+M*(1-i),w=e+y*(1-i)}return Motion.animationResult({x:b,y:w,intensity:f},u,h,g,_)}function spiralV1(t,e,i,s,o,n,a,r,h=!1,l=!1,c=null,d={},u=null){u||(u={started:!1,loopCount:0,direction:1,lastDirection:1});let p=r>0?a/r:1,g=!1,_={...d};if(l||h)if(h)if(l){const t=2*r,e=a%t,i=Math.floor(a/t),s=e<r?1:-1;p=1===s?e/r:2-e/r,s!==u.direction&&(u.direction=s,1===u.direction&&_.onLoop&&_.onLoop(i)),i>u.loopCount&&(u.loopCount=i)}else{p%=1;const t=Math.floor(a/r);t>u.loopCount&&_.onLoop&&(_.onLoop(t),u.loopCount=t)}else l&&!h&&(p<=1?u.direction=1:p<=2?(p=2-p,u.direction=-1):(p=0,g=!0,u.direction=1));else p>=1&&(p=1,g=!0);!u.started&&_.onStart&&(_.onStart(),u.started=!0),g&&!u.completed&&_.onComplete&&(_.onComplete(),u.completed=!0);const f=c?c(p):p,m=Tween.lerp(i,s,f),x=o+f*n*Math.PI*2,M=t+m*Math.cos(x),y=e+m*Math.sin(x),b={...u,lastDirection:u.direction};return Motion.animationResult({x:M,y:y,radius:m,angle:x,direction:u.direction},p,h||l&&!g,g,b)}function springV1(t,e,i,s,o=!1,n=!1,a={},r={}){if(s<=0)return this.animationResult({value:e,velocity:0,done:!0,phase:"complete"},1,!1,!0);let h,l,c,d=i/s,u="forward",p=0;o?(p=Math.floor(d),d%=1,p>0&&r.onLoop&&r.onLoop(p)):d>1&&(d=1),d>0&&i<=s&&r.onStart&&r.onStart(),n?d>=.5?(h=t,l=e,c=2*(d-.5),u="return",d>=.5&&d<.51&&r.onYoyoTurn&&r.onYoyoTurn()):(h=e,l=t,c=2*d,u="forward"):(h=e,l=t,c=d);const g=void 0!==a.stiffness?a.stiffness:.3,_=void 0!==a.damping?a.damping:.6,f=Math.max(.1,1/(1.5*_)),m=Math.max(.1,.8/(1.5*g+.5));let x;if(c<.99)x=Easing.easeOutElastic(c,f,m);else{const t=(c-.99)/.01;x=Easing.easeOutElastic(.99,f,m)*(1-t)+1*t}const M=Tween.lerp(l,h,x),y=Math.min(c+.01,1);let b;if(y<.99)b=Easing.easeOutElastic(y,f,m);else{const t=(y-.99)/.01;b=Easing.easeOutElastic(.99,f,m)*(1-t)+1*t}const w=(Tween.lerp(l,h,b)-M)/.01*s,P=!o&&d>=1;return P&&r.onComplete&&r.onComplete(),Motion.animationResult({value:M,velocity:w,delta:"forward"===u?e-M:t-M,done:P,phase:u},d,o,P)}function swingV1(t,e,i,s,o,n=!0,a=!0,r=null,h={},l=null){const{t:c,easedT:d,completed:u,state:p}=Motion._frame(s,o,n,r,h,l),g=(a?Math.sin(d*Math.PI*2):Math.sin(d*Math.PI))*i;return Motion.animationResult({angle:g},c,n,u,p)}function waypointV1(t,e,i,s,o,n=!0,a={},r=null){if(!i||!Array.isArray(i)||i.length<2)return console.warn("Patrol animation requires at least 2 waypoints"),Motion._createResult({x:0,y:0,moving:!1,direction:"idle",waypoint:0},0,!1,!0);r||(r={currentWaypoint:0,nextWaypoint:1,isWaiting:!0,waitStartTime:0,lastWaypointTime:0,lastWaypointReached:-1,completed:!1});let h=0;for(let t=0;t<i.length;t++){const e=(t+1)%i.length;if(!n&&t===i.length-1)break;const s=i[e][0]-i[t][0],o=i[e][1]-i[t][1];h+=Math.abs(s)+Math.abs(o)}const l=h/s+o*i.length;let c=e;c=n?e%l:Math.min(e,l);const d=c/l;let u,p,g,_=c,f=0,m=1,x=!0,M=0,y=0,b=!1;if(_<o)M=_/o,f=0,m=1,x=!0;else{_-=o;for(let t=0;t<i.length;t++){if(!n&&t===i.length-1){f=t,m=t,x=!0,M=1,b=!0;break}const e=(t+1)%i.length,h=i[e][0]-i[t][0],l=i[e][1]-i[t][1],c=(Math.abs(h)+Math.abs(l))/s;if(_<c){f=t,m=e,x=!1,y=_/c;break}if(_-=c,_<o){f=e,m=(e+1)%i.length,x=!0,M=_/o,r.lastWaypointReached!==f&&(a.onWaypointReached&&a.onWaypointReached(f),a.onWaitStart&&a.onWaitStart(f),r.lastWaypointReached=f);break}_-=o}}if(x||b)u=i[f][0],p=i[f][1],g="idle",!r.isWaiting&&x&&a.onWaitEnd&&a.onWaitEnd(f);else{const t=i[f],e=i[m],s=e[0]-t[0],o=e[1]-t[1],n=Math.abs(s)+Math.abs(o),a=Math.abs(s)/n;if(y<=a&&0!==s){const e=y/a;u=t[0]+s*e,p=t[1],g=s>0?"right":"left"}else{const i=(y-a)/(1-a);u=e[0],p=t[1]+o*i,g=o>0?"down":"up"}}return r.currentWaypoint=f,r.nextWaypoint=m,r.isWaiting=x,!r.completed&&b&&a.onPatrolComplete&&(a.onPatrolComplete(),r.completed=!0),Motion.animationResult({x:u,y:p,moving:!x,waiting:x,waitProgress:x?M:0,direction:g,waypoint:f,nextWaypoint:m},d,n,b,r)}class Motion{static animationResult(t,e,i,s=!1,o=null){return{...t,t:e,progress:e,loop:i,completed:s,state:o}}static _step(t,e,i,s={},o={started:!1,loopCount:0}){let n=e>0?t/e:1,a=!1;if(!(o=o||{started:!1,loopCount:0}).started&&s.onStart&&(s.onStart(),o.started=!0),i){n%=1;const i=Math.floor(t/e);i>o.loopCount&&s.onLoop&&(s.onLoop(i),o.loopCount=i)}else n>=1&&(n=1,a=!0,!o.completed&&s.onComplete&&(s.onComplete(),o.completed=!0));return{t:n,completed:a,state:o}}static _frame(t,e,i,s=null,o={},n=null){const{t:a,completed:r,state:h}=this._step(t,e,i,o,n);return{t:a,easedT:s?s(a):a,completed:r,state:h}}static oscillate(t,e,i,s,o=!0,n=null,a={},r=null){return oscillateV1(t,e,i,s,o,n,a,r)}static parabolic(t,e,i,s,o,n=!1,a=!1,r=null,h={},l=null){return parabolicV1(t,e,i,s,o,n,a,r,h,l)}static float(t,e,i,s,o,n,a=!0,r=null,h={},l=null){return floatV1(t,e,i,s,o,n,a,r,h,l)}static spring(t,e,i,s,o=!1,n=!1,a={},r={}){return springV1(t,e,i,s,o,n,a,r)}static swing(t,e,i,s,o,n=!0,a=!0,r=null,h={},l=null){return swingV1(t,e,i,s,o,n,a,r,h,l)}static pendulum(t,e,i,s,o=!0,n=!1,a=null,r={},h=null){return pendulumV1(t,e,i,s,o,n,a,r,h)}static pulse(t,e,i,s,o=!0,n=!1,a=null,r={}){return pulseV1(t,e,i,s,o,n,a,{})}static spiral(t,e,i,s,o,n,a,r,h=!1,l=!1,c=null,d={},u=null){return spiralV1(t,e,i,s,o,n,a,r,h,l,c,d,u)}static orbit(t,e,i,s,o,n,a,r=!0,h=!0,l=null,c={},d=null){return orbitV1(t,e,i,s,o,n,a,r,h,l,c,d)}static bezier(t,e,i,s,o,n,a=!1,r=!1,h=null,l={},c=null){return bezierV1(t,e,i,s,o,n,a,r,h,l,c)}static bounce(t,e,i,s,o,n=!1,a=null,r={},h=null){return bounceV1(t,e,i,s,o,n,a,r,h)}static shake(t,e,i,s,o,n,a,r,h=!1,l=null,c={},d=null){return shakeV1(t,e,i,s,o,n,a,r,h,l,c,d)}static follow(t,e=!1,i,s,o=!1,n=null,a={},r=null){return followPath(t,e,i,s,o,n,a,r)}static waypoint(t,e,i,s,o,n=!0,a={},r=null){return waypointV1(t,e,i,s,o,n,a,r)}static patrol(t,e,i,s,o,n,a=!0,r=null){return patrolV1(t,e,i,s,o,n,a,r)}static hop(t,e,i,s,o=!0,n=!0,a=null,r={},h=null){return hopV1(t,e,i,s,o,n,a,r,h)}static group(t,e,i,s,o=!1,n=null,a={},r=null){r||(r={started:!1,loopCount:0,animationStates:Array(t.length).fill(null)});const{t:h,easedT:l,completed:c,state:d}=this._frame(i,s,o,n,a,r),u={};for(let r=0;r<t.length;r++){const h=t[r],l=[...e[r]];h===this.parabolic||h===this.oscillate||h===this.pulse?(l[3]=i,l[4]=s,l[5]=o,void 0===l[6]&&(l[6]=n)):h===this.spring?(l[2]=i,l[3]=s,l[4]=o):h===this.spiral||h===this.bezier?(l[6]=i,l[7]=s,l[8]=o,void 0===l[9]&&(l[9]=n)):h===this.orbit?(l[5]=i,l[6]=s,l[7]=o,void 0===l[9]&&(l[9]=n)):h===this.bounce||h===this.shake?(l[6]=i,l[7]=s,l[8]=o,void 0===l[9]&&(l[9]=n)):h===this.followPath&&(l[2]=i,l[3]=s,l[4]=o,void 0===l[5]&&(l[5]=n)),l.push(a),l.push(d.animationStates[r]);const c=h.apply(this,l);d.animationStates[r]=c.state;u[`anim${r}`]=c}return this.animationResult(u,h,o,c,d)}static sequence(t,e,i,s,o=!1,n=null,a={},r=null,h=null){if(!h){h={started:!1,loopCount:0,animationStates:Array(t.length).fill(null),currentAnim:0,animStartTimes:[0],totalDuration:0};let e=0;for(let t=0;t<i.length;t++)e+=i[t],t<i.length-1&&h.animStartTimes.push(e);h.totalDuration=e}let l=s;if(o&&h.totalDuration>0){l=s%h.totalDuration;const t=Math.floor(s/h.totalDuration);t>h.loopCount&&a.onLoop&&(a.onLoop(t),h.loopCount=t)}!h.started&&a.onStart&&(a.onStart(),h.started=!0);let c=0;for(let e=t.length-1;e>=0;e--)if(l>=h.animStartTimes[e]){c=e;break}h.currentAnim=c;const d=l-h.animStartTimes[c],u=i[c],p=t[c],g=[...e[c]];p===this.parabolic||p===this.oscillate||p===this.pulse?(g[3]=d,g[4]=u,g[5]=!1,n&&n[c]&&(g[6]=n[c])):p===this.spring?(g[2]=d,g[3]=u,g[4]=!1):p===this.spiral||p===this.bezier?(g[6]=d,g[7]=u,g[8]=!1,n&&n[c]&&(g[9]=n[c])):p===this.orbit?(g[5]=d,g[6]=u,g[7]=!1,n&&n[c]&&(g[9]=n[c])):p===this.bounce||p===this.shake?(g[6]=d,g[7]=u,g[8]=!1,n&&n[c]&&(g[9]=n[c])):p===this.followPath&&(g[2]=d,g[3]=u,g[4]=!1,n&&n[c]&&(g[5]=n[c]));const _=r&&r[c]?r[c]:{},f=p.apply(this,[...g,_,h.animationStates[c]]);h.animationStates[c]=f.state;const m=!o&&l>=h.totalDuration;return m&&!h.completed&&a.onComplete&&(a.onComplete(),h.completed=!0),this.animationResult({...f,currentAnim:c,totalAnimations:t.length,sequenceProgress:Math.min(l/h.totalDuration,1)},l/h.totalDuration,o,m,h)}}function bezierV1(t,e,i,s,o,n,a=!1,r=!1,h=null,l={},c=null){if(n<=0)return Motion.animationResult({x:s[0],y:s[1],phase:"complete"},1,!1,!0);let d=o/n,u="forward",p=0;a?(p=Math.floor(d),d%=1,p>0&&l.onLoop&&l.onLoop(p)):d>1&&(d=1),d>0&&o<=n&&l.onStart&&l.onStart();let g=h?h(d):d;r&&(d>=.5?(g=1-2*(d-.5),u="return",d>=.5&&d<.51&&l.onYoyoTurn&&l.onYoyoTurn()):(g=2*d,u="forward"),g=h?h(g):g);const _=3*(e[0]-t[0]),f=3*(i[0]-e[0])-_,m=s[0]-t[0]-_-f,x=3*(e[1]-t[1]),M=3*(i[1]-e[1])-x,y=s[1]-t[1]-x-M,b=m*Math.pow(g,3)+f*Math.pow(g,2)+_*g+t[0],w=y*Math.pow(g,3)+M*Math.pow(g,2)+x*g+t[1],P=!a&&d>=1;return P&&l.onComplete&&l.onComplete(),Motion.animationResult({x:b,y:w,phase:u},d,a,P,c)}class Tweenetik{constructor(t,e,i,s,o={}){this.target=t,this.toProps={...e},this.duration=i,this.easingFn=s||Easing.easeOutQuad,this.delay=o.delay||0,this.onStart=o.onStart||null,this.onComplete=o.onComplete||null,this.onUpdate=o.onUpdate||null,this._elapsed=0,this._started=!1,this._finished=!1,this._startProps={};for(const t in this.toProps)t in this.target&&(this._startProps[t]=this.target[t])}static to(t,e,i,s,o){const n=new Tweenetik(t,e,i,s,o);return Tweenetik._active.push(n),n}update(t){if(this._finished)return;if(this._elapsed+=t,this._elapsed<this.delay)return;const e=this._elapsed-this.delay,i=Math.min(e/this.duration,1);!this._started&&i>0&&(this._started=!0,this.onStart&&this.onStart());const s=this.easingFn(i);for(const t in this._startProps){const e=this._startProps[t],i=this.toProps[t];this.target[t]=Tween.lerp(e,i,s)}this.onUpdate&&this.onUpdate(),i>=1&&(this._finished=!0,this.onComplete&&this.onComplete())}static updateAll(t){for(const e of Tweenetik._active)e.update(t);Tweenetik._active=Tweenetik._active.filter((t=>!t._finished))}}class Pipeline extends Loggable{constructor(t){super(),this.game=t,this._collection=new ZOrderedCollection,this._collection._owner=this;["inputdown","inputup","inputmove","click"].forEach((t=>{this.game.events.on(t,(e=>{this.dispatchInputEvent(t,e)}))}))}_hoverObject(t,e){if(!t.interactive||!t._hitTest)return;const i=t._hitTest(e.x,e.y);i&&!t._hovered?(t._hovered=!0,t.events.emit("mouseover",e)):!i&&t._hovered&&(t._hovered=!1,t.events.emit("mouseout",e))}_hoverScene(t,e){for(let i=t.children.length-1;i>=0;i--){const s=t.children[i];s instanceof Scene?this._hoverScene(s,e):this._hoverObject(s,e)}}dispatchInputEvent(t,e){var i;for(let s=this.gameObjects.length-1;s>=0;s--){const o=this.gameObjects[s];if(o instanceof Scene){if(this._dispatchToScene(o,t,e))break}else if(o.interactive&&(null==(i=o._hitTest)?void 0:i.call(o,e.x,e.y))){o.events.emit(t,e);break}}"inputmove"===t&&this._dispatchHover(e)}_dispatchHover(t){for(let e=this.gameObjects.length-1;e>=0;e--){const i=this.gameObjects[e];i instanceof Scene?this._hoverScene(i,t):this._hoverObject(i,t)}}_dispatchToScene(t,e,i){var s;for(let o=t.children.length-1;o>=0;o--){const n=t.children[o];if(n instanceof Scene){if(this._dispatchToScene(n,e,i))return!0}else if(n.interactive&&(null==(s=n._hitTest)?void 0:s.call(n,i.x,i.y)))return n.events.emit(e,i),!0}return!1}add(t){t.parent=this.game;const e=this._collection.add(t);return e.init&&e.init(),e}remove(t){null!=t?this._collection.remove(t):this.logger.warn("Cannot remove undefined or null object",t)}bringToFront(t){return this._collection.bringToFront(t)}sendToBack(t){return this._collection.sendToBack(t)}bringForward(t){return this._collection.bringForward(t)}sendBackward(t){return this._collection.sendBackward(t)}clear(){return this._collection.clear()}get gameObjects(){return this._collection.children}update(t){this.logger.groupCollapsed("Pipeline.update"),this._collection.children.filter((t=>t.active)).forEach((e=>e.update(t))),Tweenetik.updateAll(t),this.logger.groupEnd()}render(){this.logger.groupCollapsed("Pipeline.render"),this._collection.getSortedChildren().filter((t=>t.visible)).filter((t=>t.active)).forEach((t=>t.render())),this.logger.groupEnd()}}class Cursor extends GameObject{constructor(t,e,i=null,s={}){super(t,s),this.normalShape=e,this.pressedShape=i||e,this.active=!1,this.offsetX=0,this.offsetY=0,this.isDown=!1,this.game.events.on("inputmove",(t=>{this.x=t.x,this.y=t.y})),this.game.events.on("inputdown",(()=>{this.isDown=!0})),this.game.events.on("inputup",(()=>{this.isDown=!1})),this.game.events.on("mouseover",(()=>{this.visible=!1})),this.game.events.on("mouseout",(()=>{this.visible=!0}))}activate(){this.active=!0,this.game.canvas.style.cursor="none"}deactivate(){this.active=!1,this.game.canvas.style.cursor="default"}draw(){if(super.draw(),!this.active)return;const t=this.isDown&&this.pressedShape?this.pressedShape:this.normalShape;t&&t.render()}}class Game{constructor(t){__privateAdd(this,_prevWidth,0),__privateAdd(this,_prevHeight,0),this.canvas=t,this.ctx=t.getContext("2d"),this.events=new EventEmitter,this._cursor=null,this.lastTime=0,this.dt=0,this.running=!1,this._frame=0,this.pipeline=new Pipeline(this),Painter.init(this.ctx),this.targetFPS=60,this._frameInterval=1e3/this.targetFPS,this._accumulator=0,this._pauseOnBlur=!1,this._isPaused=!1,this._init=!1,this.initLogging()}setFPS(t){this.targetFPS=t,this._frameInterval=1e3/t}init(){this.initIO(),this.initMotion(),this._init=!0,this.logger.log("[Game] Initialized")}initMouse(){Mouse.init(this)}initTouch(){Touch.init(this)}initInput(){Input.init(this)}initKeyboard(){Keys.init(this)}initIO(){this.initMouse(),this.initTouch(),this.initInput(),this.initKeyboard()}initMotion(){Tweenetik._active=[]}initLogging(){this.logger=new Logger("Game"),Logger.setOutput(console),Logger.disableAll(),Logger.disable(),Logger.setLevel(Logger.INFO),this.logger.groupCollapsed("Initializing Game...")}enableLogging(){Logger.enable()}disableLogging(){Logger.disableAll(),Logger.disable()}markBoundsDirty(){this._boundsDirty=!0}get boundsDirty(){return this._boundsDirty}set boundsDirty(t){this._boundsDirty=t}enableFluidSize(t=window){if(t===window){const t=()=>{var t;this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight,__privateGet(this,_prevWidth)===this.canvas.width&&__privateGet(this,_prevHeight)===this.canvas.height||(this.markBoundsDirty(),null==(t=this.onResize)||t.call(this)),__privateSet(this,_prevWidth,this.canvas.width),__privateSet(this,_prevHeight,this.canvas.height)};t(),window.addEventListener("resize",t),this._fluidResizeCleanup=()=>{window.removeEventListener("resize",t)}}else{if(!("ResizeObserver"in window))return void console.warn("ResizeObserver not supported in this browser.");const e=()=>{const e=t.getBoundingClientRect();this.canvas.width=e.width,this.canvas.height=e.height},i=new ResizeObserver((()=>{e()}));i.observe(t),e(),this._fluidResizeCleanup=()=>i.disconnect()}}disableFluidSize(){this._fluidResizeCleanup&&(this._fluidResizeCleanup(),this._fluidResizeCleanup=null)}start(){if(this.logger.groupCollapsed("[Game] Starting..."),this.init(),!this._init)throw new Error("Game not initialized. Did you call init()? Remember to call super.init() in your subclass.");this.running=!0,this.loop=this.loop.bind(this),requestAnimationFrame(this.loop),this.logger.log("[Game] Started"),this.logger.groupEnd()}stop(){this.running=!1,this.logger.log("[Game] Stopped")}restart(){this.pipeline.clear(),this.init(),this.start(),this.logger.log("[Game] Restarted")}loop(t){if(!this.running)return;const e=t-this.lastTime;if(this.lastTime=t,this._accumulator+=e,this.actualFps=1e3/e,this._accumulator>=this._frameInterval){const t=this._frameInterval/1e3;this.dt=t,this._frame++,this.logger.groupCollapsed(`Frame #${this._frame}`),this.logger.time("render time"),this.update(t),this.render(),this.logger.timeEnd("render time"),this.logger.groupEnd(),this._accumulator-=this._frameInterval}this.boundsDirty&&(this.boundsDirty=!1),requestAnimationFrame(this.loop)}update(t){this.pipeline.update(t)}render(){this.running&&this.clear(),this.pipeline.render()}clear(){Painter.clear()}get width(){return this.canvas.width}get height(){return this.canvas.height}set backgroundColor(t){this.canvas.style.backgroundColor=t}set cursor(t){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor)),this._cursor=t,this._cursor.activate(),this.pipeline.add(t)}get cursor(){return this._cursor}resetCursor(){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor),this._cursor=null)}enablePauseOnBlur(t){this._pauseOnBlur=t,t?window.addEventListener("visibilitychange",this._handleVisibilityChange.bind(this),!1):window.removeEventListener("visibilitychange",this._handleVisibilityChange.bind(this),!1)}_handleVisibilityChange(){this.logger.log("Visibility change detected"),document.hidden?this._pauseOnBlur&&this.running&&(this._isPaused=!0,this.stop(),this.logger.log("Paused due to tab visibility change")):this._isPaused&&(this._isPaused=!1,this.start(),this.logger.log("Resumed after tab visibility change"))}}_prevWidth=new WeakMap,_prevHeight=new WeakMap;class Button extends GameObject{constructor(t,e={}){super(t,e);const{x:i=0,y:s=0,width:o=120,height:n=40,text:a="Button",font:r="14px monospace",textColor:h="#000",textAlign:l="center",textBaseline:c="middle",shape:d=null,label:u=null,onClick:p=null,onHover:g=null,onPressed:_=null,onRelease:f=null,padding:m=10,colorDefaultBg:x="#eee",colorDefaultStroke:M="#999",colorDefaultText:y="#333",colorHoverBg:b="#222",colorHoverStroke:w="#16F529",colorHoverText:P="#16F529",colorPressedBg:v="#111",colorPressedStroke:k="#00aaff",colorPressedText:C="#00aaff"}=e;this.x=i,this.y=s,this.width=o,this.height=n,this.padding=m,this.textAlign=l,this.textBaseline=c,this.initColorScheme({colorDefaultBg:x,colorDefaultStroke:M,colorDefaultText:y,colorHoverBg:b,colorHoverStroke:w,colorHoverText:P,colorPressedBg:v,colorPressedStroke:k,colorPressedText:C}),this.initBackground(d),this.initLabel(a,r,h,u),this.initGroup(),this.initEvents(p,g,_,f),this.setState("default")}initColorScheme(t){this.colors={default:{bg:t.colorDefaultBg,stroke:t.colorDefaultStroke,text:t.colorDefaultText},hover:{bg:t.colorHoverBg,stroke:t.colorHoverStroke,text:t.colorHoverText},pressed:{bg:t.colorPressedBg,stroke:t.colorPressedStroke,text:t.colorPressedText}}}initBackground(t){this.bg=t??new Rectangle({width:this.width,height:this.height,color:this.colors.default.bg,stroke:this.colors.default.stroke,lineWidth:2})}initLabel(t,e,i,s){this.label=s??new TextShape(t,{font:e,color:i,align:this.textAlign,baseline:this.textBaseline}),this.alignText()}alignText(){if(!this.label)return;const t=this.width/2,e=this.height/2;switch(this.textAlign){case"left":this.label.x=-t+this.padding;break;case"right":this.label.x=t-this.padding;break;default:this.label.x=0}switch(this.textBaseline){case"top":this.label.y=-e+this.padding;break;case"bottom":this.label.y=e-this.padding;break;default:this.label.y=0}}initGroup(){this.group=new Group,this.group.add(this.bg),this.group.add(this.label)}initEvents(t,e,i,s){this.interactive=!0,this.onHover=e,this.onPressed=i,this.onRelease=s,this.on("mouseover",this.setState.bind(this,"hover")),this.on("mouseout",this.setState.bind(this,"default")),this.on("inputdown",this.setState.bind(this,"pressed")),this.on("inputup",(()=>{"pressed"===this.state&&"function"==typeof t&&t(),this.setState("hover")}))}setState(t){var e,i,s;if(this.state!==t)switch(this.state=t,t){case"default":this.game.cursor&&setTimeout((()=>{this.game.cursor.activate()}),0),this.bg.color=this.colors.default.bg,this.bg.stroke=this.colors.default.stroke,this.label.color=this.colors.default.text,this.game.canvas.style.cursor="default",null==(e=this.onRelease)||e.call(this);break;case"hover":this.game.cursor&&this.game.cursor.deactivate(),this.bg.color=this.colors.hover.bg,this.bg.stroke=this.colors.hover.stroke,this.label.color=this.colors.hover.text,this.game.canvas.style.cursor="pointer",null==(i=this.onHover)||i.call(this);break;case"pressed":this.game.cursor&&this.game.cursor.deactivate(),this.bg.color=this.colors.pressed.bg,this.bg.stroke=this.colors.pressed.stroke,this.label.color=this.colors.pressed.text,this.game.canvas.style.cursor="pointer",null==(s=this.onPressed)||s.call(this)}}update(t){super.update(t),this._boundsDirty&&this.alignText()}get text(){return this.label.text}set text(t){this.label.text=t,this._boundsDirty=!0}setTextAlign(t){this.textAlign=t,this.label.align=t,this._boundsDirty=!0}setTextBaseline(t){this.textBaseline=t,this.label.baseline=t,this._boundsDirty=!0}setFont(t){this.label.font=t,this._boundsDirty=!0}resize(t,e){this.width=t,this.height=e,this.bg.width=t,this.bg.height=e,this._boundsDirty=!0}draw(){super.draw(),this.group.render()}}class ToggleButton extends Button{constructor(t,e={}){const i=e.onClick;super(t,{...e,onClick:()=>{this.toggled=!this.toggled,"function"==typeof e.onToggle&&e.onToggle(this.toggled),"function"==typeof i&&i(),this.refreshToggleVisual()}}),this.colorActiveBg=e.colorActiveBg||"#444",this.colorActiveStroke=e.colorActiveStroke||"#0f0",this.colorActiveText=e.colorActiveText||"#0f0",this.toggled=!!e.startToggled,this.refreshToggleVisual()}toggle(t){this.toggled=t,this.refreshToggleVisual()}refreshToggleVisual(){this.toggled?(this.bg.fillColor=this.colorActiveBg,this.bg.strokeColor=this.colorActiveStroke,this.label.color=this.colorActiveText):(this.bg.fillColor=this.colors.default.bg,this.bg.strokeColor=this.colors.default.stroke,this.label.color=this.colors.default.text)}setState(t){super.setState(t),this.toggled&&(this.bg.fillColor=this.colorActiveBg,this.bg.strokeColor=this.colorActiveStroke,this.label.color=this.colorActiveText)}}class FPSCounter extends Text{constructor(t,e={}){super(t,"0 FPS",{x:0,y:0,font:"12px monospace",color:"#0f0",align:"center",baseline:"middle",debug:!1,...e}),this.fps=0,this._frames=0,this._accum=0}update(t){const e=this.game.actualFps;e&&(this._frames++,this._accum+=t,this._accum>=.5&&(this.fps=Math.round(e),this.text=`${this.fps} FPS`,this._accum=0,this._frames=0),super.update(t))}getBounds(){if(this.shape&&this.shape.getTextBounds){const t=this.shape.getTextBounds();return{x:t.x,y:t.y,width:t.width,height:t.height}}return super.getBounds()}getDebugBounds(){if(this.shape&&this.shape.getDebugBounds){const t=this.shape.getDebugBounds();return{x:t.x,y:t.y,width:t.width,height:t.height}}return super.getDebugBounds()}}export{Arc,Arrow,BezierShape,Button,Circle,Cloud,Complex,Cone,Cross,Cube,Cursor,Cylinder,DebugTab,Diamond,Easing,Euclidian,EventEmitter,FPSCounter,Fractals,Game,GameObject,GameObjectShapeWrapper,Geometry2d,GridLayout,Group,Heart,Hexagon,HorizontalLayout,ImageGo,Input,Keys,LayoutScene,Line,Loggable,Logger,Motion,Mouse,Noise,OutlinedText,Painter,PainterColors,PainterEffects,PainterImages,PainterLines,PainterOpacity,PainterShapes,PainterText,PatternRectangle,Patterns,PieSlice,Pin,Pipeline,Polygon,Position,Prism,Random,Rectangle,Renderable,Ring,RoundedRectangle,SVGShape,Scene,Shape,ShapeGOFactory,Sphere,Square,Star,StickFigure,TaskManager,Text,TextShape,TileLayout,ToggleButton,Touch,Traceable,Transformable,Triangle,Tween,Tweenetik,VerticalLayout,WrappedText,ZOrderedCollection,applyAnchor,applyDraggable,applyLayout,bezierV1,bounceV1,floatV1,followPath,gridLayout,hopV1,horizontalLayout,orbitV1,oscillateV1,parabolicV1,patrolV1,pendulumV1,pulseV1,shakeV1,spiralV1,springV1,swingV1,tileLayout,verticalLayout,waypointV1};