var _Grad,_grad3,_p,_perm,_gradP,_F2,_G2,_F3,_G3,_Noise_static,fade_fn,lerp_fn,_components,_dimension,_name,_signature,_coordinates,__colors,__effects,__img,__lines,__opacity,__shapes,__text,_Painter_static,checkInitialized_fn,_prevWidth,_prevHeight,_parent,_go,_refs,_state,_shapes,_motions,_FluentGO_instances,addShapeInstance_fn,normalizeShapeOpts_fn,processMotions_fn,applyMotion_fn,_parent2,_layerGO,_group,_refs2,_state2,_parent3,_scene,_refs3,_state3,_lastGO,_game,_scenes,_currentScene,_refs4,_state4,_plugins,_canvas,_FluentGame_instances,createCanvas_fn,createContext_fn,__ctx,__output,__ctx2,__output2,__ctx3,__analyzer,__dataArray,__frequencyData,__ctx4,__masterGain,__initialized,__defProp=Object.defineProperty,__typeError=t=>{throw TypeError(t)},__defNormalProp=(t,e,i)=>e in t?__defProp(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i,__publicField=(t,e,i)=>__defNormalProp(t,"symbol"!=typeof e?e+"":e,i),__accessCheck=(t,e,i)=>e.has(t)||__typeError("Cannot "+i),__privateGet=(t,e,i)=>(__accessCheck(t,e,"read from private field"),i?i.call(t):e.get(t)),__privateAdd=(t,e,i)=>e.has(t)?__typeError("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,i),__privateSet=(t,e,i,s)=>(__accessCheck(t,e,"write to private field"),s?s.call(t,i):e.set(t,i),i),__privateMethod=(t,e,i)=>(__accessCheck(t,e,"access private method"),i);class ZOrderedCollection{constructor(t={}){this.children=[],this.sortByZIndex=t.sortByZIndex||!0,this._zOrderDirty=!1}add(t){return this.children.includes(t)?(console.warn("Object is already in this collection"),t):(this.children.push(t),t.parent=this._owner||this,this.sortByZIndex&&(this._zOrderDirty=!0,t.zIndex=this.children.length-1),t)}remove(t){const e=this.children.indexOf(t);return-1!==e&&(this.children.splice(e,1),t.parent=null,!0)}clear(){this.children.forEach((t=>{t.parent=null})),this.children=[]}bringToFront(t){const e=this.children.indexOf(t);if(-1!==e)if(this.sortByZIndex){let e=!0;for(const i of this.children)if(i!==t&&(i.zIndex||0)>=(t.zIndex||0)){e=!1;break}e||(t.zIndex=Number.MAX_SAFE_INTEGER,this._zOrderDirty=!0,this._normalizeZIndices())}else e!==this.children.length-1&&(this.children.splice(e,1),this.children.push(t));else this.add(t)}sendToBack(t){const e=this.children.indexOf(t);if(-1===e)return this.children.unshift(t),void(t.parent=this._owner||this);if(this.sortByZIndex){let e=!0;for(const i of this.children)if(i!==t&&(i.zIndex||0)<=(t.zIndex||0)){e=!1;break}e||(t.zIndex=Number.MIN_SAFE_INTEGER,this._zOrderDirty=!0,this._normalizeZIndices())}else 0!==e&&(this.children.splice(e,1),this.children.unshift(t))}bringForward(t){const e=this.children.indexOf(t);if(-1!==e&&e!==this.children.length-1)if(this.sortByZIndex){const e=[...this.children].sort(((t,e)=>(t.zIndex||0)-(e.zIndex||0))),i=e.indexOf(t);if(i<e.length-1){const s=e[i+1],n=s.zIndex||0,a=t.zIndex||0;n-a>1?t.zIndex=a+Math.floor((n-a)/2):(t.zIndex=n,s.zIndex=a),this._zOrderDirty=!0,this._normalizeZIndices()}}else{const i=this.children[e+1];this.children[e+1]=t,this.children[e]=i}}sendBackward(t){const e=this.children.indexOf(t);if(!(e<=0))if(this.sortByZIndex){const e=[...this.children].sort(((t,e)=>(t.zIndex||0)-(e.zIndex||0))),i=e.indexOf(t);if(i>0){const s=e[i-1],n=s.zIndex||0,a=t.zIndex||0;a-n>1?t.zIndex=n+Math.floor((a-n)/2):(t.zIndex=n,s.zIndex=a),this._zOrderDirty=!0,this._normalizeZIndices()}}else{const i=this.children[e-1];this.children[e-1]=t,this.children[e]=i}}_normalizeZIndices(){if(this.children.length<=1)return;if(this.children.some((t=>(t.zIndex||0)>1e3||(t.zIndex||0)<-1e3))){[...this.children].sort(((t,e)=>(t.zIndex||0)-(e.zIndex||0))).forEach(((t,e)=>{t.zIndex=10*e})),this._zOrderDirty=!0}}getSortedChildren(){return this.sortByZIndex&&this._zOrderDirty&&(this.children.sort(((t,e)=>(t.zIndex||0)-(e.zIndex||0))),this._zOrderDirty=!1),this.children}}const _Position=class t{static calculate(e,i,s,n=10,a=0,r=0){const o=i.width||0,h=i.height||0,l=s.width||0,c=s.height||0,_=s.x||0,u=s.y||0;let d,p,g,f;switch(e){case t.TOP_LEFT:d=_-l/2+n+o/2,p=u-c/2+n+h/2,g="left",f="top";break;case t.TOP_CENTER:d=_,p=u-c/2+n+h/2,g="center",f="top";break;case t.TOP_RIGHT:d=_+l/2-n-o/2,p=u-c/2+n+h/2,g="right",f="top";break;case t.CENTER_LEFT:d=_-l/2+n+o/2,p=u,g="left",f="middle";break;case t.CENTER:d=_,p=u,g="center",f="middle";break;case t.CENTER_RIGHT:d=_+l/2-n-o/2,p=u,g="right",f="middle";break;case t.BOTTOM_LEFT:d=_-l/2+n+o/2,p=u+c/2-n-h/2,g="left",f="bottom";break;case t.BOTTOM_CENTER:d=_,p=u+c/2-n-h/2,g="center",f="bottom";break;case t.BOTTOM_RIGHT:d=_+l/2-n-o/2,p=u+c/2-n-h/2,g="right",f="bottom";break;default:d=_-l/2+n+o/2,p=u-c/2+n+h/2,g="left",f="top"}return d+=a,p+=r,{x:d,y:p,align:g,baseline:f}}static calculateAbsolute(e,i,s,n=10,a=0,r=0){const o={width:s.width,height:s.height,x:s.width/2,y:s.height/2};return t.calculate(e,i,o,n,a,r)}};__publicField(_Position,"TOP_LEFT","top-left"),__publicField(_Position,"TOP_CENTER","top-center"),__publicField(_Position,"TOP_RIGHT","top-right"),__publicField(_Position,"CENTER_LEFT","center-left"),__publicField(_Position,"CENTER","center"),__publicField(_Position,"CENTER_RIGHT","center-right"),__publicField(_Position,"BOTTOM_LEFT","bottom-left"),__publicField(_Position,"BOTTOM_CENTER","bottom-center"),__publicField(_Position,"BOTTOM_RIGHT","bottom-right");let Position=_Position;function applyLayout(t,e,i={}){const s=i.offsetX??0,n=i.offsetY??0,a=i.transform;return t.forEach(((t,i)=>{if(i<e.length){const r=e[i];if(a){const e=a(r);t.x=e.x+s,t.y=e.y+n}else t.x=r.x+s,t.y=r.y+n}})),t}function horizontalLayout(t,e={}){const i=e.spacing??10,s=e.padding??0,n=e.align??"start",a=e.centerItems??!0;let r=s,o=0;const h=[];for(const e of t)o=Math.max(o,e.height??0);for(let e=0;e<t.length;e++){const s=t[e],l=s.width??0,c=s.height??0,_=a?r+l/2:r;let u;switch(n){case"center":u=(o-c)/2;break;case"end":u=o-c;break;default:u=0}h.push({x:_,y:u}),r+=l,e<t.length-1&&(r+=i)}return{positions:h,width:r+s,height:o+2*s}}function verticalLayout(t,e={}){const i=e.spacing??10,s=e.padding??0,n=e.align??"start",a=e.centerItems??!0;let r=s,o=0;const h=[];for(const e of t)o=Math.max(o,e.width??0);for(let e=0;e<t.length;e++){const s=t[e],l=s.width??0,c=s.height??0,_=a?r+c/2:r;let u;switch(n){case"center":u=(o-l)/2;break;case"end":u=o-l;break;default:u=0}h.push({x:u,y:_}),r+=c,e<t.length-1&&(r+=i)}return{positions:h,width:o+2*s,height:r+s}}function tileLayout(t,e={}){if(0===t.length)return{positions:[],width:0,height:0};const i=e.columns??4,s=e.spacing??10,n=e.padding??0,a=e.centerItems??!0,r=t[0].width??0,o=t[0].height??0,h=Math.ceil(t.length/i),l=[],c=i*r+(i-1)*s+2*n,_=h*o+(h-1)*s+2*n;let u=n,d=n,p=0;for(let e=0;e<t.length;e++){const t=a?u+r/2:u,e=a?d+o/2:d;l.push({x:t,y:e}),p++,p<i?u+=r+s:(p=0,u=n,d+=o+s)}return{positions:l,width:c,height:_}}function gridLayout(t,e={}){if(0===t.length)return{positions:[],width:0,height:0};const i=e.columns??4,s=e.spacing??10,n=e.padding??0,a=e.centerItems??!0,r=new Array(i).fill(0),o=[];t.forEach(((t,e)=>{const s=e%i,n=Math.floor(e/i),a=t.width??0,h=t.height??0;r[s]=Math.max(r[s],a),void 0===o[n]?o[n]=h:o[n]=Math.max(o[n],h)}));const h=[];let l=n,c=n,_=0;for(let e=0;e<t.length;e++){const u=t[e],d=u.width??0,p=u.height??0,g=o[Math.floor(e/i)],f=a?l+d/2:l,m=a?c+p/2:c;h.push({x:f,y:m}),_++,_<i?l+=r[_-1]+s:(_=0,l=n,c+=g+s)}return{positions:h,width:2*n+r.reduce(((t,e)=>t+e),0)+s*(i-1),height:2*n+o.reduce(((t,e)=>t+e),0)+s*(o.length-1),cols:i,rows:o.length}}class TaskManager{constructor(t){this.worker=new Worker(t),this.nextTaskId=1,this.pendingTasks=new Map,this.worker.onmessage=this.handleMessage.bind(this)}handleMessage(t){const{taskId:e,status:i,result:s,error:n}=t.data;if(this.pendingTasks.has(e)){const{resolve:t,reject:a}=this.pendingTasks.get(e);"complete"===i?t(s):"error"===i&&a(new Error(n)),this.pendingTasks.delete(e)}}runTask(t,e){return new Promise(((i,s)=>{const n=this.nextTaskId++;this.pendingTasks.set(n,{resolve:i,reject:s}),this.worker.postMessage({taskId:n,taskName:t,params:e})}))}terminate(){this.worker.terminate()}}class Camera3D{constructor(t={}){this.rotationX=t.rotationX??0,this.rotationY=t.rotationY??0,this.rotationZ=t.rotationZ??0,this._initialRotationX=this.rotationX,this._initialRotationY=this.rotationY,this._initialRotationZ=this.rotationZ,this.perspective=t.perspective??800,this.sensitivity=t.sensitivity??.005,this.minRotationX=t.minRotationX??-1.5,this.maxRotationX=t.maxRotationX??1.5,this.clampX=t.clampX??!0,this.autoRotate=t.autoRotate??!1,this.autoRotateSpeed=t.autoRotateSpeed??.5,this.autoRotateAxis=t.autoRotateAxis??"y",this._isDragging=!1,this._lastMouseX=0,this._lastMouseY=0,this._canvas=null,this._boundHandlers=null}project(t,e,i){if(0!==this.rotationZ){const i=Math.cos(this.rotationZ),s=Math.sin(this.rotationZ),n=t;t=n*i-e*s,e=n*s+e*i}const s=Math.cos(this.rotationY),n=Math.sin(this.rotationY),a=t*s-i*n,r=t*n+i*s,o=Math.cos(this.rotationX),h=Math.sin(this.rotationX),l=e*o-r*h,c=e*h+r*o,_=this.perspective/(this.perspective+c);return{x:a*_,y:l*_,z:c,scale:_}}projectAll(t){return t.map((t=>this.project(t.x,t.y,t.z)))}update(t){if(this.autoRotate&&!this._isDragging){const e=this.autoRotateSpeed*t;switch(this.autoRotateAxis){case"x":this.rotationX+=e;break;case"y":this.rotationY+=e;break;case"z":this.rotationZ+=e}}}enableMouseControl(t,e={}){this._canvas&&this.disableMouseControl(),this._canvas=t;const i=e.invertX?-1:1,s=e.invertY?-1:1;return this._boundHandlers={mousedown:t=>{this._isDragging=!0,this._lastMouseX=t.clientX,this._lastMouseY=t.clientY},mousemove:t=>{if(!this._isDragging)return;const e=t.clientX-this._lastMouseX,n=t.clientY-this._lastMouseY;this.rotationY+=e*this.sensitivity*i,this.rotationX+=n*this.sensitivity*s,this.clampX&&(this.rotationX=Math.max(this.minRotationX,Math.min(this.maxRotationX,this.rotationX))),this._lastMouseX=t.clientX,this._lastMouseY=t.clientY},mouseup:()=>{this._isDragging=!1},mouseleave:()=>{this._isDragging=!1},touchstart:t=>{1===t.touches.length&&(this._isDragging=!0,this._lastMouseX=t.touches[0].clientX,this._lastMouseY=t.touches[0].clientY)},touchmove:t=>{if(!this._isDragging||1!==t.touches.length)return;t.preventDefault();const e=t.touches[0].clientX-this._lastMouseX,n=t.touches[0].clientY-this._lastMouseY;this.rotationY+=e*this.sensitivity*i,this.rotationX+=n*this.sensitivity*s,this.clampX&&(this.rotationX=Math.max(this.minRotationX,Math.min(this.maxRotationX,this.rotationX))),this._lastMouseX=t.touches[0].clientX,this._lastMouseY=t.touches[0].clientY},touchend:()=>{this._isDragging=!1},dblclick:()=>{this.reset()}},t.addEventListener("mousedown",this._boundHandlers.mousedown),t.addEventListener("mousemove",this._boundHandlers.mousemove),t.addEventListener("mouseup",this._boundHandlers.mouseup),t.addEventListener("mouseleave",this._boundHandlers.mouseleave),t.addEventListener("touchstart",this._boundHandlers.touchstart),t.addEventListener("touchmove",this._boundHandlers.touchmove,{passive:!1}),t.addEventListener("touchend",this._boundHandlers.touchend),t.addEventListener("dblclick",this._boundHandlers.dblclick),this}disableMouseControl(){return this._canvas&&this._boundHandlers&&(this._canvas.removeEventListener("mousedown",this._boundHandlers.mousedown),this._canvas.removeEventListener("mousemove",this._boundHandlers.mousemove),this._canvas.removeEventListener("mouseup",this._boundHandlers.mouseup),this._canvas.removeEventListener("mouseleave",this._boundHandlers.mouseleave),this._canvas.removeEventListener("touchstart",this._boundHandlers.touchstart),this._canvas.removeEventListener("touchmove",this._boundHandlers.touchmove),this._canvas.removeEventListener("touchend",this._boundHandlers.touchend),this._canvas.removeEventListener("dblclick",this._boundHandlers.dblclick)),this._canvas=null,this._boundHandlers=null,this}reset(){return this.rotationX=this._initialRotationX,this.rotationY=this._initialRotationY,this.rotationZ=this._initialRotationZ,this}setRotation(t,e,i=0){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i=0){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this.clampX&&(this.rotationX=Math.max(this.minRotationX,Math.min(this.maxRotationX,this.rotationX))),this}isDragging(){return this._isDragging}lookAt(t,e,i){return this.rotationY=Math.atan2(t,i),this.rotationX=Math.atan2(e,Math.sqrt(t*t+i*i)),this}}class Random{static symmetric(t,e,i,s,n=1,a="topleft"){const r="centered"===a?e:e+s/2;return{x:("centered"===a?t:t+i/2)+(Math.random()-.5)*i*n,y:r+(Math.random()-.5)*s*n}}static pointInBox(t,e,i,s,n="topleft"){return"centered"===n?{x:t+(Math.random()-.5)*i,y:e+(Math.random()-.5)*s}:{x:t+Math.random()*i,y:e+Math.random()*s}}static centered(t,e,i,s,n=50,a="topleft"){const r="centered"===a?e:e+s/2;return{x:("centered"===a?t:t+i/2)+2*(Math.random()-.5)*n,y:r+2*(Math.random()-.5)*n}}static gaussian(t,e,i,s,n=40,a="topleft"){const r="centered"===a?e:e+s/2;return{x:("centered"===a?t:t+i/2)+Random._gaussian(0,n),y:r+Random._gaussian(0,n)}}static radial(t,e,i,s,n=100,a="topleft"){const r="centered"===a?t:t+i/2,o="centered"===a?e:e+s/2,h=Math.random()*Math.PI*2,l=Math.random()*n;return{x:r+Math.cos(h)*l,y:o+Math.sin(h)*l}}static pick(t){return t[Math.floor(Math.random()*t.length)]}static pickOther(t,e){const i=t.filter((t=>t!==e));if(0!==i.length)return Random.pick(i)}static float(t,e){return t+Math.random()*(e-t)}static int(t,e){return Math.floor(Random.float(t,e+1))}static chance(t=.5){return Math.random()<t}static coin(){return Math.random()<.5}static _gaussian(t=0,e=1){let i=1-Math.random(),s=1-Math.random();return t+e*Math.sqrt(-2*Math.log(i))*Math.cos(2*Math.PI*s)}}class Complex{constructor(t,e=0){this.real=t,this.imag=e}static fromPolar(t,e){return new Complex(t*Math.cos(e),t*Math.sin(e))}add(t){return new Complex(this.real+t.real,this.imag+t.imag)}subtract(t){return new Complex(this.real-t.real,this.imag-t.imag)}multiply(t){return new Complex(this.real*t.real-this.imag*t.imag,this.real*t.imag+this.imag*t.real)}divide(t){return new Complex(this.real/t,this.imag/t)}scale(t){return new Complex(this.real*t,this.imag*t)}abs(){return Math.sqrt(this.real*this.real+this.imag*this.imag)}}class Fractals{static applyColorScheme(t,e,i,s,n,a){const r=(null==e?void 0:e.data)||[];for(let e=0;e<t.length;e++){const o=t[e],h=4*e;switch(i){case"futuristic":{const i=t[e]/10,s={r:0,g:5,b:10},n={r:0,g:30,b:20};if(i>.7){const t=3.33*(i-.7);r[h]=Math.floor(s.r*(1-t)+n.r*t),r[h+1]=Math.floor(s.g*(1-t)+n.g*t),r[h+2]=Math.floor(s.b*(1-t)+n.b*t)}else{const t=1.43*i;r[h]=Math.floor(s.r*t),r[h+1]=Math.floor(s.g*t),r[h+2]=Math.floor(s.b*t)}r[h+3]=255}break;case"rainbow":if(0===o)r[h]=0,r[h+1]=0,r[h+2]=0,r[h+3]=255;else{const t=(10*o+n)%360,[e,i,s]=a(t,.8,.5);r[h]=e,r[h+1]=i,r[h+2]=s,r[h+3]=255}break;case"grayscale":{const t=0===o?0:255-255*o/s;r[h]=t,r[h+1]=t,r[h+2]=t,r[h+3]=255}break;case"binary":0!==o?(r[h]=0,r[h+1]=0,r[h+2]=0):(r[h]=255,r[h+1]=255,r[h+2]=255),r[h+3]=255;break;case"fire":if(0==o)r[h]=0,r[h+1]=0,r[h+2]=0;else{const t=o/s;if(t<.3){const e=t/.3;r[h]=Math.floor(255*e),r[h+1]=0,r[h+2]=0}else if(t<.6){const e=(t-.3)/.3;r[h]=255,r[h+1]=Math.floor(165*e),r[h+2]=0}else if(t<.9){const e=(t-.6)/.3;r[h]=255,r[h+1]=165+Math.floor(90*e),r[h+2]=Math.floor(255*e)}else r[h]=255,r[h+1]=255,r[h+2]=255}r[h+3]=255;break;case"ocean":if(0===o)r[h]=0,r[h+1]=20,r[h+2]=50;else{const t=o/s;r[h]=Math.floor(10+50*t),r[h+1]=Math.floor(50+150*t),r[h+2]=Math.floor(100+155*t)}r[h+3]=255;break;case"electric":if(0===o)r[h]=0,r[h+1]=0,r[h+2]=0;else{const t=(o+n)%3,e=o%20/20;0===t?(r[h]=Math.floor(255*(.5+.5*Math.sin(e*Math.PI*2))),r[h+1]=Math.floor(128*e),r[h+2]=Math.floor(255*e)):1===t?(r[h]=Math.floor(255*e),r[h+1]=Math.floor(255*(.5+.5*Math.sin(e*Math.PI*2))),r[h+2]=Math.floor(128*e)):(r[h]=Math.floor(128*e),r[h+1]=Math.floor(255*e),r[h+2]=Math.floor(255*(.5+.5*Math.sin(e*Math.PI*2))))}r[h+3]=255;break;case"topographic":if(0===o)r[h]=5,r[h+1]=15,r[h+2]=30;else{const t=o/s;if(t<.1){const e=t/.1;r[h]=Math.floor(5+20*e),r[h+1]=Math.floor(15+40*e),r[h+2]=Math.floor(30+50*e)}else if(t<.3){const e=(t-.1)/.2;r[h]=Math.floor(210+45*e),r[h+1]=Math.floor(180+40*e),r[h+2]=Math.floor(140+30*e)}else if(t<.7){const e=(t-.3)/.4;r[h]=Math.floor(50*(1-e)),r[h+1]=Math.floor(100+80*e),r[h+2]=Math.floor(50*(1-e))}else{const e=(t-.7)/.3;r[h]=Math.floor(150+105*e),r[h+1]=Math.floor(150+105*e),r[h+2]=Math.floor(150+105*e)}}r[h+3]=255;break;default:if(0===o)r[h]=0,r[h+1]=0,r[h+2]=0;else{const t=(o+n)%64;t<16?(r[h]=16*t,r[h+1]=0,r[h+2]=0):t<32?(r[h]=255,r[h+1]=16*(t-16),r[h+2]=0):t<48?(r[h]=255-16*(t-32),r[h+1]=255,r[h+2]=0):(r[h]=0,r[h+1]=255-16*(t-48),r[h+2]=16*(t-48))}r[h+3]=255}}return null!=e?e:r}static pythagorasTree(t,e,i=10,s=-2,n=2,a=-.5,r=3.5){const o=new Uint8Array(t*e),h=e=>Math.floor((e-s)*t/(n-s)),l=t=>Math.floor((t-a)*e/(r-a)),c=(i,s,n,a)=>{const r=h(i),c=l(s),_=h(n),u=l(a);let d=r,p=c;const g=Math.abs(_-r),f=Math.abs(u-c),m=r<_?1:-1,v=c<u?1:-1;let y=g-f;for(;d>=0&&d<t&&p>=0&&p<e&&(o[p*t+d]=255),d!==_||p!==u;){const t=2*y;t>-f&&(y-=f,d+=m),t<g&&(y+=g,p+=v)}},_=(t,e,i,s,n)=>{if(n<=0)return;const a=i-t,r=s-e,o=i+r,h=s-a,l=t+r,u=e-a;((t,e,i,s,n,a,r,o)=>{c(t,e,i,s),c(i,s,n,a),c(n,a,r,o),c(r,o,t,e)})(t,e,i,s,o,h,l,u);const d=Math.PI/4,p=.7*Math.sqrt(a*a+r*r),g=p*Math.cos(Math.atan2(r,a)-d),f=p*Math.sin(Math.atan2(r,a)-d),m=.7*Math.sqrt(a*a+r*r),v=l,y=u,x=v+m*Math.cos(Math.atan2(r,a)+d),w=y+m*Math.sin(Math.atan2(r,a)+d);_(o,h,o+g,h+f,n-1),_(v,y,x,w,n-1)},u=Math.min(i,12);return _(-.5,0,.5,0,u),o}static mandelbrot(t,e,i=100,s=-2.5,n=1,a=-1.5,r=1.5){const o=new Uint8Array(t*e),h=(n-s)/t,l=(r-a)/e;for(let n=0;n<e;n++){const e=n*t,r=a+n*l;for(let n=0;n<t;n++){const t=s+n*h;let a=0,l=0,c=0,_=0,u=0;do{l=2*a*l+r,a=c-_+t,c=a*a,_=l*l,u++}while(c+_<4&&u<i);o[e+n]=u<i?u%256:0}}return o}static julia(t,e,i=100,s=-.7,n=.27,a=1,r=0,o=0){const h=new Uint8Array(t*e),l=2/a,c=-l+r,_=-l+o,u=(l+r-c)/t,d=(l+o-_)/e;for(let a=0;a<e;a++){const e=a*t,r=_+a*d;for(let a=0;a<t;a++){let t=c+a*u,o=r,l=0,_=0,d=0;do{l=t*t,_=o*o;o=2*t*o+n,t=l-_+s,d++}while(l+_<4&&d<i);h[e+a]=d<i?d%256:0}}return h}static tricorn(t,e,i=100,s=-2.5,n=1.5,a=-1.5,r=1.5){const o=new Uint8Array(t*e),h=(n-s)/t,l=(r-a)/e;for(let n=0;n<e;n++){const e=n*t,r=a+n*l;for(let n=0;n<t;n++){const t=s+n*h;let a=0,l=0,c=0,_=0,u=0;do{l=-2*a*l+r,a=c-_+t,c=a*a,_=l*l,u++}while(c+_<4&&u<i);o[e+n]=u<i?u%256:0}}return o}static phoenix(t,e,i=100,s=.5,n=.5,a=-2,r=2,o=-2,h=2){const l=new Uint8Array(t*e),c=(r-a)/t,_=(h-o)/e;for(let r=0;r<e;r++){const e=r*t,h=o+r*_;for(let r=0;r<t;r++){const t=a+r*c;let o=0,_=0,u=0,d=0,p=0,g=0,f=0;do{const e=p-g+t+s*u+n,i=2*o*_+h+s*d;u=o,d=_,o=e,_=i,p=o*o,g=_*_,f++}while(p+g<4&&f<i);l[e+r]=f<i?f%256:0}}return l}static newton(t,e,i=100,s=1e-6,n=-2,a=2,r=-2,o=2){const h=new Uint8Array(t*e),l=s*s,c=a-n,_=o-r,u=new Float64Array(3),d=new Float64Array(3);for(let t=0;t<3;t++){const e=2*Math.PI*t/3;u[t]=Math.cos(e),d[t]=Math.sin(e)}const p=c/t,g=_/e;for(let s=0;s<e;s++){const e=s*t,a=r+s*g;for(let s=0;s<t;s++){let t=n+s*p,r=a,o=0,c=-1;for(;o<i&&c<0;){const e=t*t-r*r,i=2*t*r,s=e*t-i*r-1,n=e*r+i*t,a=3*e,h=3*i,_=a*a+h*h;if(_<l)break;const p=1/_,g=t-(s*a+n*h)*p,f=r-(n*a-s*h)*p;for(let t=0;t<3;t++){const e=g-u[t],i=f-d[t];if(e*e+i*i<l){c=t;break}}t=g,r=f,o++}if(c>=0){const t=1-Math.min(o/i,1),n=85*c;h[e+s]=Math.floor(n+85*t)}else h[e+s]=0}}return h}static sierpinski(t,e,i=6,s=0,n=1,a=0,r=1){const o=new Uint8Array(t*e).fill(1),h=Math.sqrt(3)/2,l=n-s,c=(r-a)/l;if(Math.abs(c-h)>1e-9){const t=(a+r)/2,e=l*h;a=t-e/2,r=t+e/2}const _=(1<<Math.min(i,32))-1,u=(n-s)/t,d=(r-a)/e,p=2/Math.sqrt(3);for(let i=0;i<e;++i){const e=a+i*d,n=Math.floor(e*p),r=.5*n;for(let e=0;e<t;++e){const a=s+e*u;Math.floor(a-r)&n&_&&(o[i*t+e]=0)}}return o}static sierpinskiCarpet(t,e,i=5,s=0,n=1,a=0,r=1){const o=new Uint8Array(t*e).fill(1),h=n-s,l=r-a,c=Math.max(h,l),_=(s+n)/2,u=(a+r)/2;s=_-c/2,n=_+c/2,a=u-c/2,r=u+c/2;const d=Math.pow(3,i),p=(t,e)=>{let i=t,s=e;for(;i>0||s>0;){if(i%3==1&&s%3==1)return!0;i=Math.floor(i/3),s=Math.floor(s/3)}return!1};for(let i=0;i<e;++i){const h=(a+i/e*(r-a))*d,l=(Math.floor(h)%d+d)%d;for(let e=0;e<t;++e){const a=(s+e/t*(n-s))*d;p((Math.floor(a)%d+d)%d,l)&&(o[i*t+e]=0)}}return o}static barnsleyFern(t,e,i=1e5){const s=new Uint8Array(t*e).fill(0);let n=0,a=0;const r=Math.min(t,e)/10,o=t/2;for(let h=0;h<i;h++){const i=Math.random();let h,l;i<.01?(h=0,l=.16*a):i<.86?(h=.85*n+.04*a,l=-.04*n+.85*a+1.6):i<.93?(h=.2*n-.26*a,l=.23*n+.22*a+1.6):(h=-.15*n+.28*a,l=.26*n+.24*a+.44),n=h,a=l;const c=Math.floor(n*r+o),_=Math.floor(e-a*r);if(c>=0&&c<t&&_>=0&&_<e){const e=_*t+c;s[e]<255&&s[e]++}}return s}static lyapunov(t,e,i=1e3,s="AB",n=3.4,a=4,r=3.4,o=4){console.time("lyapunov");const h=(s=s.toUpperCase().replace(/[^AB]/g,"")||"AB").length,l=new Float32Array(t*e);let c=1/0,_=-1/0;for(let u=0;u<e;u++){const d=r+(o-r)*u/e;for(let e=0;e<t;e++){const r=n+(a-n)*e/t;let o=.5;for(let t=0;t<100;t++){o=("A"===s[t%h]?r:d)*o*(1-o)}let p=0,g=0;for(;g<i;){const t="A"===s[g%h]?r:d;o=t*o*(1-o);const e=Math.abs(t*(1-2*o));if(p+=Math.log(Math.max(e,1e-10)),g++,Math.abs(p/g)>10)break}const f=p/g;l[u*t+e]=f,f>-10&&f<10&&(f<c&&(c=f),f>_&&(_=f))}}c===_&&(c-=1,_+=1);const u=_-c,d=new Uint8Array(t*e);for(let t=0;t<l.length;t++){let e=l[t];e=Math.max(-10,Math.min(10,e));let i=(e-c)/u;d[t]=Math.floor(255*i)}return console.timeEnd("lyapunov"),d}static koch(t,e,i=4,s=-2,n=2,a=-2,r=2){const o=new Uint8Array(t*e),h=e=>Math.floor((e-s)*t/(n-s)),l=t=>Math.floor((t-a)*e/(r-a)),c=(i,s,n,a,r)=>{if(r<=0)return void((i,s,n,a)=>{const r=h(i),c=l(s),_=h(n),u=l(a);let d=r,p=c;const g=Math.abs(_-r),f=Math.abs(u-c),m=r<_?1:-1,v=c<u?1:-1;let y=g-f;for(;d>=0&&d<t&&p>=0&&p<e&&(o[p*t+d]=255),d!==_||p!==u;){const t=2*y;t>-f&&(y-=f,d+=m),t<g&&(y+=g,p+=v)}})(i,s,n,a);const _=(n-i)/3,u=(a-s)/3,d=i+_,p=s+u,g=i+2*_,f=s+2*u,m=Math.PI/3,v=d+_*Math.cos(m)-u*Math.sin(m),y=p+_*Math.sin(m)+u*Math.cos(m);c(i,s,d,p,r-1),c(d,p,v,y,r-1),c(v,y,g,f,r-1),c(g,f,n,a,r-1)},_=Math.min(i,10),u=3*Math.sqrt(3)/2,d=[0,-u/2+.5],p=[-1.5,u/2+.5],g=[1.5,u/2+.5];return c(d[0],d[1],p[0],p[1],_),c(p[0],p[1],g[0],g[1],_),c(g[0],g[1],d[0],d[1],_),o}}__publicField(Fractals,"types",{MANDELBROT:"mandelbrot",TRICORN:"tricorn",PHOENIX:"phoenix",JULIA:"julia",SIERPINSKI:"sierpinski",SCARPET:"sierpinskiCarpet",BARNSEY_FERN:"barnsleyFern",KOCH:"koch",PYTHAGORAS_TREE:"pythagorasTree",NEWTON:"newton",LYAPUNOV:"lyapunov"}),__publicField(Fractals,"colors",{FUTURISTIC:"futuristic",RAINBOW:"rainbow",GRAYSCALE:"grayscale",TOPOGRAPHIC:"topographic",FIRE:"fire",OCEAN:"ocean",ELECTRIC:"electric",BINARY:"binary",HISTORIC:"historic"});const _Noise=class{static seed(t){t>0&&t<1&&(t*=65536),(t=Math.floor(t))<256&&(t|=t<<8);for(let e=0;e<256;e++){let i;i=1&e?__privateGet(this,_p)[e]^255&t:__privateGet(this,_p)[e]^t>>8&255,__privateGet(this,_perm)[e]=__privateGet(this,_perm)[e+256]=i,__privateGet(this,_gradP)[e]=__privateGet(this,_gradP)[e+256]=__privateGet(this,_grad3)[i%12]}}static simplex2(t,e){let i,s,n;const a=(t+e)*__privateGet(this,_F2),r=Math.floor(t+a),o=Math.floor(e+a),h=(r+o)*__privateGet(this,_G2),l=t-r+h,c=e-o+h;let _,u;l>c?(_=1,u=0):(_=0,u=1);const d=l-_+__privateGet(this,_G2),p=c-u+__privateGet(this,_G2),g=l-1+2*__privateGet(this,_G2),f=c-1+2*__privateGet(this,_G2),m=255&r,v=255&o,y=__privateGet(this,_gradP)[m+__privateGet(this,_perm)[v]],x=__privateGet(this,_gradP)[m+_+__privateGet(this,_perm)[v+u]],w=__privateGet(this,_gradP)[m+1+__privateGet(this,_perm)[v+1]];let M=.5-l*l-c*c;M<0?i=0:(M*=M,i=M*M*y.dot2(l,c));let b=.5-d*d-p*p;b<0?s=0:(b*=b,s=b*b*x.dot2(d,p));let P=.5-g*g-f*f;return P<0?n=0:(P*=P,n=P*P*w.dot2(g,f)),70*(i+s+n)}static simplex3(t,e,i){let s,n,a,r;const o=(t+e+i)*__privateGet(this,_F3),h=Math.floor(t+o),l=Math.floor(e+o),c=Math.floor(i+o),_=(h+l+c)*__privateGet(this,_G3),u=t-h+_,d=e-l+_,p=i-c+_;let g,f,m,v,y,x;u>=d?d>=p?(g=1,f=0,m=0,v=1,y=1,x=0):u>=p?(g=1,f=0,m=0,v=1,y=0,x=1):(g=0,f=0,m=1,v=1,y=0,x=1):d<p?(g=0,f=0,m=1,v=0,y=1,x=1):u<p?(g=0,f=1,m=0,v=0,y=1,x=1):(g=0,f=1,m=0,v=1,y=1,x=0);const w=u-g+__privateGet(this,_G3),M=d-f+__privateGet(this,_G3),b=p-m+__privateGet(this,_G3),P=u-v+2*__privateGet(this,_G3),G=d-y+2*__privateGet(this,_G3),S=p-x+2*__privateGet(this,_G3),k=u-1+3*__privateGet(this,_G3),T=d-1+3*__privateGet(this,_G3),C=p-1+3*__privateGet(this,_G3),I=255&h,A=255&l,O=255&c,F=__privateGet(this,_gradP)[I+__privateGet(this,_perm)[A+__privateGet(this,_perm)[O]]],B=__privateGet(this,_gradP)[I+g+__privateGet(this,_perm)[A+f+__privateGet(this,_perm)[O+m]]],z=__privateGet(this,_gradP)[I+v+__privateGet(this,_perm)[A+y+__privateGet(this,_perm)[O+x]]],D=__privateGet(this,_gradP)[I+1+__privateGet(this,_perm)[A+1+__privateGet(this,_perm)[O+1]]];let E=.6-u*u-d*d-p*p;E<0?s=0:(E*=E,s=E*E*F.dot3(u,d,p));let R=.6-w*w-M*M-b*b;R<0?n=0:(R*=R,n=R*R*B.dot3(w,M,b));let L=.6-P*P-G*G-S*S;L<0?a=0:(L*=L,a=L*L*z.dot3(P,G,S));let W=.6-k*k-T*T-C*C;return W<0?r=0:(W*=W,r=W*W*D.dot3(k,T,C)),32*(s+n+a+r)}static perlin2(t,e){const i=Math.floor(t),s=Math.floor(e);t-=i,e-=s;const n=255&i,a=255&s,r=__privateGet(this,_gradP)[n+__privateGet(this,_perm)[a]].dot2(t,e),o=__privateGet(this,_gradP)[n+__privateGet(this,_perm)[a+1]].dot2(t,e-1),h=__privateGet(this,_gradP)[n+1+__privateGet(this,_perm)[a]].dot2(t-1,e),l=__privateGet(this,_gradP)[n+1+__privateGet(this,_perm)[a+1]].dot2(t-1,e-1),c=__privateMethod(this,_Noise_static,fade_fn).call(this,t);return __privateMethod(this,_Noise_static,lerp_fn).call(this,__privateMethod(this,_Noise_static,lerp_fn).call(this,r,h,c),__privateMethod(this,_Noise_static,lerp_fn).call(this,o,l,c),__privateMethod(this,_Noise_static,fade_fn).call(this,e))}static perlin3(t,e,i){const s=Math.floor(t),n=Math.floor(e),a=Math.floor(i);t-=s,e-=n,i-=a;const r=255&s,o=255&n,h=255&a,l=__privateGet(this,_gradP)[r+__privateGet(this,_perm)[o+__privateGet(this,_perm)[h]]].dot3(t,e,i),c=__privateGet(this,_gradP)[r+__privateGet(this,_perm)[o+__privateGet(this,_perm)[h+1]]].dot3(t,e,i-1),_=__privateGet(this,_gradP)[r+__privateGet(this,_perm)[o+1+__privateGet(this,_perm)[h]]].dot3(t,e-1,i),u=__privateGet(this,_gradP)[r+__privateGet(this,_perm)[o+1+__privateGet(this,_perm)[h+1]]].dot3(t,e-1,i-1),d=__privateGet(this,_gradP)[r+1+__privateGet(this,_perm)[o+__privateGet(this,_perm)[h]]].dot3(t-1,e,i),p=__privateGet(this,_gradP)[r+1+__privateGet(this,_perm)[o+__privateGet(this,_perm)[h+1]]].dot3(t-1,e,i-1),g=__privateGet(this,_gradP)[r+1+__privateGet(this,_perm)[o+1+__privateGet(this,_perm)[h]]].dot3(t-1,e-1,i),f=__privateGet(this,_gradP)[r+1+__privateGet(this,_perm)[o+1+__privateGet(this,_perm)[h+1]]].dot3(t-1,e-1,i-1),m=__privateMethod(this,_Noise_static,fade_fn).call(this,t),v=__privateMethod(this,_Noise_static,fade_fn).call(this,e),y=__privateMethod(this,_Noise_static,fade_fn).call(this,i);return __privateMethod(this,_Noise_static,lerp_fn).call(this,__privateMethod(this,_Noise_static,lerp_fn).call(this,__privateMethod(this,_Noise_static,lerp_fn).call(this,l,d,m),__privateMethod(this,_Noise_static,lerp_fn).call(this,c,p,m),y),__privateMethod(this,_Noise_static,lerp_fn).call(this,__privateMethod(this,_Noise_static,lerp_fn).call(this,_,g,m),__privateMethod(this,_Noise_static,lerp_fn).call(this,u,f,m),y),v)}};_Grad=new WeakMap,_grad3=new WeakMap,_p=new WeakMap,_perm=new WeakMap,_gradP=new WeakMap,_F2=new WeakMap,_G2=new WeakMap,_F3=new WeakMap,_G3=new WeakMap,_Noise_static=new WeakSet,fade_fn=function(t){return t*t*t*(t*(6*t-15)+10)},lerp_fn=function(t,e,i){return(1-i)*t+i*e},__privateAdd(_Noise,_Noise_static),__privateAdd(_Noise,_Grad,class{constructor(t,e,i){this.x=t,this.y=e,this.z=i}dot2(t,e){return this.x*t+this.y*e}dot3(t,e,i){return this.x*t+this.y*e+this.z*i}}),__privateAdd(_Noise,_grad3,[new(__privateGet(_Noise,_Grad))(1,1,0),new(__privateGet(_Noise,_Grad))(-1,1,0),new(__privateGet(_Noise,_Grad))(1,-1,0),new(__privateGet(_Noise,_Grad))(-1,-1,0),new(__privateGet(_Noise,_Grad))(1,0,1),new(__privateGet(_Noise,_Grad))(-1,0,1),new(__privateGet(_Noise,_Grad))(1,0,-1),new(__privateGet(_Noise,_Grad))(-1,0,-1),new(__privateGet(_Noise,_Grad))(0,1,1),new(__privateGet(_Noise,_Grad))(0,-1,1),new(__privateGet(_Noise,_Grad))(0,1,-1),new(__privateGet(_Noise,_Grad))(0,-1,-1)]),__privateAdd(_Noise,_p,[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]),__privateAdd(_Noise,_perm,new Array(512)),__privateAdd(_Noise,_gradP,new Array(512)),__privateAdd(_Noise,_F2,.5*(Math.sqrt(3)-1)),__privateAdd(_Noise,_G2,(3-Math.sqrt(3))/6),__privateAdd(_Noise,_F3,1/3),__privateAdd(_Noise,_G3,1/6),_Noise.seed(0);let Noise=_Noise;function generatePenroseTilingPixels(t=800,e=800,i){const{divisions:s=5,zoomType:n="in",color1:a=[255,0,0,255],color2:r=[0,0,255,255],color3:o=[0,0,0,255],backgroundColor:h=[255,255,255,255]}=i||{},l=new Uint8ClampedArray(t*e*4);for(let t=0;t<l.length;t+=4)l[t]=h[0],l[t+1]=h[1],l[t+2]=h[2],l[t+3]=h[3]||255;const c="in"===n?1:2,_=Math.max(t,e),u=_/c,d=_/c,p=.5*c,g=.5*c,f=(Math.sqrt(5)+1)/2;let m=[];for(let t=0;t<10;t++){const e=Complex.fromPolar(1,(2*t-1)*Math.PI/10),i=Complex.fromPolar(1,(2*t+1)*Math.PI/10);t%2==0?m.push(["thin",new Complex(0),i,e]):m.push(["thin",new Complex(0),e,i])}for(let t=0;t<s;t++){const t=[];for(const[e,i,s,n]of m)if("thin"===e){const e=i.add(s.subtract(i).scale(1/f));t.push(["thin",n,e,s]),t.push(["thicc",e,n,i])}else{const e=s.add(i.subtract(s).scale(1/f)),a=s.add(n.subtract(s).scale(1/f));t.push(["thicc",a,n,i]),t.push(["thicc",e,a,s]),t.push(["thin",a,e,i])}m=t}function v(i){return{x:Math.floor((i.real*u+p*u)*t/_),y:Math.floor((i.imag*d+g*d)*e/_)}}for(const[i,s,n,o]of m){fillTriangle(l,v(s),v(n),v(o),"thin"===i?a:r,t,e)}if(o&&o[3]>0)for(const[i,s,n,a]of m){const i=v(s),r=v(n),h=v(a);drawLine(l,i,r,o,t,e),drawLine(l,r,h,o,t,e),drawLine(l,h,i,o,t,e)}return l}function fillTriangle(t,e,i,s,n,a,r){e.y>i.y&&([e,i]=[i,e]),e.y>s.y&&([e,s]=[s,e]),i.y>s.y&&([i,s]=[s,i]);const o=n[0],h=n[1],l=n[2],c=n[3]||255;if(i.y===s.y)fillFlatBottomTriangle(t,e,i,s,o,h,l,c,a,r);else if(e.y===i.y)fillFlatTopTriangle(t,e,i,s,o,h,l,c,a,r);else{const n={x:Math.floor(e.x+(i.y-e.y)/(s.y-e.y)*(s.x-e.x)),y:i.y};fillFlatBottomTriangle(t,e,i,n,o,h,l,c,a,r),fillFlatTopTriangle(t,i,n,s,o,h,l,c,a,r)}}function fillFlatBottomTriangle(t,e,i,s,n,a,r,o,h,l){const c=(i.x-e.x)/(i.y-e.y||1),_=(s.x-e.x)/(s.y-e.y||1);let u=e.x,d=e.x;for(let s=e.y;s<=i.y;s++){if(s>=0&&s<l){const e=Math.max(0,Math.min(Math.floor(u),h-1)),i=Math.max(0,Math.min(Math.floor(d),h-1));for(let l=Math.min(e,i);l<=Math.max(e,i);l++){const e=4*(s*h+l);e>=0&&e<t.length-3&&(t[e]=n,t[e+1]=a,t[e+2]=r,t[e+3]=o)}}u+=c,d+=_}}function fillFlatTopTriangle(t,e,i,s,n,a,r,o,h,l){const c=(s.x-e.x)/(s.y-e.y||1),_=(s.x-i.x)/(s.y-i.y||1);let u=s.x,d=s.x;for(let i=s.y;i>e.y;i--)if(i>=0&&i<l){u-=c,d-=_;const e=Math.max(0,Math.min(Math.floor(u),h-1)),s=Math.max(0,Math.min(Math.floor(d),h-1));for(let l=Math.min(e,s);l<=Math.max(e,s);l++){const e=4*(i*h+l);e>=0&&e<t.length-3&&(t[e]=n,t[e+1]=a,t[e+2]=r,t[e+3]=o)}}}function drawLine(t,e,i,s,n,a){const r=s[0],o=s[1],h=s[2],l=s[3]||255;let c=e.x,_=e.y,u=i.x,d=i.y;const p=Math.abs(u-c),g=Math.abs(d-_),f=c<u?1:-1,m=_<d?1:-1;let v=p-g;for(;;){if(c>=0&&c<n&&_>=0&&_<a){const e=4*(_*n+c);if(e>=0&&e<t.length-3){const i=l/255;t[e]=Math.round(t[e]*(1-i)+r*i),t[e+1]=Math.round(t[e+1]*(1-i)+o*i),t[e+2]=Math.round(t[e+2]*(1-i)+h*i),t[e+3]=255}}if(c===u&&_===d)break;const e=2*v;e>-g&&(v-=g,c+=f),e<p&&(v+=p,_+=m)}}class Patterns{static void(t,e,i={}){const{background:s=[255,255,255,255],foreground:n=[0,0,200,255]}=i,a=new Uint8ClampedArray(t*e*4);for(let t=0;t<a.length;t+=4)a[t]=s[0],a[t+1]=s[1],a[t+2]=s[2],a[t+3]=s[3];return a}static solidGrid(t,e,i={}){const{spacing:s=8,background:n=[0,0,0,0],foreground:a=[128,128,128,255]}=i,r=new Uint8ClampedArray(t*e*4);for(let i=0;i<e;i++){const e=i%s==0;for(let o=0;o<t;o++){const h=4*(i*t+o),l=o%s==0||e?a:n;r[h]=l[0],r[h+1]=l[1],r[h+2]=l[2],r[h+3]=l[3]}}return r}static checkerboard(t,e,i={}){const{cellSize:s=8,color1:n=[0,0,0,255],color2:a=[255,255,255,255]}=i,r=new Uint8ClampedArray(t*e*4);for(let i=0;i<e;i++){const e=Math.floor(i/s);for(let o=0;o<t;o++){const h=(Math.floor(o/s)+e)%2==0?n:a,l=4*(i*t+o);r.set(h,l)}}return r}static stripes(t,e,i={}){const{spacing:s=4,thickness:n=1,background:a=[0,0,0,0],foreground:r=[255,255,0,255]}=i,o=new Uint8ClampedArray(t*e*4);for(let i=0;i<e;i++)for(let e=0;e<t;e++){const h=(e+i)%s<n,l=4*(i*t+e);o.set(h?r:a,l)}return o}static honeycomb(t,e,i={}){const{radius:s=10,lineWidth:n=1,foreground:a=[255,255,255,255],background:r=[0,0,0,255]}=i,o=new Uint8ClampedArray(t*e*4);for(let t=0;t<o.length;t+=4)o[t]=r[0],o[t+1]=r[1],o[t+2]=r[2],o[t+3]=r[3];const h=Math.floor(t/2),l=Math.floor(e/2),c=(t,e,i,s,n)=>{const a=Math.abs(t-i),r=Math.abs(e-s),o=n*Math.sqrt(3)/2;return!(r>o)&&(!(a>n)&&n*o*2>=n*r*2+o*a)},_=s-n,u=s*Math.sqrt(3),d=Math.max(0,Math.floor(h-s-1)),p=Math.min(t-1,Math.ceil(h+s+1)),g=Math.max(0,Math.floor(l-u/2-1)),f=Math.min(e-1,Math.ceil(l+u/2+1));for(let e=g;e<=f;e++)for(let i=d;i<=p;i++){const n=c(i,e,h,l,s),r=_>0&&c(i,e,h,l,_);if(n&&!r){const s=4*(e*t+i);o[s]=a[0],o[s+1]=a[1],o[s+2]=a[2],o[s+3]=a[3]}}return o}static harlequin(t,e,i={}){const{size:s=20,spacing:n=0,background:a=[255,255,255,255],foreground:r=[0,0,0,255]}=i,o=new Uint8ClampedArray(t*e*4);for(let t=0;t<o.length;t+=4)o[t]=a[0],o[t+1]=a[1],o[t+2]=a[2],o[t+3]=a[3];const h=2*s,l=2*s,c=h+n,_=l+n;for(let i=-1;i<e/_+1;i++)for(let s=-1;s<t/c+1;s++){const n=s*c+c/2,a=i*_+_/2;if(!((i+s)%2==0))continue;const f=Math.max(0,Math.floor(n-h/2)),m=Math.min(t-1,Math.ceil(n+h/2)),v=Math.max(0,Math.floor(a-l/2)),y=Math.min(e-1,Math.ceil(a+l/2));for(let e=v;e<=y;e++)for(let i=f;i<=m;i++)if(u=i,d=e,p=n,g=a,Math.abs(u-p)/(h/2)+Math.abs(d-g)/(l/2)<=1){const s=4*(e*t+i);o[s]=r[0],o[s+1]=r[1],o[s+2]=r[2],o[s+3]=r[3]}}var u,d,p,g;return o}static circles(t,e,i={}){const{radius:s=10,lineWidth:n=2,spacing:a=5,background:r=[0,0,0,255],foreground:o=[255,255,255,255]}=i,h=new Uint8ClampedArray(t*e*4);for(let t=0;t<h.length;t+=4)h[t]=r[0],h[t+1]=r[1],h[t+2]=r[2],h[t+3]=r[3];const l=2*s+a,c=(t,e,i,s,n)=>{const a=t-i,r=e-s;return a*a+r*r<=n*n};for(let i=0;i<Math.ceil(e/l)+1;i++)for(let a=0;a<Math.ceil(t/l)+1;a++){const r=a*l+s,_=i*l+s;if(r<-s||r>t+s||_<-s||_>e+s)continue;const u=Math.max(0,Math.floor(r-s)),d=Math.min(t-1,Math.ceil(r+s)),p=Math.max(0,Math.floor(_-s)),g=Math.min(e-1,Math.ceil(_+s)),f=s-n;for(let e=p;e<=g;e++)for(let i=u;i<=d;i++){const n=c(i,e,r,_,s),a=c(i,e,r,_,f);if(n&&!a){const s=4*(e*t+i);h[s]=o[0],h[s+1]=o[1],h[s+2]=o[2],h[s+3]=o[3]}}}return h}static diamonds(t,e,i={}){const{size:s=16,squareSize:n=6,background:a=[255,255,255,255],foreground:r=[0,0,0,255],innerColor:o=[255,255,255,255]}=i,h=new Uint8ClampedArray(t*e*4);for(let t=0;t<h.length;t+=4)h[t]=a[0],h[t+1]=a[1],h[t+2]=a[2],h[t+3]=a[3];const l=s,c=(t,e,i,s,n)=>Math.abs(t-i)<=n/2&&Math.abs(e-s)<=n/2;for(let i=-1;i<e/l+1;i++)for(let s=-1;s<t/l+1;s++){const a=s*l+l/2,f=i*l+l/2;if(a<-l||a>t+l||f<-l||f>e+l)continue;const m=Math.max(0,Math.floor(a-l/2)),v=Math.min(t-1,Math.ceil(a+l/2)),y=Math.max(0,Math.floor(f-l/2)),x=Math.min(e-1,Math.ceil(f+l/2));for(let e=y;e<=x;e++)for(let i=m;i<=v;i++){const s=(_=i,u=e,d=a,p=f,g=l,Math.abs(_-d)+Math.abs(u-p)<=g/2),m=c(i,e,a,f,n);if(s){const s=4*(e*t+i);m?(h[s]=o[0],h[s+1]=o[1],h[s+2]=o[2],h[s+3]=o[3]):(h[s]=r[0],h[s+1]=r[1],h[s+2]=r[2],h[s+3]=r[3])}}}var _,u,d,p,g;return h}static cubes(t,e,i={}){const{size:s=10,spacing:n=2,background:a=[0,0,0,255],foreground:r=[255,100,0,255]}=i,o=new Uint8ClampedArray(t*e*4);for(let t=0;t<o.length;t+=4)o[t]=a[0],o[t+1]=a[1],o[t+2]=a[2],o[t+3]=a[3];const h=s+n;for(let i=0;i<Math.ceil(e/h)+1;i++)for(let n=0;n<Math.ceil(t/h)+1;n++){const a=n*h,l=i*h;if(!(a>=t||l>=e))for(let i=l;i<Math.min(l+s,e);i++)for(let e=a;e<Math.min(a+s,t);e++){const s=4*(i*t+e);o[s]=r[0],o[s+1]=r[1],o[s+2]=r[2],o[s+3]=r[3]}}return o}static cross(t,e,i={}){const{size:s=8,thickness:n=2,spacing:a=16,background:r=[255,255,255,255],foreground:o=[80,80,80,255]}=i,h=new Uint8ClampedArray(t*e*4);for(let t=0;t<h.length;t+=4)h[t]=r[0],h[t+1]=r[1],h[t+2]=r[2],h[t+3]=r[3];for(let i=0;i<Math.ceil(e/a)+1;i++)for(let r=0;r<Math.ceil(t/a)+1;r++){const l=r*a,c=i*a;if(l<-s||l>t+s||c<-s||c>e+s)continue;const _=l-s/2,u=l+s/2,d=c-n/2,p=c+n/2;for(let i=Math.max(0,Math.floor(d));i<Math.min(e,Math.ceil(p));i++)for(let e=Math.max(0,Math.floor(_));e<Math.min(t,Math.ceil(u));e++){const s=4*(i*t+e);h[s]=o[0],h[s+1]=o[1],h[s+2]=o[2],h[s+3]=o[3]}const g=l-n/2,f=l+n/2,m=c-s/2,v=c+s/2;for(let i=Math.max(0,Math.floor(m));i<Math.min(e,Math.ceil(v));i++)for(let e=Math.max(0,Math.floor(g));e<Math.min(t,Math.ceil(f));e++){const s=4*(i*t+e);h[s]=o[0],h[s+1]=o[1],h[s+2]=o[2],h[s+3]=o[3]}}return h}static mesh(t,e,i={}){const{spacing:s=20,lineWidth:n=2,background:a=[255,255,255,0],foreground:r=[0,0,0,255]}=i,o=new Uint8ClampedArray(t*e*4);for(let t=0;t<o.length;t+=4)o[t]=a[0],o[t+1]=a[1],o[t+2]=a[2],o[t+3]=a[3];for(let i=0;i<e;i++)for(let a=0;a<t;a++){const h=(a+i)%s,l=(a-i+e)%s;if(h<n||h>s-n||(l<n||l>s-n)){const e=4*(i*t+a);o[e]=r[0],o[e+1]=r[1],o[e+2]=r[2],o[e+3]=r[3]}}return o}static isometric(t,e,i={}){const{cellSize:s=20,lineWidth:n=1,background:a=[0,0,0,0],foreground:r=[0,255,0,255]}=i,o=new Uint8ClampedArray(t*e*4);for(let t=0;t<o.length;t+=4)o[t]=a[0],o[t+1]=a[1],o[t+2]=a[2],o[t+3]=a[3];const h=s,l=s/2;for(let i=0;i<e;i++)for(let e=0;e<t;e++){const s=e%h,a=i%l,c=a-s/2,_=a+s/2-l,u=Math.abs(c)<n/2,d=Math.abs(_)<n/2;if(u||d){const s=4*(i*t+e);o[s]=r[0],o[s+1]=r[1],o[s+2]=r[2],o[s+3]=r[3]}}return o}static weave(t,e,i={}){const{tileSize:s=40,lineWidth:n=2,background:a=[255,255,255,255],foreground:r=[0,0,0,255]}=i,o=new Uint8ClampedArray(t*e*4);for(let t=0;t<o.length;t+=4)o[t]=a[0],o[t+1]=a[1],o[t+2]=a[2],o[t+3]=a[3];for(let i=0;i<e;i++)for(let e=0;e<t;e++){const a=e%s,h=i%s,l=Math.abs((h+s/2)%s-s/2)<n/2,c=Math.abs((a+2*h+1.5*s)%s-s/2)<n/2,_=Math.abs((a-2*h+1.5*s)%s-s/2)<n/2;if(l||c||_){const s=4*(i*t+e);o[s]=r[0],o[s+1]=r[1],o[s+2]=r[2],o[s+3]=r[3]}}return o}static perlinNoise(t,e,i={}){const{background:s=[0,0,0,0],foreground:n=[255,255,255,255],scale:a=.1,octaves:r=4,persistence:o=.5,lacunarity:h=2,seed:l=65536*Math.random()}=i,c=new Uint8ClampedArray(t*e*4);Noise.seed(l);for(let i=0;i<e;i++)for(let e=0;e<t;e++){let l=1,_=1,u=0,d=0;for(let t=0;t<r;t++){const t=e*a*_,s=i*a*_;u+=Noise.perlin2(t,s)*l,d+=l,l*=o,_*=h}u/=d;const p=.5*(u+1),g=[Math.floor(s[0]+p*(n[0]-s[0])),Math.floor(s[1]+p*(n[1]-s[1])),Math.floor(s[2]+p*(n[2]-s[2])),Math.floor(s[3]+p*(n[3]-s[3]))],f=4*(i*t+e);c.set(g,f)}return c}static circularGradient(t,e,i={}){const{innerColor:s=[255,255,255,255],outerColor:n=[0,0,0,255],centerX:a=t/2,centerY:r=e/2,radius:o=Math.min(t,e)/2,fadeExponent:h=1}=i,l=new Uint8ClampedArray(t*e*4);for(let i=0;i<e;i++)for(let e=0;e<t;e++){const c=4*(i*t+e),_=e-a,u=i-r,d=Math.sqrt(_*_+u*u);let p=Math.min(d/o,1);p=Math.pow(p,h);const g=[Math.floor(s[0]+p*(n[0]-s[0])),Math.floor(s[1]+p*(n[1]-s[1])),Math.floor(s[2]+p*(n[2]-s[2])),Math.floor(s[3]+p*(n[3]-s[3]))];l.set(g,c)}return l}static noiseDisplacement(t,e,i={}){const{gridSpacing:s=16,gridColor:n=[255,255,255,255],background:a=[0,0,0,0],displacementScale:r=8,noiseScale:o=.05,gridThickness:h=1,seed:l=65536*Math.random()}=i,c=new Uint8ClampedArray(t*e*4);Noise.seed(l);for(let t=0;t<c.length;t+=4)c.set(a,t);for(let i=0;i<e;i++)for(let e=0;e<t;e++){const a=e+Noise.perlin2(e*o,i*o)*r,l=i+Noise.perlin2((e+31.416)*o,(i+27.182)*o)*r;if(a%s<h||a%s>s-h||(l%s<h||l%s>s-h)){const s=4*(i*t+e);c.set(n,s)}}return c}static dotPattern(t,e,i={}){const{dotSize:s=3,spacing:n=12,dotColor:a=[0,0,0,255],background:r=[255,255,255,255],useNoise:o=!1,noiseScale:h=.1,noiseDensity:l=.4,seed:c=65536*Math.random()}=i,_=new Uint8ClampedArray(t*e*4);o&&Noise.seed(c);for(let t=0;t<_.length;t+=4)_.set(r,t);if(o)for(let i=0;i<e;i++)for(let n=0;n<t;n++){if(.5*(Noise.perlin2(n*h,i*h)+1)>l)for(let r=-s;r<=s;r++)for(let o=-s;o<=s;o++){const h=n+o,l=i+r;if(h>=0&&h<t&&l>=0&&l<e){if(o*o+r*r<=s*s){const e=4*(l*t+h);_.set(a,e)}}}}else for(let i=Math.floor(n/2);i<e;i+=n)for(let r=Math.floor(n/2);r<t;r+=n)for(let n=-s;n<=s;n++)for(let o=-s;o<=s;o++){const h=r+o,l=i+n;if(h>=0&&h<t&&l>=0&&l<e){if(o*o+n*n<=s*s){const e=4*(l*t+h);_.set(a,e)}}}return _}static voronoi(t,e,i={}){const{cellCount:s=20,cellColors:n=null,edgeColor:a=[0,0,0,255],edgeThickness:r=1.5,seed:o=1e3*Math.random(),jitter:h=.5,baseColor:l=null,colorVariation:c=.3}=i,_=new Uint8ClampedArray(t*e*4);Noise.seed(o);const u=[],d=[],p=()=>{let t=1e4*Math.sin(.167*o+.423*u.length);return t-Math.floor(t)},g=Math.sqrt(s),f=t/g,m=e/g,v=t=>{if(l){const[e,i,s,n]=l,a=Math.max(e,i,s)/255,r=Math.min(e,i,s)/255,o=(a+r)/2;let h,_;if(a===r)h=_=0;else{const t=a-r;_=o>.5?t/(2-a-r):t/(a+r),h=a===e/255?(i/255-s/255)/t+(i/255<s/255?6:0):a===i/255?(s/255-e/255)/t+2:(e/255-i/255)/t+4,h/=6}const u=Noise.perlin2(.15*t,0)*c*.3,d=Noise.perlin2(0,.15*t)*c,g=Noise.perlin2(.15*t,.15*t)*c*.5;h=(h+u)%1,_=Math.min(1,Math.max(0,_*(1+d)));const f=Math.min(.9,Math.max(.1,o*(1+g)));let m,v,y;if(0===_)m=v=y=f;else{const t=(t,e,i)=>(i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+(e-t)*(2/3-i)*6:t),e=f<.5?f*(1+_):f+_-f*_,i=2*f-e;m=t(i,e,h+1/3),v=t(i,e,h),y=t(i,e,h-1/3)}const x=.05,w=()=>(2*p()-1)*x;return[Math.min(255,Math.max(0,Math.floor(255*m*(1+w())))),Math.min(255,Math.max(0,Math.floor(255*v*(1+w())))),Math.min(255,Math.max(0,Math.floor(255*y*(1+w())))),n]}{let e,i,s;const n=6*(.618033988749895*t%1),a=Math.floor(n),r=n-a,o=.5,h=.5*(1-r),l=.5*(1-(1-r));switch(a%6){case 0:e=.5,i=l,s=o;break;case 1:e=h,i=.5,s=o;break;case 2:e=o,i=.5,s=l;break;case 3:e=o,i=h,s=.5;break;case 4:e=l,i=o,s=.5;break;case 5:e=.5,i=o,s=h}return[Math.floor(255*e+50+100*p()),Math.floor(255*i+50+100*p()),Math.floor(255*s+50+100*p()),255]}};for(let t=0;t<g;t++)for(let e=0;e<g&&!(u.length>=s);e++){const i=e*f+f/2,s=t*m+m/2,a=(2*p()-1)*h*f,r=(2*p()-1)*h*m;u.push({x:Math.floor(i+a),y:Math.floor(s+r)}),n&&u.length-1<n.length?d.push(n[u.length-1]):d.push(v(u.length-1))}const y=(i,s,n,a)=>{let r=Math.abs(i-n),o=Math.abs(s-a);r=Math.min(r,t-r),o=Math.min(o,e-o);return.8*Math.sqrt(r*r+o*o)+.2*(r+o)};for(let i=0;i<e;i++)for(let s=0;s<t;s++){const n=4*(i*t+s);let o=1/0,h=1/0,l=0;for(let t=0;t<u.length;t++){const e=y(s,i,u[t].x,u[t].y);e<o?(h=o,o=e,l=t):e<h&&(h=e)}for(let n=0;n<u.length;n++)for(let a=-1;a<=1;a++)for(let r=-1;r<=1;r++){if(0===a&&0===r)continue;const c=u[n].x+a*t,_=u[n].y+r*e,d=Math.sqrt(Math.pow(s-c,2)+Math.pow(i-_,2));d<o?(h=o,o=d,l=n):d<h&&(h=d)}h-o<r?_.set(a,n):_.set(d[l],n)}return _}static penrose(t,e,i={}){return generatePenroseTilingPixels(t,e,i)}}const _Tensor=class t{constructor(t,e={}){__privateAdd(this,_components),__privateAdd(this,_dimension),__privateAdd(this,_name),__privateAdd(this,_signature),__privateAdd(this,_coordinates),__privateSet(this,_components,t.map((t=>[...t]))),__privateSet(this,_dimension,t.length),__privateSet(this,_name,e.name||""),__privateSet(this,_signature,e.signature||null),__privateSet(this,_coordinates,e.coordinates||null)}static minkowski(){return new t([[-1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],{name:"Minkowski",signature:[-1,1,1,1],coordinates:["t","x","y","z"]})}static schwarzschild(e,i,s=Math.PI/2){e<=i&&(e=1.001*i);const n=1-i/e,a=Math.sin(s);return new t([[-n,0,0,0],[0,1/n,0,0],[0,0,e*e,0],[0,0,0,e*e*a*a]],{name:"Schwarzschild",signature:[-1,1,1,1],coordinates:["t","r","θ","φ"]})}static diagonal(e,i={}){const s=e.length,n=[];for(let t=0;t<s;t++){n[t]=[];for(let i=0;i<s;i++)n[t][i]=t===i?e[t]:0}return new t(n,i)}static identity(e=4){const i=new Array(e).fill(1);return t.diagonal(i,{name:"Identity"})}static zero(e=4){const i=[];for(let t=0;t<e;t++)i[t]=new Array(e).fill(0);return new t(i,{name:"Zero"})}get(t,e){return __privateGet(this,_components)[t][e]}set(e,i,s){const n=__privateGet(this,_components).map((t=>[...t]));return n[e][i]=s,new t(n,{name:__privateGet(this,_name),signature:__privateGet(this,_signature),coordinates:__privateGet(this,_coordinates)})}getDiagonal(){const t=[];for(let e=0;e<__privateGet(this,_dimension);e++)t.push(__privateGet(this,_components)[e][e]);return t}get dimension(){return __privateGet(this,_dimension)}get name(){return __privateGet(this,_name)}get signature(){return __privateGet(this,_signature)}get coordinates(){return __privateGet(this,_coordinates)}add(e){const i=[];for(let t=0;t<__privateGet(this,_dimension);t++){i[t]=[];for(let s=0;s<__privateGet(this,_dimension);s++)i[t][s]=__privateGet(this,_components)[t][s]+e.get(t,s)}return new t(i)}subtract(e){const i=[];for(let t=0;t<__privateGet(this,_dimension);t++){i[t]=[];for(let s=0;s<__privateGet(this,_dimension);s++)i[t][s]=__privateGet(this,_components)[t][s]-e.get(t,s)}return new t(i)}scale(e){const i=[];for(let t=0;t<__privateGet(this,_dimension);t++){i[t]=[];for(let s=0;s<__privateGet(this,_dimension);s++)i[t][s]=__privateGet(this,_components)[t][s]*e}return new t(i)}multiply(e){const i=[];for(let t=0;t<__privateGet(this,_dimension);t++){i[t]=[];for(let s=0;s<__privateGet(this,_dimension);s++){let n=0;for(let i=0;i<__privateGet(this,_dimension);i++)n+=__privateGet(this,_components)[t][i]*e.get(i,s);i[t][s]=n}}return new t(i)}transpose(){const e=[];for(let t=0;t<__privateGet(this,_dimension);t++){e[t]=[];for(let i=0;i<__privateGet(this,_dimension);i++)e[t][i]=__privateGet(this,_components)[i][t]}return new t(e,{name:__privateGet(this,_name)?`${__privateGet(this,_name)}ᵀ`:"",signature:__privateGet(this,_signature),coordinates:__privateGet(this,_coordinates)})}inverse(){const e=__privateGet(this,_dimension),i=[];for(let t=0;t<e;t++){i[t]=[];for(let s=0;s<e;s++)i[t][s]=__privateGet(this,_components)[t][s];for(let s=0;s<e;s++)i[t][e+s]=t===s?1:0}for(let t=0;t<e;t++){let s=t;for(let n=t+1;n<e;n++)Math.abs(i[n][t])>Math.abs(i[s][t])&&(s=n);if([i[t],i[s]]=[i[s],i[t]],Math.abs(i[t][t])<1e-10)throw new Error("Matrix is singular, cannot compute inverse");const n=i[t][t];for(let s=0;s<2*e;s++)i[t][s]/=n;for(let s=0;s<e;s++)if(s!==t){const n=i[s][t];for(let a=0;a<2*e;a++)i[s][a]-=n*i[t][a]}}const s=[];for(let t=0;t<e;t++){s[t]=[];for(let n=0;n<e;n++)s[t][n]=i[t][e+n]}return new t(s,{name:__privateGet(this,_name)?`${__privateGet(this,_name)}⁻¹`:"",signature:__privateGet(this,_signature),coordinates:__privateGet(this,_coordinates)})}determinant(){const t=__privateGet(this,_dimension);if(2===t)return __privateGet(this,_components)[0][0]*__privateGet(this,_components)[1][1]-__privateGet(this,_components)[0][1]*__privateGet(this,_components)[1][0];if(3===t){const t=__privateGet(this,_components);return t[0][0]*(t[1][1]*t[2][2]-t[1][2]*t[2][1])-t[0][1]*(t[1][0]*t[2][2]-t[1][2]*t[2][0])+t[0][2]*(t[1][0]*t[2][1]-t[1][1]*t[2][0])}const e=__privateGet(this,_components).map((t=>[...t]));let i=1,s=0;for(let n=0;n<t;n++){let a=n;for(let i=n+1;i<t;i++)Math.abs(e[i][n])>Math.abs(e[a][n])&&(a=i);if(a!==n&&([e[n],e[a]]=[e[a],e[n]],s++),Math.abs(e[n][n])<1e-10)return 0;i*=e[n][n];for(let i=n+1;i<t;i++){e[i][n]/=e[n][n];for(let s=n+1;s<t;s++)e[i][s]-=e[i][n]*e[n][s]}}return s%2==0?i:-i}trace(){let t=0;for(let e=0;e<__privateGet(this,_dimension);e++)t+=__privateGet(this,_components)[e][e];return t}isDiagonal(t=1e-10){for(let e=0;e<__privateGet(this,_dimension);e++)for(let i=0;i<__privateGet(this,_dimension);i++)if(e!==i&&Math.abs(__privateGet(this,_components)[e][i])>t)return!1;return!0}isSymmetric(t=1e-10){for(let e=0;e<__privateGet(this,_dimension);e++)for(let i=e+1;i<__privateGet(this,_dimension);i++)if(Math.abs(__privateGet(this,_components)[e][i]-__privateGet(this,_components)[i][e])>t)return!1;return!0}static christoffel(t,e,i=.001){const s=[],n=t(e).inverse(),a=[];for(let s=0;s<4;s++){const n=[...e],r=[...e];n[s]+=i,r[s]-=i;const o=t(n),h=t(r);a[s]=[];for(let t=0;t<4;t++){a[s][t]=[];for(let e=0;e<4;e++)a[s][t][e]=(o.get(t,e)-h.get(t,e))/(2*i)}}for(let t=0;t<4;t++){s[t]=[];for(let e=0;e<4;e++){s[t][e]=[];for(let i=0;i<4;i++){let r=0;for(let s=0;s<4;s++)r+=n.get(t,s)*(a[e][i][s]+a[i][e][s]-a[s][e][i])/2;s[t][e][i]=r}}}return s}static effectivePotential(t,e,i){if(i<=0)return 1/0;const s=e*e;return-t/i+s/(2*i*i)-t*s/(i*i*i)}static iscoRadius(t){return 3*t}static photonSphereRadius(t){return 1.5*t}toArray(){const t=[];for(let e=0;e<__privateGet(this,_dimension);e++)for(let i=0;i<__privateGet(this,_dimension);i++)t.push(__privateGet(this,_components)[e][i]);return t}toMatrix(){return __privateGet(this,_components).map((t=>[...t]))}toString(t=3){return(__privateGet(this,_name)?`${__privateGet(this,_name)} Tensor:\n`:"")+__privateGet(this,_components).map((e=>`[ ${e.map((e=>e.toFixed(t).padStart(10))).join(" ")} ]`)).join("\n")}toLatex(t=3){return`\\begin{pmatrix}\n${__privateGet(this,_components).map((e=>e.map((e=>e.toFixed(t))).join(" & "))).join(" \\\\\n")}\n\\end{pmatrix}`}};_components=new WeakMap,_dimension=new WeakMap,_name=new WeakMap,_signature=new WeakMap,_coordinates=new WeakMap;let Tensor=_Tensor;const _Logger=class t{static disableAll(){t.enabledClasses=new Set,t.globalLevel=0}static disable(){t.enabled=!1}static enable(){t.enabled=!0}static setLevel(e){t.globalLevel=e}static enableFor(e){t.enabledClasses.add(e)}static disableFor(e){t.enabledClasses.delete(e)}static setOutput(e){t.output=e}constructor(t){this.className=t}static getLogger(e){return t.loggerz[e]||(t.loggerz[e]=new t(e)),t.loggerz[e]}_log(e,i,...s){t.enabled&&(t.globalLevel>=e||t.enabledClasses.has(this.className))&&t.output[i](`[${this.className}]`,...s)}log(...e){this._log(t.INFO,"log",...e)}warn(...e){this._log(t.WARN,"warn",...e)}error(...e){this._log(t.ERROR,"error",...e)}debug(...e){this._log(t.DEBUG,"log",...e)}table(...e){this._log(t.INFO,"table",...e)}groupCollapsed(e){t.enabled&&t.output.groupCollapsed(`[${this.className}] ${e}`)}groupEnd(){t.enabled&&t.output.groupEnd()}time(e){t.enabled&&t.output.time(`[${this.className}] ${e}`)}timeEnd(e){t.enabled&&t.output.timeEnd(`[${this.className}] ${e}`)}clear(){t.output.clear()}};__publicField(_Logger,"ERROR",1),__publicField(_Logger,"WARN",2),__publicField(_Logger,"INFO",3),__publicField(_Logger,"DEBUG",4),__publicField(_Logger,"globalLevel",_Logger.ERROR),__publicField(_Logger,"enabledClasses",new Set),__publicField(_Logger,"output",console),__publicField(_Logger,"enabled",!0),__publicField(_Logger,"loggerz",[]);let Logger=_Logger;class Loggable{constructor(t={}){this.name=t.name||this.constructor.name,this._logger=this.getLogger(t)}get logger(){return null==this._logger?this.getLogger():this._logger}trace(t="render"){this.logger.log(null==this.name?this.constructor.name:this.name,t,"x",this.x,"y",this.y,"w",this.width,"h",this.height,"opacity",this._opacity,"visible",this._visible,"active",this._active,"debug",this.debug)}getLogger(t){return Logger.getLogger(t.name||this.constructor.name)}}const _DebugTab=class t{static getInstance(){return t.instance||(t.instance=new t),t.instance}constructor(){this.createTab()}createTab(){this.tab=document.createElement("div"),Object.assign(this.tab.style,{position:"fixed",bottom:"0",left:"0",right:"0",height:"30px",backgroundColor:"#333",color:"#fff",padding:"5px",cursor:"pointer",fontFamily:"monospace",zIndex:"10000",display:"flex",justifyContent:"space-between",alignItems:"center"}),this.tab.innerText="Console";const t=document.createElement("div"),e=(t,e)=>{const i=document.createElement("button");return i.innerText=t,Object.assign(i.style,{marginLeft:"5px",padding:"2px 5px",fontFamily:"monospace",cursor:"pointer"}),i.onclick=e,i};this.paused=!1,this.scrollLock=!0,t.appendChild(e("Clear",(()=>this.consoleArea.value=""))),t.appendChild(e("Pause",(()=>this.paused=!this.paused))),t.appendChild(e("Scroll Lock",(()=>this.scrollLock=!this.scrollLock))),this.tab.appendChild(t),document.body.appendChild(this.tab),this.consoleArea=document.createElement("textarea"),Object.assign(this.consoleArea.style,{position:"fixed",bottom:"30px",left:"0",right:"0",height:"200px",display:"none",backgroundColor:"#111",color:"#0f0",fontFamily:"monospace",zIndex:"9999",padding:"10px",resize:"none"}),this.consoleArea.readOnly=!0,document.body.appendChild(this.consoleArea),this.tab.onclick=t=>{t.target===this.tab&&(this.consoleArea.style.display="none"===this.consoleArea.style.display?"block":"none")}}appendMessage(t,e,...i){if(this.paused)return;const s=`[${t.toUpperCase()}] ${e} ${i.join(" ")}\n`;this.consoleArea.value+=s,this.scrollLock&&(this.consoleArea.scrollTop=this.consoleArea.scrollHeight)}log(t,...e){this.appendMessage("log",t,...e)}warn(t,...e){this.appendMessage("warn",t,...e)}error(t,...e){this.appendMessage("error",t,...e)}table(t){const e=JSON.stringify(t,null,2);this.appendMessage("table",e)}groupCollapsed(t){this.appendMessage("group",`Group Start: ${t}`)}groupEnd(){this.appendMessage("group","Group End")}time(t){this[`time_${t}`]=performance.now()}timeEnd(t){const e=(performance.now()-this[`time_${t}`]).toFixed(2);this.appendMessage("time",`${t}: ${e} ms`)}};__publicField(_DebugTab,"instance");let DebugTab=_DebugTab;const _PainterEffects=class t{static dropShadow(t,e,i=0,s=0){Painter.ctx.shadowColor=t,Painter.ctx.shadowBlur=e,Painter.ctx.shadowOffsetX=i,Painter.ctx.shadowOffsetY=s}static clearShadow(){Painter.ctx.shadowColor="rgba(0, 0, 0, 0)",Painter.ctx.shadowBlur=0,Painter.ctx.shadowOffsetX=0,Painter.ctx.shadowOffsetY=0}static setAlpha(t){Painter.ctx.globalAlpha=t}static setBlendMode(t){Painter.ctx.globalCompositeOperation=t}static clipRect(t,e,i,s){Painter.ctx.beginPath(),Painter.ctx.rect(t,e,i,s),Painter.ctx.clip()}static clipCircle(t,e,i){Painter.ctx.beginPath(),Painter.shapes.arc(t,e,i,0,2*Math.PI),Painter.ctx.clip()}static blurRegion(t,e,i,s,n){const a=Painter.ctx.filter;Painter.ctx.filter=`blur(${n}px)`;const r=Painter.ctx.getImageData(t,e,i,s);Painter.ctx.putImageData(r,t,e),Painter.ctx.filter=a}static createGlow(e,i,s={}){const n="glow-"+Math.random().toString(36).substr(2,9),a={id:n,type:"glow",active:!0,time:0,color:e,blur:i,options:{...{pulseSpeed:0,pulseMin:.5*i,pulseMax:1.5*i,colorShift:0},...s},update(t){return Object.assign(this,t),this},stop(){return this.active=!1,t._activeEffects.delete(this.id),this},apply(){if(!this.active)return;let t=this.blur,e=this.color;if(this.options.pulseSpeed>0){const e=.5*Math.sin(this.time*this.options.pulseSpeed)+.5;t=this.options.pulseMin+e*(this.options.pulseMax-this.options.pulseMin)}return this.options.colorShift>0&&(e=e.replace("hue",this.time*this.options.colorShift%360)),Painter.ctx.shadowColor=e,Painter.ctx.shadowBlur=t,Painter.ctx.shadowOffsetX=0,Painter.ctx.shadowOffsetY=0,this.time+=1/60,this}};return t._activeEffects.set(n,a),t._startAnimationLoop(),a}static _startAnimationLoop(){if(null!==t._animationId)return;const e=()=>{if(t._activeEffects.forEach((t=>{t.active&&t.apply()})),0===t._activeEffects.size)return cancelAnimationFrame(t._animationId),void(t._animationId=null);t._animationId=requestAnimationFrame(e)};t._animationId=requestAnimationFrame(e)}static clearAllEffects(){t._activeEffects.forEach((t=>t.stop())),t._activeEffects.clear(),Painter.ctx.shadowColor="rgba(0, 0, 0, 0)",Painter.ctx.shadowBlur=0,Painter.ctx.shadowOffsetX=0,Painter.ctx.shadowOffsetY=0,Painter.ctx.filter="none",Painter.ctx.globalAlpha=1,Painter.ctx.globalCompositeOperation="source-over"}};__publicField(_PainterEffects,"_activeEffects",new Map),__publicField(_PainterEffects,"_animationId",null);let PainterEffects=_PainterEffects;class PainterImages{static draw(t,e=0,i=0,{width:s,height:n,crop:a=null,anchor:r="top‑left",rotation:o=0,scaleX:h=1,scaleY:l=1,flipX:c=!1,flipY:_=!1,alpha:u=1,smoothing:d=!0}={}){const p=Painter.ctx;if(!p||!t)return;const g=s??(a?a.sw:t.width??t.videoWidth),f=n??(a?a.sh:t.height??t.videoHeight),m=-g*({left:0,center:.5,right:1}[r.split("-").pop()]??0),v=-f*({top:0,center:.5,bottom:1}[r.split("-")[0]]??0);if(p.save(),p.imageSmoothingEnabled=d,p.globalAlpha*=u,p.translate(e,i),o&&p.rotate(o),(c||_)&&p.scale(c?-1:1,_?-1:1),p.scale(h,l),a){const{sx:e,sy:i,sw:s,sh:n}=a;p.drawImage(t,e,i,s,n,m,v,g,f)}else p.drawImage(t,m,v,g,f);p.restore()}static blit(t,e,i,s,n){this.draw(t,e,i,{width:s,height:n})}static createPattern(t,e="repeat"){return Painter.ctx.createPattern(t,e)}static fillPattern(t,e,i,s,n){const a=Painter.ctx;a.save(),a.fillStyle=t,a.fillRect(e,i,s,n),a.restore()}static createImageData(t,e){return Painter.ctx.createImageData(t,e)}static cloneImageData(t){return new ImageData(new Uint8ClampedArray(t.data),t.width,t.height)}static getImageData(t,e,i,s){return Painter.ctx.getImageData(t,e,i,s)}static putImageData(t,e,i,s=0,n=0,a=t.width,r=t.height){Painter.ctx.putImageData(t,e,i,s,n,a,r)}static mapPixels(t,e){const i=t.data;for(let t=0;t<i.length;t+=4){const s=t>>2,n=e(i[t],i[t+1],i[t+2],i[t+3],s);n&&([i[t],i[t+1],i[t+2],i[t+3]]=n)}return t}static setPixel(t,e,i,s,n,a,r=255){const o=4*(i*t.width+e),h=t.data;h[o]=s,h[o+1]=n,h[o+2]=a,h[o+3]=r}static async toBitmap({type:t="image/png",quality:e=.92}={}){const i=Painter.ctx.canvas,s=await i.convertToBlob({type:t,quality:e});return createImageBitmap(s)}static async createBitmap(t){return createImageBitmap(t)}static toImageData(t,e,i){if(t.length!==e*i*4)throw new Error("Invalid RGBA array size for given dimensions");return new ImageData(t,e,i)}static async createImageBitmapFromPixels(t,e,i){const s=this.toImageData(t,e,i);return await createImageBitmap(s)}static createPatternFromImageData(t,e="repeat"){const i=document.createElement("canvas");i.width=t.width,i.height=t.height;const s=i.getContext("2d");return s.putImageData(t,0,0),s.createPattern(i,e)}static createPatternFromPixels(t,e,i,s="repeat"){const n=this.toImageData(t,e,i);return this.createPatternFromImageData(n,s)}}class PainterLines{static path(t,e,i,s=1){const n=Painter.ctx;n.beginPath();for(const e of t){const[t,...i]=e;"M"===t?n.moveTo(...i):"L"===t?n.lineTo(...i):"C"===t?n.bezierCurveTo(...i):"Q"===t?n.quadraticCurveTo(...i):"Z"===t&&n.closePath()}e&&(n.fillStyle=e,Painter.colors.fill(e)),i&&(n.strokeStyle=i,n.lineWidth=s,Painter.colors.stroke())}static line(t,e,i,s,n,a){Painter.ctx.beginPath(),Painter.ctx.moveTo(t,e),Painter.ctx.lineTo(i,s),Painter.colors.stroke(n,a)}static beginPath(){Painter.ctx.beginPath()}static closePath(){Painter.ctx.closePath()}static moveTo(t,e){Painter.ctx.moveTo(t,e)}static lineTo(t,e){Painter.ctx.lineTo(t,e)}static bezierCurveTo(t,e,i,s,n,a){Painter.ctx.bezierCurveTo(t,e,i,s,n,a)}static dashedLine(t,e,i,s,n,a,r){Painter.ctx.beginPath(),a&&(Painter.ctx.strokeStyle=a),void 0!==r&&(Painter.ctx.lineWidth=r),Painter.ctx.setLineDash(n),Painter.ctx.moveTo(t,e),Painter.ctx.lineTo(i,s),Painter.colors.stroke(),Painter.ctx.setLineDash([])}static dottedLine(t,e,i,s,n=2,a=5,r){return Painter.lines.dashedLine(t,e,i,s,[n,a],r,n)}static setLineDash(t){Painter.ctx.setLineDash(t)}static resetLineDash(){Painter.ctx.setLineDash([])}static setLineWidth(t){Painter.ctx.lineWidth=t}static quadraticCurve(t,e,i,s,n,a,r,o){Painter.ctx.beginPath(),Painter.ctx.moveTo(t,e),Painter.ctx.quadraticCurveTo(i,s,n,a),r&&(Painter.ctx.strokeStyle=r),void 0!==o&&(Painter.ctx.lineWidth=o),Painter.colors.stroke()}}class PainterOpacity{static pushOpacity(t){const e=this._opacityStack[this._opacityStack.length-1]*t;this._opacityStack.push(e),Painter.logger.log("NEXT OPACITY WILL BE",e),Painter.effects.setAlpha(e)}static popOpacity(){if(this._opacityStack.length>1){this._opacityStack.pop();const t=this._opacityStack[this._opacityStack.length-1];Painter.logger.log("NEXT OPACITY WILL BE",t),Painter.effects.setAlpha(t)}}static _clone(){this._opacityStack=[...this._opacityStack]}static saveOpacityState(){this._opacityStateBackup=[...this._opacityStack]}static restoreOpacityState(){this._opacityStateBackup&&(this._opacityStack=this._opacityStateBackup,delete this._opacityStateBackup)}}__publicField(PainterOpacity,"_opacityStack",[1]);class PainterShapes{static rect(t,e,i,s,n){const a=Painter.ctx.fillStyle;Painter.colors.fill(n),Painter.ctx.fillRect(t,e,i,s),Painter.ctx.fillStyle=a}static outlineRect(t,e,i,s,n,a=1){const r=Painter.ctx.strokeStyle,o=Painter.ctx.lineWidth;Painter.ctx.strokeStyle=n,Painter.ctx.lineWidth=a,Painter.ctx.strokeRect(t,e,i,s),Painter.ctx.strokeStyle=r,Painter.ctx.lineWidth=o}static roundRect(t,e,i,s,n=0,a,r,o){let h;h="number"==typeof n?[n,n,n,n]:Array.isArray(n)?4===n.length?n:[n[0]||0,n[1]||n[0]||0,n[2]||n[0]||0,n[3]||n[1]||n[0]||0]:[0,0,0,0];const[l,c,_,u]=h,d=t+i,p=e+s;Painter.lines.beginPath(),Painter.lines.moveTo(t+l,e),Painter.lines.lineTo(d-c,e),this.arc(d-c,e+c,c,-Math.PI/2,0),Painter.lines.lineTo(d,p-_),this.arc(d-_,p-_,_,0,Math.PI/2),Painter.lines.lineTo(t+u,p),this.arc(t+u,p-u,u,Math.PI/2,Math.PI),Painter.lines.lineTo(t,e+l),this.arc(t+l,e+l,l,Math.PI,-Math.PI/2),Painter.lines.closePath(),a&&(Painter.fillStyle=a,Painter.colors.fill(a)),r&&Painter.colors.stroke(r,o)}static fillRoundRect(t,e,i,s,n=0,a){this.roundRect(t,e,i,s,n,a,null)}static strokeRoundRect(t,e,i,s,n=0,a,r){this.roundRect(t,e,i,s,n,null,a,r)}static fillCircle(t,e,i,s){Painter.logger.log("PainterShapes.fillCircle",t,e,i,s),Painter.lines.beginPath(),this.arc(t,e,i,0,2*Math.PI),Painter.colors.fill(s)}static arc(t,e,i,s,n,a){Painter.ctx.arc(t,e,i,s,n,a)}static strokeCircle(t,e,i,s,n){Painter.lines.beginPath(),this.arc(t,e,i,0,2*Math.PI),Painter.colors.stroke(s,n)}static fillEllipse(t,e,i,s,n=0,a){Painter.lines.beginPath(),this.ellipse(t,e,i,s,n,0,2*Math.PI),a&&(Painter.fillStyle=a),Painter.colors.fill(a)}static strokeEllipse(t,e,i,s,n=0,a,r){Painter.lines.beginPath(),this.ellipse(t,e,i,s,n,0,2*Math.PI),a&&(Painter.strokeStyle=a),void 0!==r&&(Painter.lineWidth=r),Painter.colors.stroke(a,r)}static ellipse(t,e,i,s,n,a,r,o){Painter.ctx.ellipse(t,e,i,s,n,a,r,o)}static polygon(t,e,i,s){if(!(t.length<2)){Painter.lines.beginPath(),Painter.lines.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++)Painter.lines.lineTo(t[e].x,t[e].y);Painter.lines.closePath(),e&&Painter.colors.fill(e),i&&Painter.colors.stroke(i,s)}}}class PainterText{static font(){return Painter.ctx.font}static setFont(t){Painter.ctx.font=t}static setTextAlign(t){Painter.ctx.textAlign=t}static setTextBaseline(t){Painter.ctx.textBaseline=t}static fillText(t,e,i,s,n){s&&(Painter.ctx.fillStyle=s),n&&(Painter.ctx.font=n),Painter.ctx.fillText(t,e,i)}static strokeText(t,e,i,s,n,a){s&&(Painter.ctx.strokeStyle=s),void 0!==n&&(Painter.ctx.lineWidth=n),a&&(Painter.ctx.font=a),Painter.ctx.strokeText(t,e,i)}static measureTextDimensions(t,e,i="start",s="alphabetic"){e&&(Painter.ctx.font=e);const n=Painter.ctx.measureText(t);let a=0;return"middle"===s&&(a=-1.5),{width:n.width,height:n.actualBoundingBoxAscent+n.actualBoundingBoxDescent,verticalAdjustment:a}}static measureTextWidth(t,e){return e&&(Painter.ctx.font=e),Painter.ctx.measureText(t).width}static outlinedText(t,e,i,s,n,a,r){r&&(Painter.ctx.font=r),Painter.ctx.strokeStyle=n,Painter.ctx.lineWidth=a,Painter.ctx.strokeText(t,e,i),Painter.ctx.fillStyle=s,Painter.ctx.fillText(t,e,i)}static wrappedText(t,e,i,s,n,a,r){a&&(Painter.ctx.fillStyle=a),r&&(Painter.ctx.font=r);const o=t.split(" ");let h="",l="",c=1;for(let t=0;t<o.length;t++){l=h+o[t]+" ";Painter.ctx.measureText(l).width>s&&t>0?(Painter.ctx.fillText(h,e,i),h=o[t]+" ",i+=n,c++):h=l}return Painter.ctx.fillText(h,e,i),c*n}static textOnPath(t,e,i,s,n=!1){if(e.length<2)return;i&&(Painter.ctx.fillStyle=i),s&&(Painter.ctx.font=s);const a=t.split(""),r=a.map((t=>Painter.ctx.measureText(t).width));n&&(a.reverse(),r.reverse(),e.reverse());let o=0;for(let t=1;t<e.length;t++){const i=e[t].x-e[t-1].x,s=e[t].y-e[t-1].y;o+=Math.sqrt(i*i+s*s)}let h=(o-r.reduce(((t,e)=>t+e),0))/2;h<0&&(h=0);let l=h;for(let t=0;t<a.length;t++){const i=r[t],{x:s,y:n,angle:o}=getPositionOnPath(e,l);Painter.ctx.save(),Painter.ctx.translate(s,n),Painter.ctx.rotate(o),Painter.ctx.fillText(a[t],0,0),Painter.ctx.restore(),l+=i}}static getPositionOnPath(t,e){let i=0;for(let s=1;s<t.length;s++){const n=t[s-1],a=t[s],r=a.x-n.x,o=a.y-n.y,h=Math.sqrt(r*r+o*o);if(i+h>=e){const t=(e-i)/h;return{x:n.x+r*t,y:n.y+o*t,angle:Math.atan2(o,r)}}i+=h}const s=t[t.length-1],n=t[t.length-2],a=Math.atan2(s.y-n.y,s.x-n.x);return{x:s.x,y:s.y,angle:a}}}const _Painter=class t{static get colors(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"colors",__privateGet(this,__colors)),__privateGet(this,__colors)}static get effects(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"effects",__privateGet(this,__effects)),__privateGet(this,__effects)}static get img(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"img",__privateGet(this,__img)),__privateGet(this,__img)}static get lines(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"lines",__privateGet(this,__lines)),__privateGet(this,__lines)}static get opacity(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"opacity",__privateGet(this,__opacity)),__privateGet(this,__opacity)}static get shapes(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"shapes",__privateGet(this,__shapes)),__privateGet(this,__shapes)}static get text(){return __privateMethod(this,_Painter_static,checkInitialized_fn).call(this,"text",__privateGet(this,__text)),__privateGet(this,__text)}static set ctx(t){this._ctx=t}static get ctx(){if(!this._ctx)throw new Error("Cannot access Painter.ctx before initialization!");return this._ctx}static init(e){this._ctx=e,this.saveStack=[],__privateSet(this,__colors,PainterColors),__privateSet(this,__effects,PainterEffects),__privateSet(this,__img,PainterImages),__privateSet(this,__lines,PainterLines),__privateSet(this,__opacity,PainterOpacity),__privateSet(this,__shapes,PainterShapes),__privateSet(this,__text,PainterText),t.logger=Logger.getLogger("Painter"),t.saveStack=[]}static setContext(t){this._ctx=t}static save(){const e=((new Error).stack.split("\n")[2]||"").match(/at\s+(\w+)\.(\w+)/),i=e?`${e[1]}.${e[2]}`:"unknown";this.saveStack.push(i),this.logger.log(`Painter.save() by: ${i}`),this.ctx.save(),t.opacity.saveOpacityState()}static restore(){if(0===this.saveStack.length)return void console.error("PAINTER ERROR: restore() without matching save()!");const e=this.saveStack.pop();this.logger.log(`Painter.restore() balancing save from: ${e}`),this.ctx.restore(),t.opacity.restoreOpacityState()}static translateTo(t,e){(isNaN(t)||void 0===t)&&(t=0),(isNaN(e)||void 0===e)&&(e=0),this.logger.log("moveTo",t,e),this.ctx.translate(t,e)}static resetPosition(){this.logger.log("resetPosition");const t=this.ctx.getTransform();this.ctx.setTransform(t.a,t.b,t.c,t.d,0,0)}static withPosition(t,e,i){this.logger.log("withPosition",t,e),this.save(),this.translateTo(t,e),i(),this.restore()}static clear(e=0,i=0,s=t.ctx.canvas.width,n=t.ctx.canvas.height){t.ctx.clearRect(e,i,s,n)}static translate(e,i){t.ctx.translate(e,i)}static rotate(e){t.logger.log("Painter.rotate",e),t.ctx.rotate(e)}static scale(e,i){t.logger.log("Painter.scale",e,i),t.ctx.scale(e,i)}static useCtx(t,e={}){const i=this.ctx,{saveState:s=!1}=e;s&&this.save(),i.beginPath(),t(i),i.beginPath(),s&&this.restore()}};__colors=new WeakMap,__effects=new WeakMap,__img=new WeakMap,__lines=new WeakMap,__opacity=new WeakMap,__shapes=new WeakMap,__text=new WeakMap,_Painter_static=new WeakSet,checkInitialized_fn=function(t,e){if(!e)throw new Error(`Painter.${t} is not initialized. Call Painter.init(ctx) first.`)},__privateAdd(_Painter,_Painter_static),__privateAdd(_Painter,__colors,null),__privateAdd(_Painter,__effects,null),__privateAdd(_Painter,__img,null),__privateAdd(_Painter,__lines,null),__privateAdd(_Painter,__opacity,null),__privateAdd(_Painter,__shapes,null),__privateAdd(_Painter,__text,null),__publicField(_Painter,"logger");let Painter=_Painter;class PainterColors{static fill(t){Painter.logger.log("PainterColors.fill - before:",Painter.ctx.fillStyle,"setting to:",t),Painter.ctx.fillStyle,Painter.ctx.fillStyle=t,Painter.ctx.fill(),Painter.logger.log("PainterColors.fill - after:",Painter.ctx.fillStyle)}static strokeOptions(t){t.color&&(Painter.ctx.strokeStyle=t.color),void 0!==t.lineWidth&&(Painter.ctx.lineWidth=t.lineWidth),t.lineCap&&(Painter.ctx.lineCap=t.lineCap),t.lineJoin&&(Painter.ctx.lineJoin=t.lineJoin),t.strokeStyle&&(Painter.ctx.strokeStyle=t.strokeStyle)}static stroke(t,e){t&&(Painter.ctx.strokeStyle=t),void 0!==e&&(Painter.ctx.lineWidth=e),Painter.ctx.stroke()}static setFillColor(t){Painter.ctx.fillStyle=t}static setStrokeColor(t){Painter.ctx.strokeStyle=t}static randomColorRGB(){const t=Math.floor(360*Math.random()),e=70+Math.floor(30*Math.random()),i=50+Math.floor(20*Math.random());return Painter.colors.hslToRgb(t,e,i)}static randomColorRGBA(t=255){const[e,i,s]=this.randomColorRGB();return[e,i,s,t]}static randomColorHSL(){return`hsl(${360*Math.random()}, 100%, 50%)`}static randomColorHSL_RGBA(t=255){const e=360*Math.random(),i=60+40*Math.random(),s=40+40*Math.random(),[n,a,r]=Painter.colors.hslToRgb(e,i,s);return[n,a,r,t]}static randomColorHEX(){return"#"+(1048575*Math.random()*1e6).toString(16).slice(0,6)}static parseColorString(t){if((t=t.trim().toLowerCase()).startsWith("hsl")){const e=t.replace(/hsla?\(|\)/g,""),[i,s,n]=e.split(",").map((t=>t.trim())),a=parseFloat(i),r=parseFloat(s)/100,o=parseFloat(n)/100;return Painter.colors.hslToRgb(a,r,o)}if(t.startsWith("#"))return hexToRgb(t);if(t.startsWith("rgb")){const e=t.replace(/rgba?\(|\)/g,""),[i,s,n]=e.split(",").map((t=>parseInt(t.trim())));return[i,s,n]}return[0,0,0]}static rgbArrayToCSS([t,e,i]){return`rgb(${Math.round(t)}, ${Math.round(e)}, ${Math.round(i)})`}static hslToRgb(t,e,i){i/=100;const s=e=>(e+t/30)%12,n=(e/=100)*Math.min(i,1-i),a=t=>i-n*Math.max(-1,Math.min(s(t)-3,Math.min(9-s(t),1)));return[Math.round(255*a(0)),Math.round(255*a(8)),Math.round(255*a(4))]}static rgbToHsl(t,e,i){t/=255,e/=255,i/=255;const s=Math.max(t,e,i),n=Math.min(t,e,i),a=s-n;let r=0,o=0,h=(s+n)/2;if(0!==a)switch(o=a/(1-Math.abs(2*h-1)),s){case t:r=((e-i)/a+6)%6*60;break;case e:r=60*((i-t)/a+2);break;case i:r=60*((t-e)/a+4)}return[r%360,o,h]}static hexToRgb(t){const e=t.replace("#","");return[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}static linearGradient(t,e,i,s,n){const a=Painter.ctx.createLinearGradient(t,e,i,s);for(const t of n)a.addColorStop(t.offset,t.color);return a}static radialGradient(t,e,i,s,n,a,r){const o=Painter.ctx.createRadialGradient(t,e,i,s,n,a);for(const t of r)o.addColorStop(t.offset,t.color);return o}static verticalGradient(t,e,i,s,n){return Painter.colors.linearGradient(t,e,t,e+s,n)}static horizontalGradient(t,e,i,s,n){return Painter.colors.linearGradient(t,e,t+i,e,n)}static conicGradient(t,e,i,s){if("function"==typeof Painter.ctx.createConicGradient){const n=Painter.ctx.createConicGradient(i,t,e);for(const t of s)n.addColorStop(t.offset,t.color);return n}return null}static rgba(t,e,i,s=1){return`rgba(${Math.round(t)}, ${Math.round(e)}, ${Math.round(i)}, ${s})`}static hsl(t,e,i){return`hsl(${t}, ${e}%, ${i}%)`}static hsla(t,e,i,s){return`hsla(${t}, ${e}%, ${i}%, ${s})`}}class Euclidian extends Loggable{constructor(t={}){super(t),this._x="number"==typeof t.x?t.x:0,this._y="number"==typeof t.y?t.y:0,this._width="number"==typeof t.width?t.width:0,this._height="number"==typeof t.height?t.height:0,this.logger.log("Euclidian",this._x,this._y,this._width,this._height)}get x(){return this._x}set x(t){this.validateProp(t,"x"),this._x=t}get y(){return this._y}set y(t){this.validateProp(t,"y"),this._y=t}get width(){return this._width}set width(t){this.validateProp(t,"width"),this._width=Math.max(0,t)}get height(){return this._height}set height(t){this.validateProp(t,"height"),this._height=Math.max(0,t)}get debug(){return this._debug}set debug(t){this.validateProp(t,"debug"),this._debug=Boolean(t)}get debugColor(){return this._debugColor}set debugColor(t){this.validateProp(t,"debugColor"),this._debugColor=t}validateProp(t,e){if(null==t)throw new Error("Invalid property value: "+e+" "+t)}}class Geometry2d extends Euclidian{constructor(t={}){super(t),this._minX=t.minX,this._maxX=t.maxX,this._minY=t.minY,this._maxY=t.maxY,this._boundsDirty=!0,this._cachedBounds=null,this.crisp=t.crisp??!0,this.logger.log("Geometry2d",this.x,this.y,this.width,this.height)}update(){this.trace("Geometry2d.update"),this.applyConstraints(),this.getBounds()}get minX(){return this._minX}set minX(t){this._minX=t}get maxX(){return this._maxX}set maxX(t){this._maxX=t}get minY(){return this._minY}set minY(t){this._minY=t}get maxY(){return this._maxY}set maxY(t){this._maxY=t}get boundsDirty(){return this._boundsDirty}applyConstraints(){void 0!==this._minX&&(this.x=Math.max(this.x,this._minX)),void 0!==this._maxX&&(this.x=Math.min(this.x,this._maxX)),void 0!==this._minY&&(this.y=Math.max(this.y,this._minY)),void 0!==this._maxY&&(this.y=Math.min(this.y,this._maxY)),this.crisp&&(this.x=Math.round(this.x),this.y=Math.round(this.y),this.width=Math.round(this.width),this.height=Math.round(this.height))}getBounds(){return!this._boundsDirty&&this._cachedBounds||(this._cachedBounds=this.calculateBounds(),this._boundsDirty=!1),this._cachedBounds}calculateBounds(){return{width:this.width,height:this.height,x:this.x,y:this.y}}getLocalPosition(){let t=0,e=0;return this.parent&&(t=this.parent.x,e=this.parent.y),{x:this.x-t-this.width/2,y:this.y-e-this.height/2}}markBoundsDirty(){this._boundsDirty=!0}validateProp(t,e){super.validateProp(t,e);t!==this[e]&&this.markBoundsDirty()}setTopLeft(t,e){return this.x=t+this.width/2,this.y=e+this.height/2,this}setCenter(t,e){return this.x=t,this.y=e,this}}class Traceable extends Geometry2d{constructor(t={}){super(t),this._debug=Boolean(t.debug),this._debugColor="string"==typeof t.debugColor?t.debugColor:"#0f0",this.logger.log("Traceable",this.x,this.y,this.width,this.height)}drawDebug(){if(!this._debug)return;const t=this.getDebugBounds();this.logger.log(this.constructor.name,"drawDebug",t.x,t.y,t.width,t.height),Painter.shapes.outlineRect(t.x,t.y,t.width,t.height,this._debugColor,2)}getDebugBounds(){return{width:this.width,height:this.height,x:-this.width/2,y:-this.height/2}}trace(t="render"){this.logger.log(null==this.name?this.constructor.name:this.name,t,"x",this.x,"y",this.y,"w",this.width,"h",this.height,"opacity",this._opacity,"visible",this._visible,"active",this._active,"debug",this.debug)}}class Renderable extends Traceable{constructor(t={}){super(t),this._visible=!1!==t.visible,this._opacity="number"==typeof t.opacity?t.opacity:1,this._active=!1!==t.active,this.zIndex=t.zIndex??0,this._shadowColor=t.shadowColor??void 0,this._shadowBlur=t.shadowBlur??0,this._shadowOffsetX=t.shadowOffsetX??0,this._shadowOffsetY=t.shadowOffsetY??0,this._tick=0,this.logger.log("Renderable",this.x,this.y,this.width,this.height)}render(){!this._visible||this._opacity<=0||(Painter.save(),Painter.effects.setBlendMode(this._blendMode),Painter.opacity.pushOpacity(this._opacity),this.crisp?Painter.translateTo(Math.round(this.x),Math.round(this.y)):Painter.translateTo(this.x,this.y),this.applyShadow(Painter.ctx),"Renderable"!==this.constructor.name&&this.draw(),Painter.opacity.popOpacity(),Painter.restore())}draw(){this.drawDebug()}update(t){this.trace("Renderable.update"),this._tick+=t,super.update(t)}applyShadow(t){this._shadowColor&&(t.shadowColor=this._shadowColor,t.shadowBlur=this._shadowBlur,t.shadowOffsetX=this._shadowOffsetX,t.shadowOffsetY=this._shadowOffsetY)}get visible(){return this._visible}set visible(t){this._visible=Boolean(t)}get active(){return this._active}set active(t){this._active=Boolean(t)}get opacity(){return this._opacity}set opacity(t){this._opacity=Math.min(1,Math.max(0,"number"==typeof t?t:1))}get shadowColor(){return this._shadowColor}set shadowColor(t){this._shadowColor=t}get shadowBlur(){return this._shadowBlur}set shadowBlur(t){this._shadowBlur=t}get shadowOffsetX(){return this._shadowOffsetX}set shadowOffsetX(t){this._shadowOffsetX=t}get shadowOffsetY(){return this._shadowOffsetY}set shadowOffsetY(t){this._shadowOffsetY=t}get tick(){return this._tick}}const _Transform=class t{constructor(t){this._owner=t}get owner(){return this._owner}x(t){return this._owner._x=t,this._owner.markBoundsDirty(),this}y(t){return this._owner._y=t,this._owner.markBoundsDirty(),this}position(t,e){return this._owner._x=t,this._owner._y=e,this._owner.markBoundsDirty(),this}translateBy(t,e){return this._owner._x+=t,this._owner._y+=e,this._owner.markBoundsDirty(),this}width(t){return this._owner._width=Math.max(0,t),this._owner.markBoundsDirty(),this}height(t){return this._owner._height=Math.max(0,t),this._owner.markBoundsDirty(),this}size(t,e){return this._owner._width=Math.max(0,t),this._owner._height=Math.max(0,e),this._owner.markBoundsDirty(),this}rotation(t){return this._owner._rotation=t*Math.PI/180,this._owner.markBoundsDirty(),this}rotationRad(t){return this._owner._rotation=t,this._owner.markBoundsDirty(),this}rotateBy(t){return this._owner._rotation+=t*Math.PI/180,this._owner.markBoundsDirty(),this}scaleX(t){return this._owner._scaleX=t,this._owner.markBoundsDirty(),this}scaleY(t){return this._owner._scaleY=t,this._owner.markBoundsDirty(),this}scale(t){return this._owner._scaleX=t,this._owner._scaleY=t,this._owner.markBoundsDirty(),this}scaleBy(t){return this._owner._scaleX*=t,this._owner._scaleY*=t,this._owner.markBoundsDirty(),this}set(t){return void 0!==t.x&&(this._owner._x=t.x),void 0!==t.y&&(this._owner._y=t.y),void 0!==t.width&&(this._owner._width=Math.max(0,t.width)),void 0!==t.height&&(this._owner._height=Math.max(0,t.height)),void 0!==t.rotation&&(this._owner._rotation=t.rotation*Math.PI/180),void 0!==t.scaleX&&(this._owner._scaleX=t.scaleX),void 0!==t.scaleY&&(this._owner._scaleY=t.scaleY),this._owner.markBoundsDirty(),this}reset(){return this._owner._rotation=0,this._owner._scaleX=1,this._owner._scaleY=1,this._owner.markBoundsDirty(),this}resetAll(){return this._owner._x=0,this._owner._y=0,this._owner._width=0,this._owner._height=0,this._owner._rotation=0,this._owner._scaleX=1,this._owner._scaleY=1,this._owner.markBoundsDirty(),this}toObject(){return{x:this._owner._x,y:this._owner._y,width:this._owner._width,height:this._owner._height,rotation:180*this._owner._rotation/Math.PI,scaleX:this._owner._scaleX,scaleY:this._owner._scaleY}}copyFrom(e){const i=e instanceof t?e.toObject():e;return this.set(i)}static handleDirectSet(e,i){if(t.strictMode)throw new Error(`Direct property assignment "${e} = ${i}" is disabled. Use shape.transform.${e}(${i}) instead. Set Transform.strictMode = false to allow direct assignment.`);console.warn(`[Deprecation] Direct assignment "${e} = ${i}" is deprecated. Use shape.transform.${e}(${i}) instead.`)}};__publicField(_Transform,"strictMode",!1);let Transform=_Transform;class Transformable extends Renderable{constructor(t={}){super(t),this._rotation=t.rotation*Math.PI/180,this._scaleX=t.scaleX??1,this._scaleY=t.scaleY??1,this.transform=new Transform(this),this.logger.log("Transformable",this.x,this.y,this.width,this.height)}draw(){this.applyTransforms(),this.drawDebug()}applyTransforms(){Painter.rotate(this._rotation),Painter.scale(this._scaleX,this._scaleY)}get rotation(){return this._rotation}set rotation(t){this._rotation=t*Math.PI/180,this.markBoundsDirty()}get scaleX(){return this._scaleX}set scaleX(t){this._scaleX=t,this.markBoundsDirty()}get scaleY(){return this._scaleY}set scaleY(t){this._scaleY=t,this.markBoundsDirty()}calculateBounds(){const t=this.width/2,e=this.height/2,i=[{x:-t,y:-e},{x:t,y:-e},{x:t,y:e},{x:-t,y:e}],s=Math.cos(this._rotation),n=Math.sin(this._rotation),a=i.map((({x:t,y:e})=>{t*=this._scaleX,e*=this._scaleY;const i=t*n+e*s;return{x:t*s-e*n+this.x,y:i+this.y}})),r=a.map((t=>t.x)),o=a.map((t=>t.y)),h=Math.min(...r),l=Math.max(...r),c=Math.min(...o),_=Math.max(...o);return{x:(h+l)/2,y:(c+_)/2,width:l-h,height:_-c}}}class Shape extends Transformable{constructor(t={}){super(t),this._color=t.color??null,this._stroke=t.stroke??null,this._lineWidth=t.lineWidth??1,this._lineJoin=t.lineJoin??"miter",this._lineCap=t.lineCap??"butt",this._miterLimit=t.miterLimit??10,this.logger.log("Shape",this.x,this.y,this.width,this.height)}get color(){return this._color}set color(t){this._color=t}get stroke(){return this._stroke}set stroke(t){this._stroke=t}get lineWidth(){return this._lineWidth}set lineWidth(t){this._lineWidth=Math.max(0,t)}get lineJoin(){return this._lineJoin}set lineJoin(t){this._lineJoin=t}get lineCap(){return this._lineCap}set lineCap(t){this._lineCap=t}get miterLimit(){return this._miterLimit}set miterLimit(t){this._miterLimit=t}}class Group extends Transformable{constructor(t={}){super(t),this._collection=new ZOrderedCollection({sortByZIndex:t.sortByZIndex||!0}),this._collection._owner=this,this._childrenVersion=0,this._cachedBounds=null,t.width=Math.max(0,t.width||0),t.height=Math.max(0,t.height||0),this.userDefinedWidth=t.width,this.userDefinedHeight=t.height,this.userDefinedDimensions=void 0!==t.width&&void 0!==t.height&&(t.width>0||t.height>0),this._cacheRendering=t.cacheRendering??!1,this._cacheCanvas=null,this._cacheDirty=!0}invalidateCache(){this._cacheDirty=!0}add(t){if(null==t||null==t)throw new Error("Object is null or undefined");if(!(t instanceof Transformable))throw new TypeError("Group can only add Transformable instances");return t.parent=this,this._collection.add(t),this._childrenVersion++,this.markBoundsDirty(),this.invalidateCache(),t}remove(t){const e=this._collection.remove(t);return e&&(t.parent=null,this._childrenVersion++,this.markBoundsDirty(),this.invalidateCache()),e}clear(){this._collection.clear(),this._childrenVersion++,this.markBoundsDirty(),this.invalidateCache()}bringToFront(t){return this._collection.bringToFront(t)}sendToBack(t){return this._collection.sendToBack(t)}bringForward(t){return this._collection.bringForward(t)}sendBackward(t){return this._collection.sendBackward(t)}draw(){if(super.draw(),this.logger.log("Group.draw children:",this.children.length),!this._cacheRendering)return void this._renderChildren();const t=this.getBounds(),e=Math.ceil(t.width)||1,i=Math.ceil(t.height)||1;this._cacheCanvas&&this._cacheCanvas.width===e&&this._cacheCanvas.height===i||(this._cacheCanvas=document.createElement("canvas"),this._cacheCanvas.width=e,this._cacheCanvas.height=i,this._cacheDirty=!0),this._cacheDirty&&(this._renderToCache(e,i),this._cacheDirty=!1),Painter.img.blit(this._cacheCanvas,-e/2,-i/2,e,i)}_renderChildren(){const t=this._collection.getSortedChildren();for(let e=0;e<t.length;e++){const i=t[e];i.visible&&(Painter.save(),i.render(),Painter.restore())}}_renderToCache(t,e){const i=this._cacheCanvas.getContext("2d");i.clearRect(0,0,t,e);const s=Painter.ctx;Painter.ctx=i,i.save(),i.translate(t/2,e/2),this._renderChildren(),i.restore(),Painter.ctx=s}update(t){this.logger.groupCollapsed("Group.update");const e=this._collection.getSortedChildren();for(let i=0;i<e.length;i++){const s=e[i];s.active&&"function"==typeof s.update&&s.update(t)}super.update(t),this.logger.groupEnd()}get children(){var t;return(null==(t=this._collection)?void 0:t.children)||[]}get width(){return this.userDefinedDimensions?this._width:this.getBounds().width}set width(t){const e=Math.max(0,t);this._width=e,this.userDefinedWidth=e,this.userDefinedDimensions=(this.userDefinedWidth>0||this.userDefinedHeight>0)&&void 0!==this.userDefinedWidth&&void 0!==this.userDefinedHeight,this.markBoundsDirty()}get height(){return this.userDefinedDimensions?this._height:this.getBounds().height}set height(t){const e=Math.max(0,t);this._height=e,this.userDefinedHeight=e,this.userDefinedDimensions=(this.userDefinedWidth>0||this.userDefinedHeight>0)&&void 0!==this.userDefinedWidth&&void 0!==this.userDefinedHeight,this.markBoundsDirty()}get cacheRendering(){return this._cacheRendering}set cacheRendering(t){this._cacheRendering=t,t&&(this._cacheDirty=!0)}calculateBounds(){var t;if(this.userDefinedDimensions)return{x:this.x,y:this.y,width:this._width,height:this._height};if(!(null==(t=this.children)?void 0:t.length))return{x:this.x,y:this.y,width:0,height:0};let e=1/0,i=1/0,s=-1/0,n=-1/0;for(const t of this.children){const a=t.x,r=t.y,o=t.width,h=t.height,l=a-o/2,c=a+o/2,_=r-h/2,u=r+h/2;e=Math.min(e,l),s=Math.max(s,c),i=Math.min(i,_),n=Math.max(n,u)}const a=s-e,r=n-i;return{x:this.x,y:this.y,width:a,height:r}}getDebugBounds(){const t=this.calculateBounds();return{width:t.width,height:t.height,x:-t.width/2,y:-t.height/2}}forEachTransform(t){return this.children.forEach(((e,i)=>{e.transform&&t(e.transform,e,i)})),this}translateChildren(t,e){return this.forEachTransform((i=>i.translateBy(t,e)))}scaleChildren(t){return this.forEachTransform((e=>e.scaleBy(t)))}rotateChildren(t){return this.forEachTransform((e=>e.rotateBy(t)))}resetChildTransforms(){return this.forEachTransform((t=>t.reset()))}}class Arc extends Shape{constructor(t,e,i,s={}){super(s),this.radius=t,this.startAngle=e,this.endAngle=i}draw(){super.draw(),Painter.lines.beginPath(),Painter.shapes.arc(0,0,this.radius,this.startAngle,this.endAngle,!1),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}getBounds(){const t=this.radius;return{x:this.x,y:this.y,width:2*t,height:2*t}}}class Circle extends Shape{constructor(t,e={}){super(e),this._radius=t,this.width=2*t,this.height=2*t}draw(){super.draw(),this.color&&Painter.shapes.fillCircle(0,0,this._radius,this.color),this.stroke&&Painter.shapes.strokeCircle(0,0,this._radius,this.stroke,this.lineWidth)}calculateBounds(){const t=2*this._radius;return this.trace("Circle.calculateBounds:"+t),{x:this.x,y:this.y,width:t,height:t}}get radius(){return this._radius}set radius(t){this.validateProp(t,"radius"),t!=this._radius&&(this._radius=t,this.width=2*t,this.height=2*t,this._boundsDirty=!0,this.calculateBounds())}}class Cloud extends Shape{constructor(t=40,e={}){super(e),this.size=t,this.width=2*t,this.height=2*t}draw(){super.draw();const t=this.size,e=Painter.ctx,i=[{x:.5*-t,y:0,r:.4*t},{x:.2*-t,y:.3*-t,r:.35*t},{x:.2*t,y:.35*-t,r:.4*t},{x:.5*t,y:0,r:.35*t},{x:0,y:.15*t,r:.5*t}];if(this.color){e.fillStyle=this.color;for(const t of i)e.beginPath(),e.arc(t.x,t.y,t.r,0,2*Math.PI),e.fill()}if(this.stroke){e.strokeStyle=this.stroke,e.lineWidth=this.lineWidth;for(const t of i)e.beginPath(),e.arc(t.x,t.y,t.r,0,2*Math.PI),e.stroke()}}getBounds(){const t=2*this.size;return{x:this.x,y:this.y,width:t,height:t}}}class BezierShape extends Shape{constructor(t=[],e={}){super(e),this.path=t}draw(){super.draw(),Painter.lines.path(this.path,this.color,this.stroke,this.lineWidth)}getBounds(){return{x:this.x,y:this.y,width:100,height:100}}}class Rectangle extends Shape{constructor(t={}){super(t)}draw(){super.draw(),this.drawRect()}drawRect(){const t=-this.width/2,e=-this.height/2;this.color&&Painter.shapes.rect(t,e,this.width,this.height,this.color),this.stroke&&Painter.shapes.outlineRect(t,e,this.width,this.height,this.stroke,this.lineWidth)}}class RoundedRectangle extends Shape{constructor(t=0,e={}){super(e),"number"==typeof t?this.radii=[t,t,t,t]:Array.isArray(t)?this.radii=4===t.length?t:[t[0]||0,t[1]||t[0]||0,t[2]||t[0]||0,t[3]||t[1]||t[0]||0]:this.radii=[0,0,0,0]}draw(){super.draw();const t=-this.width/2,e=-this.height/2;this.color&&this.stroke?Painter.shapes.roundRect(t,e,this.width,this.height,this.radii,this.color,this.stroke,this.lineWidth):this.color?Painter.shapes.fillRoundRect(t,e,this.width,this.height,this.radii,this.color):this.stroke&&Painter.shapes.strokeRoundRect(t,e,this.width,this.height,this.radii,this.stroke,this.lineWidth)}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class PatternRectangle extends Shape{constructor(t=null,e="repeat",i={}){super(i),this.image=t,this.repetition=e,this.pattern=null,t&&this._tryCreatePattern(t)}_tryCreatePattern(t){t instanceof HTMLImageElement||"boolean"==typeof t.complete?t.complete?this._createPattern():t.addEventListener("load",(()=>this._createPattern()),{once:!0}):this._createPattern()}_createPattern(){this.pattern=Painter.img.createPattern(this.image,this.repetition)}setImage(t,e){this.image=t,e&&(this.repetition=e),this.pattern=null,this._tryCreatePattern(t)}draw(){super.draw(),!this.pattern&&this.image&&this._tryCreatePattern(this.image);const t=-this.width/2,e=-this.height/2;this.pattern?Painter.img.fillPattern(this.pattern,t,e,this.width,this.height):this.strokeColor&&Painter.shapes.outlineRect(t,e,this.width,this.height,this.strokeColor,this.lineWidth)}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class Square extends Rectangle{constructor(t,e={}){super(e),this.width=t,this.height=t}}class Cube extends Shape{constructor(t=50,e={}){super(e),this.size=t,this.faceTopColor=e.faceTopColor||"#eee",this.faceBottomColor=e.faceBottomColor||"#ccc",this.faceLeftColor=e.faceLeftColor||"#aaa",this.faceRightColor=e.faceRightColor||"#888",this.faceFrontColor=e.faceFrontColor||"#666",this.faceBackColor=e.faceBackColor||"#444",this.strokeColor=e.strokeColor||null,this.lineWidth=e.lineWidth||1,this.rotationX=e.rotationX||0,this.rotationY=e.rotationY||0,this.rotationZ=e.rotationZ||0,this.visibleFaces=e.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.size/2,e=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let a=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=a*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-a*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),a=t,s=e,{x:t=a*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=a*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},i=(t,i,s)=>{const n=e(t,i,s);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z}},s={p0:i(-t,-t,-t),p1:i(t,-t,-t),p2:i(t,t,-t),p3:i(-t,t,-t),p4:i(-t,-t,t),p5:i(t,-t,t),p6:i(t,t,t),p7:i(-t,t,t)},n={top:{points:[s.p4,s.p5,s.p6,s.p7],color:this.faceTopColor,normal:[0,0,1]},bottom:{points:[s.p0,s.p1,s.p2,s.p3],color:this.faceBottomColor,normal:[0,0,-1]},left:{points:[s.p0,s.p4,s.p7,s.p3],color:this.faceLeftColor,normal:[-1,0,0]},right:{points:[s.p1,s.p5,s.p6,s.p2],color:this.faceRightColor,normal:[1,0,0]},front:{points:[s.p0,s.p1,s.p5,s.p4],color:this.faceFrontColor,normal:[0,-1,0]},back:{points:[s.p3,s.p2,s.p6,s.p7],color:this.faceBackColor,normal:[0,1,0]}};this.visibleFaces.map((t=>{const e=n[t];if(!e)return null;const i=e.points.reduce(((t,e)=>({x:t.x+e.x,y:t.y+e.y})),{x:0,y:0});i.x/=e.points.length,i.y/=e.points.length;return{key:t,face:e,depth:i.x*i.x+i.y*i.y}})).filter((t=>null!==t)).sort(((t,e)=>e.depth-t.depth)).forEach((({key:t,face:e})=>{(null==e?void 0:e.color)&&Painter.shapes.polygon(e.points,e.color,this.strokeColor,this.lineWidth)}))}getBounds(){const t=1.5*this.size;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cone extends Shape{constructor(t=50,e=100,i={}){super(i),this.radius=t,this.height=e||i.height||100,this.segments=i.segments||24,this.bottomColor=i.bottomColor||"#eee",this.sideColor=i.sideColor||"#aaa",this.stroke=i.stroke||null,this.lineWidth=i.lineWidth||1,this.rotationX=i.rotationX||0,this.rotationY=i.rotationY||0,this.rotationZ=i.rotationZ||0,this.visibleFaces=i.visibleFaces||["bottom","side"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.radius,e=this.height/2,i=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let a=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=a*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-a*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),a=t,s=e,{x:t=a*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=a*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},s=(t,e,s)=>{const n=i(t,e,s);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z}},n=s(0,0,e),a=[],r=2*Math.PI/this.segments;for(let i=0;i<this.segments;i++){const n=i*r,o=Math.cos(n)*t,h=Math.sin(n)*t;a.push(s(o,h,-e))}const o=[];for(let t=0;t<this.segments;t++){const e=(t+1)%this.segments;o.push({points:[n,a[t],a[e]],z:(n.z+a[t].z+a[e].z)/3})}const h=[];this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...a].reverse(),z:-e}),this.visibleFaces.includes("side")&&h.push(...o.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,e)=>e.z-t.z));for(const t of h){const e="bottom"===t.type?this.bottomColor:this.sideColor;Painter.shapes.polygon(t.points,e,this.stroke,this.lineWidth)}}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Prism extends Shape{constructor(t=100,e={}){super(e),this.depth=t,this.faceTopColor=e.faceTopColor||"#eee",this.faceBottomColor=e.faceBottomColor||"#ccc",this.faceLeftColor=e.faceLeftColor||"#aaa",this.faceRightColor=e.faceRightColor||"#888",this.faceFrontColor=e.faceFrontColor||"#666",this.faceBackColor=e.faceBackColor||"#444",this.stroke=e.stroke||null,this.lineWidth=e.lineWidth||1,this.rotationX=e.rotationX||0,this.rotationY=e.rotationY||0,this.rotationZ=e.rotationZ||0,this.visibleFaces=e.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.width/2,e=this.height/2,i=this.depth/2,s=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let a=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=a*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-a*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),a=t,s=e,{x:t=a*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=a*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},n=(t,e,i)=>{const n=s(t,e,i);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z}},a={p0:n(-t,-i,-e),p1:n(t,-i,-e),p2:n(0,-i,e),p3:n(-t,i,-e),p4:n(t,i,-e),p5:n(0,i,e)},r={front:{points:[a.p0,a.p1,a.p2],color:this.faceFrontColor},back:{points:[a.p3,a.p4,a.p5],color:this.faceBackColor},bottom:{points:[a.p0,a.p1,a.p4,a.p3],color:this.faceBottomColor},right:{points:[a.p1,a.p2,a.p5,a.p4],color:this.faceRightColor},left:{points:[a.p0,a.p2,a.p5,a.p3],color:this.faceLeftColor}};this.visibleFaces.filter((t=>r[t])).map((t=>{const e=r[t],i=e.points.reduce(((t,e)=>t+e.x),0)/e.points.length,s=e.points.reduce(((t,e)=>t+e.y),0)/e.points.length,n=e.points.reduce(((t,e)=>t+(e.z||0)),0)/e.points.length;return{key:t,face:e,depth:i*i+s*s+n*n}})).sort(((t,e)=>e.depth-t.depth)).forEach((({key:t,face:e})=>{(null==e?void 0:e.color)&&Painter.shapes.polygon(e.points,e.color,this.stroke,this.lineWidth)}))}getBounds(){const t=1.5*Math.max(this.width,this.height,this.depth);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cylinder extends Shape{constructor(t=40,e={}){super(e),this.radius=t,this.height=e.height||80,this.segments=e.segments||24,this.topColor=e.topColor||"#FF00FF",this.bottomColor=e.bottomColor||"#FF0FFF",this.sideColor=e.sideColor||"#00FF00",this.stroke=e.stroke||"#000000",this.lineWidth=e.lineWidth||1,this.rotationX=e.rotationX||0,this.rotationY=e.rotationY||0,this.rotationZ=e.rotationZ||0,this.visibleFaces=e.visibleFaces||["top","bottom","side"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.radius,e=this.height/2,i=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let a=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=a*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-a*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),a=t,s=e,{x:t=a*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=a*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},s=(t,e,s)=>{const n=i(t,e,s);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z}},n=[],a=[],r=2*Math.PI/this.segments;for(let i=0;i<this.segments;i++){const o=i*r,h=Math.cos(o)*t,l=Math.sin(o)*t;n.push(s(h,l,e)),a.push(s(h,l,-e))}const o=[];for(let t=0;t<this.segments;t++){const e=(t+1)%this.segments;o.push({points:[a[t],a[e],n[e],n[t]],z:(n[t].z+n[e].z+a[t].z+a[e].z)/4})}const h=[];this.visibleFaces.includes("top")&&h.push({type:"top",points:n,z:e}),this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...a].reverse(),z:-e}),this.visibleFaces.includes("side")&&h.push(...o.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,e)=>e.z-t.z));for(const t of h){let e;switch(t.type){case"top":e=this.topColor;break;case"bottom":e=this.bottomColor;break;case"side":e=this.sideColor}Painter.shapes.polygon(t.points,e,this.stroke,this.lineWidth)}}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Diamond extends Shape{constructor(t={}){super(t)}draw(){super.draw();const t=this.width/2,e=this.height/2,i=[{x:0,y:-e},{x:t,y:0},{x:0,y:e},{x:-t,y:0}];Painter.shapes.polygon(i,this.color,this.stroke,this.lineWidth)}}class Line extends Shape{constructor(t=40,e={}){super(e),this.length=t}draw(){super.draw();const t=this.length/2;Painter.lines.line(-t,-t,t,t,this.stroke,this.lineWidth)}}class Triangle extends Shape{constructor(t=50,e={}){super(e),this.size=t}draw(){super.draw();const t=this.size/2,e=[{x:0,y:-t},{x:t,y:t},{x:-t,y:t}];Painter.shapes.polygon(e,this.color,this.stroke,this.lineWidth)}}class Star extends Shape{constructor(t=40,e=5,i=.5,s={}){super(s),this.radius=t,this.spikes=e,this.inset=i}draw(){super.draw();const t=Math.PI/this.spikes,e=-Math.PI/2;Painter.lines.beginPath();for(let i=0;i<2*this.spikes;i++){const s=i%2==0?this.radius:this.radius*this.inset,n=i*t+e,a=Math.cos(n)*s,r=Math.sin(n)*s;0===i?Painter.lines.moveTo(a,r):Painter.lines.lineTo(a,r)}Painter.lines.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}}class Sphere extends Shape{constructor(t=50,e={}){super(e),this.radius=t,this.hSegments=e.hSegments||16,this.vSegments=e.vSegments||12,this.color=e.color||"#6495ED",this.highlightColor=e.highlightColor||"#FFFFFF",this.wireframe=e.wireframe||!1,this.stroke=e.stroke||"#333333",this.lineWidth=e.lineWidth||1,this.rotationX=e.rotationX||0,this.rotationY=e.rotationY||0,this.rotationZ=e.rotationZ||0}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}calculateSurfaceColor(t,e,i){let s=t*(1/Math.sqrt(3))+e*(1/Math.sqrt(3))+i*(1/Math.sqrt(3));if(s=Math.max(.3,s),this.highlightColor){const t=this.hexToRgb(this.color),e=this.hexToRgb(this.highlightColor);return`rgb(${Math.round(t.r*(1-s)+e.r*s)}, ${Math.round(t.g*(1-s)+e.g*s)}, ${Math.round(t.b*(1-s)+e.b*s)})`}const n=this.hexToRgb(this.color);return`rgb(${Math.min(255,Math.round(n.r*s))}, ${Math.min(255,Math.round(n.g*s))}, ${Math.min(255,Math.round(n.b*s))})`}hexToRgb(t){const e={r:100,g:100,b:255};if(!t||"string"!=typeof t)return e;const i=t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,((t,e,i,s)=>e+e+i+i+s+s)),s=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(i);return s?{r:parseInt(s[1],16),g:parseInt(s[2],16),b:parseInt(s[3],16)}:e}draw(){super.draw();const t=this.radius,e=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let a=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=a*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-a*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),a=t,s=e,{x:t=a*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=a*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},i=(i,s,n)=>{const a=e(i,s,n);return{x:(a.x-a.y)*Math.cos(Math.PI/6),y:(a.x+a.y)*Math.sin(Math.PI/6)-a.z,z:a.z,nx:a.x/t,ny:a.y/t,nz:a.z/t}},s=[];for(let e=0;e<=this.vSegments;e++){const n=[],a=e/this.vSegments,r=Math.PI*a-Math.PI/2;for(let e=0;e<=this.hSegments;e++){const s=e/this.hSegments,a=2*Math.PI*s,o=t*Math.cos(r)*Math.cos(a),h=t*Math.cos(r)*Math.sin(a),l=t*Math.sin(r);n.push(i(o,h,l))}s.push(n)}const n=[];for(let t=0;t<this.vSegments;t++)for(let e=0;e<this.hSegments;e++){const i=s[t][e],a=s[t][e+1],r=s[t+1][e],o=s[t+1][e+1],h=(i.z+a.z+r.z+o.z)/4,l=(i.nx+a.nx+r.nx+o.nx)/4,c=(i.ny+a.ny+r.ny+o.ny)/4,_=(i.nz+a.nz+r.nz+o.nz)/4;n.push({points:[i,a,o,r],z:h,color:this.calculateSurfaceColor(l,c,_)})}if(n.sort(((t,e)=>e.z-t.z)),this.wireframe)for(const t of n){const e=t.points;for(let t=0;t<e.length;t++){const i=(t+1)%e.length;Painter.lines.line(e[t].x,e[t].y,e[i].x,e[i].y,this.stroke,this.lineWidth)}}for(const t of n)Painter.shapes.polygon(t.points,t.color,this.stroke,this.lineWidth)}getBounds(){const t=2*this.radius*1.5;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class SVGShape extends Shape{constructor(t,e={}){console.log("SVGShape",e.x),super(e),this.scale=e.scale||1,this.centerPath=void 0===e.centerPath||e.centerPath,this.animationProgress=void 0!==e.animationProgress?e.animationProgress:1,this.svgPathData=t,this.pathCommands=this.parseSVGPath(t),this.centerPath?this.pathCommands=this.centerAndScalePath(this.pathCommands,this.scale):this.pathCommands=this.scalePath(this.pathCommands,this.scale),this.prevX=0,this.prevY=0,this.currentPoint={x:0,y:0}}parseSVGPath(t){const e=/M\s*([-\d.]+)[,\s]*([-\d.]+)/g,i=/L\s*([-\d.]+)[,\s]*([-\d.]+)/g,s=/C\s*([-\d.]+)[,\s]*([-\d.]+)\s*([-\d.]+)[,\s]*([-\d.]+)\s*([-\d.]+)[,\s]*([-\d.]+)/g,n=[];let a;for(;null!==(a=e.exec(t));)n.push(["M",parseFloat(a[1]),parseFloat(a[2])]);for(;null!==(a=i.exec(t));){const t=parseFloat(a[1]),e=parseFloat(a[2]);let i=0,s=0;for(let t=n.length-1;t>=0;t--){const e=n[t];if("M"===e[0]){i=e[1],s=e[2];break}if("C"===e[0]){i=e[5],s=e[6];break}}const r=i+(t-i)/3,o=s+(e-s)/3,h=i+2*(t-i)/3,l=s+2*(e-s)/3;n.push(["C",r,o,h,l,t,e])}for(;null!==(a=s.exec(t));)n.push(["C",parseFloat(a[1]),parseFloat(a[2]),parseFloat(a[3]),parseFloat(a[4]),parseFloat(a[5]),parseFloat(a[6])]);return/Z/g.test(t)&&n.push(["Z"]),n}centerAndScalePath(t,e){let i=1/0,s=1/0,n=-1/0,a=-1/0;for(const e of t)"M"===e[0]?(i=Math.min(i,e[1]),s=Math.min(s,e[2]),n=Math.max(n,e[1]),a=Math.max(a,e[2])):"C"===e[0]&&(i=Math.min(i,e[1],e[3],e[5]),s=Math.min(s,e[2],e[4],e[6]),n=Math.max(n,e[1],e[3],e[5]),a=Math.max(a,e[2],e[4],e[6]));const r=(i+n)/2,o=(s+a)/2;return this.originalWidth=(n-i)*e,this.originalHeight=(a-s)*e,t.map((t=>"M"===t[0]?["M",(t[1]-r)*e,(t[2]-o)*e]:"C"===t[0]?["C",(t[1]-r)*e,(t[2]-o)*e,(t[3]-r)*e,(t[4]-o)*e,(t[5]-r)*e,(t[6]-o)*e]:[...t]))}scalePath(t,e){let i=1/0,s=1/0,n=-1/0,a=-1/0;for(const e of t)"M"===e[0]?(i=Math.min(i,e[1]),s=Math.min(s,e[2]),n=Math.max(n,e[1]),a=Math.max(a,e[2])):"C"===e[0]&&(i=Math.min(i,e[1],e[3],e[5]),s=Math.min(s,e[2],e[4],e[6]),n=Math.max(n,e[1],e[3],e[5]),a=Math.max(a,e[2],e[4],e[6]));return this.originalWidth=(n-i)*e,this.originalHeight=(a-s)*e,t.map((t=>"M"===t[0]?["M",t[1]*e,t[2]*e]:"C"===t[0]?["C",t[1]*e,t[2]*e,t[3]*e,t[4]*e,t[5]*e,t[6]*e]:[...t]))}getBezierPoint(t,e){if("M"===t[0])return{x:t[1],y:t[2]};if("C"===t[0]){const i=this.prevX,s=this.prevY,n=t[1],a=t[2],r=t[3],o=t[4],h=t[5],l=t[6];return{x:Math.pow(1-e,3)*i+3*Math.pow(1-e,2)*e*n+3*(1-e)*Math.pow(e,2)*r+Math.pow(e,3)*h,y:Math.pow(1-e,3)*s+3*Math.pow(1-e,2)*e*a+3*(1-e)*Math.pow(e,2)*o+Math.pow(e,3)*l}}return{x:0,y:0}}getPartialPath(){const t=[];let e=this.pathCommands.length,i=Math.floor(this.animationProgress*e),s=this.animationProgress*e%1,n=!1;this.prevX=0,this.prevY=0;for(let e=0;e<i;e++){const i=this.pathCommands[e];t.push([...i]),"M"===i[0]?(this.prevX=i[1],this.prevY=i[2],n=!0):"C"===i[0]&&(this.prevX=i[5],this.prevY=i[6],n=!0)}if(i<e){const e=this.pathCommands[i];if("M"===e[0])t.push([...e]),this.prevX=e[1],this.prevY=e[2],this.currentPoint={x:e[1],y:e[2]},n=!0;else if("C"===e[0]){if(!n){for(let t=i-1;t>=0;t--)if("M"===this.pathCommands[t][0]){this.prevX=this.pathCommands[t][1],this.prevY=this.pathCommands[t][2],n=!0;break}n||(this.prevX=0,this.prevY=0)}const a=this.getBezierPoint(e,s);t.push(["C",e[1],e[2],e[3],e[4],a.x,a.y]),this.currentPoint=a}}return t}draw(){super.draw();const t=this.getPartialPath();Painter.lines.path(t,this.color,this.stroke,this.lineWidth)}getCurrentPoint(){return{x:this.currentPoint.x,y:this.currentPoint.y}}setAnimationProgress(t){this.animationProgress=Math.max(0,Math.min(1,t))}calculateBounds(){return{x:this.x,y:this.y,width:this.originalWidth||100,height:this.originalHeight||100}}}class StickFigure extends Shape{constructor(t=1,e={}){super(e),this.scale=t,this.stroke=e.stroke||"#000",this.headColor=e.headColor||this.stroke,this.jointColor=e.jointColor||this.stroke,this.lineWidth=e.lineWidth||2,this.showJoints=!1!==e.showJoints}draw(){super.draw();const t=this.scale,e=10*t,i=-30*t,s=i+e,n=s+40*t,a=s+10*t,r=15*t,o=10*t,h=n+40*t,l=3*t;if(Painter.shapes.fillCircle(0,i,e,this.headColor),Painter.shapes.strokeCircle(0,i,e,this.stroke,this.lineWidth),Painter.lines.line(0,s,0,n,this.stroke,this.lineWidth),Painter.lines.line(-r,a,r,a,this.stroke,this.lineWidth),Painter.lines.line(0,n,-o,h,this.stroke,this.lineWidth),Painter.lines.line(0,n,o,h,this.stroke,this.lineWidth),this.showJoints){[[0,s],[-r,a],[r,a],[0,n],[-o,h],[o,h]].forEach((([t,e])=>Painter.shapes.fillCircle(t,e,l,this.jointColor)))}}getBounds(){const t=100*this.scale,e=40*this.scale;return{x:this.x,y:this.y,width:e,height:t}}}class Ring extends Shape{constructor(t,e,i={}){super(i),this.outerRadius=t,this.innerRadius=e}draw(){super.draw(),Painter.lines.beginPath(),Painter.shapes.arc(0,0,this.outerRadius,0,2*Math.PI),Painter.shapes.arc(0,0,this.innerRadius,0,2*Math.PI,!0),Painter.lines.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}}class Polygon extends Shape{constructor(t=6,e=40,i={}){super(i),this.sides=t,this.radius=e}draw(){super.draw();const t=[],e=2*Math.PI/this.sides;for(let i=0;i<this.sides;i++){const s=i*e;t.push({x:Math.cos(s)*this.radius,y:Math.sin(s)*this.radius})}Painter.shapes.polygon(t,this.color,this.stroke,this.lineWidth)}}class Arrow extends Shape{constructor(t,e={}){super(e),this.length=t}draw(){super.draw();const t=this.width/2,e=.4*this.length,i=this.length-e;Painter.lines.beginPath(),Painter.lines.moveTo(-i/2,-t),Painter.lines.lineTo(i/2,-t),Painter.lines.lineTo(i/2,-this.width),Painter.lines.lineTo(this.length/2,0),Painter.lines.lineTo(i/2,this.width),Painter.lines.lineTo(i/2,t),Painter.lines.lineTo(-i/2,t),Painter.lines.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}}class Pin extends Shape{constructor(t=20,e={}){super(e),this.radius=t}draw(){super.draw();const t=this.radius,e=2.5*t;Painter.lines.beginPath(),Painter.shapes.arc(0,0,t,Math.PI,0),Painter.lines.lineTo(t,0),Painter.lines.lineTo(0,e),Painter.lines.lineTo(-t,0),Painter.lines.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}getBounds(){return{x:this.x,y:this.y+.98*this.radius,width:2*this.radius,height:2.5*this.radius}}}class PieSlice extends Shape{constructor(t,e,i,s={}){super(s),this.radius=t,this.startAngle=e,this.endAngle=i}draw(){super.draw(),Painter.lines.beginPath(),Painter.lines.moveTo(0,0),Painter.shapes.arc(0,0,this.radius,this.startAngle,this.endAngle),Painter.lines.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}}class Hexagon extends Shape{constructor(t,e={}){super(e),this.radius=t}draw(){super.draw();const t=Array.from({length:6},((t,e)=>{const i=Math.PI/3*e;return{x:Math.cos(i)*this.radius,y:Math.sin(i)*this.radius}}));Painter.shapes.polygon(t,this.color,this.stroke,this.lineWidth)}}class Heart extends Shape{constructor(t={}){super(t)}draw(){super.draw();const t=this.width,e=this.height,i=.3*e,s=Painter.lines;s.beginPath(),s.moveTo(0,i),s.bezierCurveTo(0,0,-t/2,0,-t/2,i),s.bezierCurveTo(-t/2,.8*e,0,e,0,e),s.bezierCurveTo(0,e,t/2,.8*e,t/2,i),s.bezierCurveTo(t/2,0,0,0,0,i),s.closePath(),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}getBounds(){return{x:this.x,y:this.y+this.height/2,width:this.width,height:this.height}}}class Cross extends Shape{constructor(t,e,i={}){super(i),this.size=t,this.thickness=e,this.diagonal=i.diagonal||!1}draw(){super.draw();const t=this.size/2,e=this.thickness/2;this.diagonal?(Painter.lines.beginPath(),Painter.lines.moveTo(-t,-t+e),Painter.lines.lineTo(-t+e,-t),Painter.lines.lineTo(0,-e),Painter.lines.lineTo(t-e,-t),Painter.lines.lineTo(t,-t+e),Painter.lines.lineTo(e,0),Painter.lines.lineTo(t,t-e),Painter.lines.lineTo(t-e,t),Painter.lines.lineTo(0,e),Painter.lines.lineTo(-t+e,t),Painter.lines.lineTo(-t,t-e),Painter.lines.lineTo(-e,0),Painter.lines.closePath()):(Painter.lines.beginPath(),Painter.lines.moveTo(-e,-t),Painter.lines.lineTo(e,-t),Painter.lines.lineTo(e,-e),Painter.lines.lineTo(t,-e),Painter.lines.lineTo(t,e),Painter.lines.lineTo(e,e),Painter.lines.lineTo(e,t),Painter.lines.lineTo(-e,t),Painter.lines.lineTo(-e,e),Painter.lines.lineTo(-t,e),Painter.lines.lineTo(-t,-e),Painter.lines.lineTo(-e,-e),Painter.lines.closePath()),this.color&&Painter.colors.fill(this.color),this.stroke&&Painter.colors.stroke(this.stroke,this.lineWidth)}}class TextShape extends Shape{constructor(t,e={}){super(e),this._text=t,this._font=e.font||"12px monospace",this._color=e.color||"yellow",this._align=e.align||"center",this._baseline=e.baseline||"middle",this._calculateBounds(),this._calculateAlignmentOffsets()}draw(){super.draw(),this.logger.log("draw",this.font,this.color,this.opacity),Painter.text.setFont(this.font),Painter.text.setTextAlign(this.align),Painter.text.setTextBaseline(this.baseline),Painter.text.fillText(this.text,0,0,this.color)}_calculateAlignmentOffsets(){if(!Painter.text)return;const t=Painter.text.measureTextDimensions(this.text,this.font);switch(this._align){case"left":this._centerOffsetX=t.width/2;break;case"center":this._centerOffsetX=0;break;case"right":this._centerOffsetX=-t.width/2-5}switch(this._baseline){case"top":this._centerOffsetY=t.height/4;break;case"middle":this._centerOffsetY=-2;break;case"bottom":this._centerOffsetY=-t.height}}getTextBounds(){if(Painter.text){const t=Painter.text.measureTextDimensions(this.text,this.font),e=2;return{x:this._centerOffsetX-t.width/2,y:this._centerOffsetY-t.height/2,width:t.width+2*e,height:t.height+2*e}}return{x:this._centerOffsetX,y:this._centerOffsetY,width:this._width,height:this._height}}_calculateBounds(){if(Painter.text){const t=Painter.text.measureTextDimensions(this.text,this.font);this._width=t.width,this._height=t.height,this._calculateAlignmentOffsets()}else this._width=this.text?8*this.text.length:0,this._height=16;this.trace("TextShape.calculateBounds: "+this._width+"x"+this._height)}getDebugBounds(){const t=this.getTextBounds();return{x:t.x,y:t.y,width:t.width,height:t.height}}checkDirty(t,e){t!==e&&(this._boundsDirty=!0,this._calculateBounds())}get text(){return this._text}set text(t){this.checkDirty(t,this._text),this._text=t}get font(){return this._font}set font(t){this.checkDirty(t,this._font),this._font=t}get color(){return this._color}set color(t){this._color=t}get align(){return this._align}set align(t){this.checkDirty(t,this._align),this._align=t}get baseline(){return this._baseline}set baseline(t){this.checkDirty(t,this._baseline),this._baseline=t}}class OutlinedText extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.text=i,this.centered=s.centered||!1,this.color=s.color||"#000000",this.stroke=s.stroke||"#FFFFFF",this.lineWidth=s.lineWidth||1,this.font=s.font||null,this.align=s.align||"left",this.baseline=s.baseline||"alphabetic",this.calculateDimensions()}calculateDimensions(){if(!Painter.ctx)return console.warn("Painter context not initialized. Cannot calculate text dimensions."),this.width=0,void(this.height=0);const t=Painter.text.font();this.font&&Painter.text.setFont(this.font);const e=Painter.text.measureText(this.text);if(this.width=e.width,this.font){const t=parseInt(this.font);this.height=isNaN(t)?20:t}else this.height=e.actualBoundingBoxAscent+e.actualBoundingBoxDescent||20;this.width+=2*this.lineWidth,this.height+=2*this.lineWidth,Painter.text.setFont(t)}setText(t){this.text=t,this.calculateDimensions()}draw(){if(super.draw(),!Painter.ctx)return void console.warn("Painter context not initialized. Cannot draw text.");let t=0;this.font&&Painter.text.setFont(this.font),Painter.text.setTextAlign(this.align),Painter.text.setTextBaseline(this.baseline),this.centered&&("middle"===this.baseline||"alphabetic"===this.baseline?t=0:"top"===this.baseline?t=this.height/2:"bottom"===this.baseline&&(t=-this.height/2)),Painter.outlinedText(this.text,0,t,this.color,this.stroke,this.lineWidth,this.font)}getBounds(){if(!Painter.ctx)return super.getBounds();const t=Painter.text.font();Painter.text.setFont(this.font);const e=Painter.text.measureText(this.text),i=e.width,s=e.actualBoundingBoxAscent+e.actualBoundingBoxDescent||parseInt(this.font)||20;return Painter.text.setFont(t),this.width=i,this.height=s,{x:this.x,y:this.y,width:i,height:s}}}class WrappedText extends Shape{constructor(t,e,i,s,n=20,a={}){super(t,e,a),this.text=i,this.maxWidth=s,this.lineHeight=n,this.centered=a.centered||!1,this.color=a.color||"#000000",this.font=a.font||null,this.align=a.align||"left",this.baseline=a.baseline||"top",this.outlineColor=a.outlineColor||null,this.outlineWidth=a.outlineWidth||1,this.calculateDimensions()}calculateDimensions(){if(!Painter.ctx)return console.warn("Painter context not initialized. Cannot calculate text dimensions."),this.width=this.maxWidth,this.height=this.lineHeight,void(this.lines=[this.text]);const t=Painter.text.font(),e=Painter.text.textAlign(),i=Painter.text.textBaseline();this.font&&Painter.text.setFont(this.font),Painter.text.setTextAlign("left"),Painter.text.setTextBaseline("top");const s=this.text.split(" ");let n="",a="";this.lines=[],this.width=0;for(let t=0;t<s.length;t++){a=n+s[t]+" ";Painter.text.measureText(a).width>this.maxWidth&&t>0?(this.lines.push(n),this.width=Math.max(this.width,Painter.text.measureText(n).width),n=s[t]+" "):n=a}this.lines.push(n),this.width=Math.max(this.width,Painter.text.measureText(n).width),this.height=this.lines.length*this.lineHeight,Painter.text.setFont(t),Painter.text.setTextAlign(e),Painter.text.setTextBaseline(i)}setText(t){this.text=t,this.calculateDimensions()}draw(){if(super.draw(),!Painter.ctx)return void console.warn("Painter context not initialized. Cannot draw text.");let t=0,e=0;this.centered&&(t=-this.width/2,e=-this.height/2),this.font&&Painter.text.setFont(this.font),Painter.text.setTextAlign(this.align),Painter.text.setTextBaseline(this.baseline);let i=t;"center"===this.align?i=0:"right"===this.align&&(i=t+this.width);for(let t=0;t<this.lines.length;t++){const s=e+t*this.lineHeight;this.outlineColor?Painter.outlinedText(this.lines[t],i,s,this.color,this.outlineColor,this.outlineWidth,this.font):Painter.text.fillText(this.lines[t],i,s,this.color,this.font)}}getBounds(){return this.centered?{x:this.x,y:this.y,width:this.width,height:this.height}:{x:this.x+this.width/2,y:this.y+this.height/2,width:this.width,height:this.height}}}class EventEmitter{constructor(){this.listeners={}}on(t,e){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e)}off(t,e){this.listeners[t]&&(this.listeners[t]=this.listeners[t].filter((t=>t!==e)))}emit(t,e){this.listeners[t]&&this.listeners[t].forEach((t=>t(e)))}}const _Input=class t{static init(e){t.game=e,t.x=0,t.y=0,t.down=!1,e.events.on("mousedown",t._onDown),e.events.on("mouseup",t._onUp),e.events.on("mousemove",t._onMove),e.events.on("touchstart",t._onTouchStart),e.events.on("touchend",t._onTouchEnd),e.events.on("touchmove",t._onTouchMove)}static _setPosition(e,i){t.x=e,t.y=i}};__publicField(_Input,"_onDown",(t=>{_Input.down=!0,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onUp",(t=>{_Input.down=!1,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onMove",(t=>{_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputmove",t)})),__publicField(_Input,"_onTouchStart",(t=>{const e=t.touches[0],i=_Input.game.canvas.getBoundingClientRect();_Input.down=!0,_Input._setPosition(e.clientX-i.left,e.clientY-i.top),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onTouchEnd",(t=>{_Input.down=!1,_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onTouchMove",(t=>{const e=t.touches[0],i=_Input.game.canvas.getBoundingClientRect();_Input._setPosition(e.clientX-i.left,e.clientY-i.top),_Input.game.events.emit("inputmove",t)}));let Input=_Input;const _Mouse=class t{static init(e){t.game=e,t.canvas=e.canvas,t.x=0,t.y=0,t.leftDown=!1,t.middleDown=!1,t.rightDown=!1,t.canvas.addEventListener("mousemove",t._onMove),t.canvas.addEventListener("mousedown",t._onDown),t.canvas.addEventListener("mouseup",t._onUp),t.canvas.addEventListener("click",t._onClick),t.canvas.addEventListener("wheel",t._onWheel)}static _updatePosition(e){const i=t.canvas.getBoundingClientRect();t.x=e.clientX-i.left,t.y=e.clientY-i.top}};__publicField(_Mouse,"_onMove",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("mousemove",t)})),__publicField(_Mouse,"_onDown",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!0),1===t.button&&(_Mouse.middleDown=!0),2===t.button&&(_Mouse.rightDown=!0),_Mouse.game.events.emit("mousedown",t)})),__publicField(_Mouse,"_onUp",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!1),1===t.button&&(_Mouse.middleDown=!1),2===t.button&&(_Mouse.rightDown=!1),_Mouse.game.events.emit("mouseup",t)})),__publicField(_Mouse,"_onClick",(t=>{_Mouse._updatePosition(t),t.canvasX=_Mouse.x,t.canvasY=_Mouse.y,Object.defineProperty(t,"x",{value:_Mouse.x,writable:!1}),Object.defineProperty(t,"y",{value:_Mouse.y,writable:!1}),_Mouse.game.events.emit("click",t)})),__publicField(_Mouse,"_onWheel",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("wheel",t)}));let Mouse=_Mouse;const _Keys=class t{static init(e){t.game=e,window.addEventListener("keydown",t._onKeyDown),window.addEventListener("keyup",t._onKeyUp)}static isDown(e){return t._down.has(e)}static _onKeyDown(e){const i=t._codeMap[e.code];i&&(t._down.has(i)||(t._down.add(i),t.game.events.emit(i,e))),t.game.events.emit(e.type,e)}static _onKeyUp(e){const i=t._codeMap[e.code];i&&t._down.has(i)&&(t._down.delete(i),t.game.events.emit(i+"_up",e)),t.game.events.emit(e.type,e)}};__publicField(_Keys,"W","W"),__publicField(_Keys,"A","A"),__publicField(_Keys,"S","S"),__publicField(_Keys,"D","D"),__publicField(_Keys,"UP","UP"),__publicField(_Keys,"DOWN","DOWN"),__publicField(_Keys,"LEFT","LEFT"),__publicField(_Keys,"RIGHT","RIGHT"),__publicField(_Keys,"SPACE","SPACE"),__publicField(_Keys,"SHIFT","SHIFT"),__publicField(_Keys,"ENTER","ENTER"),__publicField(_Keys,"ESC","ESC"),__publicField(_Keys,"_codeMap",{KeyW:_Keys.W,KeyA:_Keys.A,KeyS:_Keys.S,KeyD:_Keys.D,ArrowUp:_Keys.UP,ArrowDown:_Keys.DOWN,ArrowLeft:_Keys.LEFT,ArrowRight:_Keys.RIGHT,Space:_Keys.SPACE,ShiftLeft:_Keys.SHIFT,ShiftRight:_Keys.SHIFT,Enter:_Keys.ENTER,NumpadEnter:_Keys.ENTER,Escape:_Keys.ESC}),__publicField(_Keys,"_down",new Set),__publicField(_Keys,"game",null);let Keys=_Keys;const _Touch=class t{static init(e){t.game=e,t.canvas=e.canvas,t.x=0,t.y=0,t.active=!1,t.canvas.addEventListener("touchstart",t._onStart),t.canvas.addEventListener("touchend",t._onEnd),t.canvas.addEventListener("touchmove",t._onMove)}static _updatePosition(e){const i=t.canvas.getBoundingClientRect();t.x=e.clientX-i.left,t.y=e.clientY-i.top}};__publicField(_Touch,"_onStart",(t=>{t.touches.length>0&&(_Touch.active=!0,_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchstart",t))})),__publicField(_Touch,"_onEnd",(t=>{_Touch.active=!1,_Touch.game.events.emit("touchend",t)})),__publicField(_Touch,"_onMove",(t=>{t.touches.length>0&&(_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchmove",t))}));let Touch=_Touch;function applyAnchor(t,e={}){var i;if(!(t&&t instanceof GameObject))return console.warn("applyAnchor can only be applied to GameObject instances"),t;t._anchor={position:e.anchor??null,margin:e.anchorMargin??10,offsetX:e.anchorOffsetX??0,offsetY:e.anchorOffsetY??0,relative:e.anchorRelative??!1,setTextAlign:!1!==e.anchorSetTextAlign,lastUpdate:0};const s=null==(i=t.update)?void 0:i.bind(t);return t.update=function(e){const i=!0===t._anchor.relative&&t.parent?t.parent:t._anchor.relative;if(t._anchor.position&&(t.boundsDirty||i&&i.boundsDirty||t.parent&&t.parent.boundsDirty)){let e;if(i){const s={x:i.x,y:i.y,width:i.width,height:i.height};e=Position.calculate(t._anchor.position,t,s,t._anchor.margin,t._anchor.offsetX,t._anchor.offsetY)}else e=Position.calculateAbsolute(t._anchor.position,t,t.game,t._anchor.margin,t._anchor.offsetX,t._anchor.offsetY);!t.parent||(n=t).game&&n.game.pipeline&&n.game.pipeline.gameObjects&&n.game.pipeline.gameObjects.includes(n)?(t.x=e.x,t.y=e.y):i===t.parent?(t.x=e.x-i.x,t.y=e.y-i.y):(t.x=e.x-t.parent.x,t.y=e.y-t.parent.y),t._anchor.setTextAlign&&("align"in t&&(t.align=e.align),"baseline"in t&&(t.baseline=e.baseline)),t._anchor.lastUpdate=t.game?t.game.lastTime:Date.now()}var n;s&&s(e)},t}class GameObject extends Transformable{constructor(t,e={}){super(e),this.game=t,this.parent=null,this.events=new EventEmitter,this._interactive=e.interactive??!1,this._hovered=!1,e.anchor&&applyAnchor(this,e)}update(t){this.logger.groupCollapsed("GameObject.update: "+(null==this.name?this.constructor.name:this.name)),super.update(t),this.logger.groupEnd()}get interactive(){return this._interactive}set interactive(t){const e=Boolean(t);this._interactive!==e&&(this._interactive=e,!0===e?this._enableEvents():(this._disableEvents(),this._hovered&&(this._hovered=!1,this.events.emit("mouseout"))))}_enableEvents(){this.logger.log(`${this.constructor.name} is now interactive`)}_disableEvents(){this.logger.log(`${this.constructor.name} is no longer interactive`)}get hovered(){return this._hovered}set hovered(t){this._hovered=Boolean(t)}_setHovered(t){this._hovered=Boolean(t)}_hitTest(t,e){var i;if(!this._interactive)return!1;const s=null==(i=this.getBounds)?void 0:i.call(this);if(!s)return!1;let n=t,a=e;const r=[];let o=this;for(;o;)r.unshift(o),o=o.parent;for(const t of r){if(n-=t.x||0,a-=t.y||0,t.rotation){const e=Math.cos(-t.rotation),i=Math.sin(-t.rotation),s=n;n=s*e-a*i,a=s*i+a*e}void 0!==t.scaleX&&0!==t.scaleX&&(n/=t.scaleX),void 0!==t.scaleY&&0!==t.scaleY&&(a/=t.scaleY)}const h=(s.width||this.width||0)/2,l=(s.height||this.height||0)/2;return n>=-h&&n<=h&&a>=-l&&a<=l}on(t,e){this.events.on(t,e)}off(t,e){this.events.off(t,e)}emit(t,...e){this.events.emit(t,...e)}}function applyDraggable(t,e={}){const i=t.game;return t.dragging=!1,t.dragOffset={x:0,y:0},t._dragInputMoveHandler&&i.events.off("inputmove",t._dragInputMoveHandler),t._dragInputUpHandler&&i.events.off("inputup",t._dragInputUpHandler),"function"==typeof t.enableInteractivity?t.enableInteractivity(t):t.interactive=!0,t._dragInputDownHandler=i=>{t.dragging=!0,t.dragOffset.x=t.x-i.x,t.dragOffset.y=t.y-i.y,e.onDragStart&&e.onDragStart()},t._dragInputMoveHandler=e=>{t.dragging&&(t.x=e.x+t.dragOffset.x,t.y=e.y+t.dragOffset.y)},t._dragInputUpHandler=i=>{t.dragging&&(t.dragging=!1,e.onDragEnd&&e.onDragEnd())},t.on("inputdown",t._dragInputDownHandler),i.events.on("inputmove",t._dragInputMoveHandler),i.events.on("inputup",t._dragInputUpHandler),()=>{t.off("inputdown",t._dragInputDownHandler),i.events.off("inputmove",t._dragInputMoveHandler),i.events.off("inputup",t._dragInputUpHandler),delete t._dragInputDownHandler,delete t._dragInputMoveHandler,delete t._dragInputUpHandler,delete t.dragging,delete t.dragOffset}}class ShapeGOFactory{static create(t,e,i={}){const s={x:(null==e?void 0:e.x)??0,y:(null==e?void 0:e.y)??0,width:(null==e?void 0:e.width)??0,height:(null==e?void 0:e.height)??0,rotation:(null==e?void 0:e.rotation)??0,scaleX:(null==e?void 0:e.scaleX)??1,scaleY:(null==e?void 0:e.scaleY)??1,opacity:(null==e?void 0:e.opacity)??1,visible:(null==e?void 0:e.visible)??!0,active:!0,debug:(null==e?void 0:e.debug)??!1,color:(null==e?void 0:e.color)??null,stroke:(null==e?void 0:e.stroke)??null,lineWidth:(null==e?void 0:e.lineWidth)??1,lineJoin:(null==e?void 0:e.lineJoin)??"miter",lineCap:(null==e?void 0:e.lineCap)??"butt",miterLimit:(null==e?void 0:e.miterLimit)??10,...i,name:i.name??(null==e?void 0:e.constructor.name)??"ShapeWrapper"};return new GameObjectShapeWrapper(t,e,s)}}class GameObjectShapeWrapper extends GameObject{constructor(t,e,i={}){if(super(t,i),!e||null==e||null==e)throw new Error("GameObjectShapeWrapper requires a shape");this.shape=e,void 0!==i.color&&(e.color=i.color),void 0!==i.stroke&&(e.stroke=i.stroke),void 0!==i.lineWidth&&(e.lineWidth=i.lineWidth),void 0!==i.lineJoin&&(e.lineJoin=i.lineJoin),void 0!==i.lineCap&&(e.lineCap=i.lineCap),void 0!==i.miterLimit&&(e.miterLimit=i.miterLimit),this.syncPropertiesToShape(),this.logger.log(`Created GameObject(${this.constructor.name}):`,{x:this.x,y:this.y,width:this.width,height:this.height,color:this.color,stroke:this.stroke})}syncPropertiesToShape(){if(!this.shape)return;const t=["width","height","rotation","scaleX","scaleY","visible","debug","debugColor"];for(const e of t)e in this&&e in this.shape&&this[e]!==this.shape[e]&&(this.shape[e]=this[e])}get color(){return this.shape?this.shape.color:null}set color(t){this.shape&&(this.shape.color=t)}get stroke(){return this.shape?this.shape.stroke:null}set stroke(t){this.shape&&(this.shape.stroke=t)}get lineWidth(){return this.shape?this.shape.lineWidth:1}set lineWidth(t){this.shape&&(this.shape.lineWidth=t)}get lineJoin(){return this.shape?this.shape.lineJoin:"miter"}set lineJoin(t){this.shape&&(this.shape.lineJoin=t)}get lineCap(){return this.shape?this.shape.lineCap:"butt"}set lineCap(t){this.shape&&(this.shape.lineCap=t)}get miterLimit(){return this.shape?this.shape.miterLimit:10}set miterLimit(t){this.shape&&(this.shape.miterLimit=t)}update(t){var e;this.active&&(null==(e=this.onUpdate)||e.call(this,t),(this._boundsDirty||this.tweening)&&(this.syncPropertiesToShape(),this._boundsDirty=!1),super.update(t))}draw(){super.draw(),this.shape.render()}}class Scene extends GameObject{constructor(t,e={}){super(t,e),this._collection=new ZOrderedCollection({sortByZIndex:e.sortByZIndex||!0}),this._collection._owner=this,this._width=e.width??0,this._height=e.height??0,this.forceWidth=null,this.forceHeight=null,this._naturalWidth=null,this._naturalHeight=null,this.userDefinedDimensions=!1,null!=e.width&&null!=e.height&&(this.userDefinedWidth=e.width,this.userDefinedHeight=e.height,this.userDefinedDimensions=!0)}update(t){this.logger.groupCollapsed("Scene.update: "+(null==this.name?this.constructor.name:this.name));for(let e=0;e<this.children.length;e++){const i=this.children[e];i.active&&i.update&&i.update(t)}super.update(t),this.logger.groupEnd()}add(t){if(null==t||null==t)throw new Error("GameObject is null or undefined");return null!=t.parent&&console.warn("This GameObject already has a parent. Consider removing it first."),t.parent=this,this._collection.add(t),this.markBoundsDirty(),t.init&&t.init(),t}markBoundsDirty(){super.markBoundsDirty(),this.children.forEach((t=>{t.markBoundsDirty()}))}remove(t){const e=this._collection.remove(t);return e&&(t.parent=null,this.markBoundsDirty()),e}draw(){super.draw(),this.logger.log("Scene.draw chilren:"),this._collection.getSortedChildren().filter((t=>t.visible)).map((function(t){return Painter.save(),t.render(),Painter.restore(),t}))}getDebugBounds(){return{width:this.width,height:this.height,x:-this.width/2,y:-this.height/2}}bringToFront(t){return this._collection.bringToFront(t)}sendToBack(t){return this._collection.sendToBack(t)}bringForward(t){return this._collection.bringForward(t)}sendBackward(t){return this._collection.sendBackward(t)}clear(){return this._collection.children.forEach((t=>this.remove(t))),this._collection.clear()}get children(){return this._collection.children}}class LayoutScene extends Scene{constructor(t,e={}){super(t,e),this.spacing=e.spacing??10,this.padding=e.padding??0,this.autoSize=e.autoSize??!0,this.align=e.align??"start",this.debug=e.debug??!1,this._layoutDirty=!0}calculateLayout(){throw new Error("Subclasses must implement calculateLayout()")}update(t){if(this._boundsDirty||this._layoutDirty){const t=this.width,e=this.height,i=this.calculateLayout();this.autoSize&&i&&(Math.abs(this.width-i.width)>.1&&(this.width=i.width),Math.abs(this.height-i.height)>.1&&(this.height=i.height)),i&&i.positions&&this.applyPositionsToChildren(i.positions),this._boundsDirty=!1,this._layoutDirty=!1,t===this.width&&e===this.height||this._updatingBoundsFromLayout||(this._updatingBoundsFromLayout=!0,Scene.prototype.markBoundsDirty.call(this),this._updatingBoundsFromLayout=!1)}super.update(t)}markBoundsDirty(){this._updatingBoundsFromLayout?this._boundsDirty=!0:(super.markBoundsDirty(),this._layoutDirty=!0)}applyPositionsToChildren(t){applyLayout(this.children,t,this.getLayoutOffset())}getLayoutOffset(){return{offsetX:0,offsetY:0}}add(t){const e=super.add(t);return this._layoutDirty=!0,e}remove(t){const e=super.remove(t);return this._layoutDirty=!0,e}}class HorizontalLayout extends LayoutScene{calculateLayout(){return horizontalLayout(this.children,{spacing:this.spacing,padding:this.padding,align:this.align,centerItems:!0})}getLayoutOffset(){return{offsetX:-this.width/2,offsetY:0}}}class VerticalLayout extends LayoutScene{calculateLayout(){return verticalLayout(this.children,{spacing:this.spacing,padding:this.padding,align:this.align,centerItems:!0})}getLayoutOffset(){return{offsetX:0,offsetY:-this.height/2}}}class TileLayout extends LayoutScene{constructor(t,e={}){super(t,e),this.columns=e.columns??4}calculateLayout(){return this.children.length?tileLayout(this.children,{columns:this.columns,spacing:this.spacing,padding:this.padding,centerItems:!0}):null}getLayoutOffset(){return{offsetX:-this.width/2,offsetY:-this.height/2}}}class GridLayout extends LayoutScene{constructor(t,e={}){super(t,e),this.columns=e.columns??4,this.debug=e.debug??!1}calculateLayout(){return this.children.length?gridLayout(this.children,{columns:this.columns,spacing:this.spacing,padding:this.padding,centerItems:this.centerItems,width:this.autoSize?void 0:this.width,height:this.autoSize?void 0:this.height}):null}getLayoutOffset(){return{offsetX:-this.width/2,offsetY:-this.height/2}}}class Text extends GameObjectShapeWrapper{constructor(t,e,i={}){super(t,new TextShape(e,{font:i.font||"16px monospace",color:i.color||"yellow",align:i.align||"left",baseline:i.baseline||"top",strokeColor:i.strokeColor||"#000",lineWidth:i.lineWidth||1,debugColor:i.debugColor||"yellow"}),i),this._textOptions={font:i.font||"16px monospace",color:i.color||"yellow",align:i.align||"left",baseline:i.baseline||"top"}}get text(){return this.shape.text}set text(t){this.shape.text=t,this.markBoundsDirty()}get font(){return this.shape.font}set font(t){this.shape.font=t,this._textOptions.font=t,this.markBoundsDirty()}get color(){return this.shape.color}set color(t){this.shape.color=t,this._textOptions.color=t}get align(){return this.shape.align}set align(t){this.shape.align=t,this._textOptions.align=t,this.markBoundsDirty()}get baseline(){return this.shape.baseline}set baseline(t){this.shape.baseline=t,this._textOptions.baseline=t,this.markBoundsDirty()}measureWidth(){if(!Painter.ctx)return 0;return Painter.text.measureTextWidth(this.text,this.font)}measureHeight(){if(!this.font)return 16;const t=parseInt(this.font);return isNaN(t)?16:t}getBounds(){const t=super.getBounds();if(this.shape.getTextBounds){const t=this.shape.getTextBounds();return{x:this.x,y:this.y,width:t.width,height:t.height}}return t}update(t){super.update(t),this.shape&&(this.width=this.shape.width||this.measureWidth(),this.height=this.shape.height||this.measureHeight())}}class ImageShape extends Shape{constructor(t,e={}){if(!t&&!e.width&&!e.height)throw new Error("ImageShape must be initialized with either a bitmap or width and height");super(e),this._bitmap=t??Painter.img.createImageData(e.width,e.height),this._width=e.width??(null==t?void 0:t.width)??0,this._height=e.height??(null==t?void 0:t.height)??0,this.anchor=e.anchor??"center",this._anchorX=.5,this._anchorY=.5,this._updateAnchorOffsets(),this.smoothing=!1!==e.smoothing,t instanceof ImageData&&this.buffer(t)}_updateAnchorOffsets(){var t;const e=(null==(t=this.anchor)?void 0:t.toLowerCase())??"center";e.includes("left")?this._anchorX=0:e.includes("right")?this._anchorX=1:this._anchorX=.5,e.includes("top")?this._anchorY=0:e.includes("bottom")?this._anchorY=1:this._anchorY=.5}get bitmap(){return this._bitmap}set bitmap(t){t&&(this._bitmap=t,!this._width&&t.width&&(this._width=t.width),!this._height&&t.height&&(this._height=t.height),t instanceof ImageData&&this.buffer(t))}buffer(t){if(!t)return;this._buffer||(this._buffer=document.createElement("canvas")),this._buffer.width===t.width&&this._buffer.height===t.height||(this._buffer.width=t.width,this._buffer.height=t.height);this._buffer.getContext("2d").putImageData(t,0,0)}reset(){this._buffer=null,this._bitmap=Painter.img.createImageData(this.width,this.height)}setAnchor(t){this.anchor=t,this._updateAnchorOffsets()}draw(){if(!this.visible)return;if(!this._bitmap&&!this._buffer)return;super.draw();let t=this._bitmap instanceof ImageData?this._buffer:this._bitmap;(!t||this._bitmap instanceof ImageData&&!this._buffer)&&(this._bitmap instanceof ImageData&&(this.buffer(this._bitmap),t=this._buffer),!t)||Painter.img.draw(t,0,0,{width:this.width,height:this.height,anchor:this.anchor,rotation:this.rotation,scaleX:this.scaleX,scaleY:this.scaleY,alpha:this.opacity,smoothing:this.smoothing,flipX:this.scaleX<0,flipY:this.scaleY<0})}calculateBounds(){return{x:-this._anchorX*this.width,y:-this._anchorY*this.height,width:this.width,height:this.height}}}class ImageGo extends GameObjectShapeWrapper{constructor(t,e,i={}){super(t,e instanceof ImageShape?e:new ImageShape(e,i),i)}reset(){this.shape.reset()}}class Tween{static lerp(t,e,i){return t+(e-t)*i}static lerpAngle(t,e,i){let s=e-t;for(;s<-Math.PI;)s+=2*Math.PI;for(;s>Math.PI;)s-=2*Math.PI;return t+s*i}static tweenColor(t,e,i){return t.map(((t,s)=>Tween.lerp(t,e[s],i)))}static tweenGradient(t,e,i){let s=t[0],n=e[0];Math.abs(n-s)>180&&(s<n?s+=360:n+=360);return[Tween.lerp(s,n,i)%360,Tween.lerp(t[1],e[1],i),Tween.lerp(t[2],e[2],i)]}}class Easing{static linear(t){return t}static smoothstep(t){return t*t*(3-2*t)}static smootherstep(t){return t*t*t*(t*(6*t-15)+10)}static easeInQuad(t){return t*t}static easeOutQuad(t){return t*(2-t)}static easeInOutQuad(t){return t<.5?2*t*t:(4-2*t)*t-1}static easeInCubic(t){return t*t*t}static easeOutCubic(t){return--t*t*t+1}static easeInOutCubic(t){return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1}static easeInQuart(t){return t*t*t*t}static easeOutQuart(t){return 1- --t*t*t*t}static easeInOutQuart(t){return t<.5?8*t*t*t*t:1-8*--t*t*t*t}static easeInSine(t){return 1-Math.cos(t*Math.PI/2)}static easeOutSine(t){return Math.sin(t*Math.PI/2)}static easeInOutSine(t){return-(Math.cos(Math.PI*t)-1)/2}static easeInExpo(t){return 0===t?0:Math.pow(2,10*(t-1))}static easeOutExpo(t){return 1===t?1:1-Math.pow(2,-10*t)}static easeInOutExpo(t){return 0===t||1===t?t:t<.5?.5*Math.pow(2,20*t-10):.5*(2-Math.pow(2,-20*t+10))}static easeInCirc(t){return 1-Math.sqrt(1-t*t)}static easeOutCirc(t){return Math.sqrt(1- --t*t)}static easeInOutCirc(t){return t<.5?.5*(1-Math.sqrt(1-4*t*t)):.5*(Math.sqrt(-(2*t-3)*(2*t-1))+1)}static easeInElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return-e*Math.pow(2,10*(t-1))*Math.sin((t-1-s)*(2*Math.PI)/i)}static easeOutElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return e*Math.pow(2,-10*t)*Math.sin((t-s)*(2*Math.PI)/i)+1}static easeInOutElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return t<.5?e*Math.pow(2,10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/i)*-.5:e*Math.pow(2,-10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/i)*.5+1}static easeInBack(t,e=1.70158){return t*t*((e+1)*t-e)}static easeOutBack(t,e=1.70158){return--t*t*((e+1)*t+e)+1}static easeInOutBack(t,e=1.70158){const i=1.525*e;return t<.5?2*t*.5*(2*t)*(2*(i+1)*t-i):.5*((2*t-2)*(2*t-2)*((i+1)*(2*t-2)+i)+2)}static easeOutBounce(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}static easeInBounce(t){return 1-Easing.easeOutBounce(1-t)}static easeInOutBounce(t){return t<.5?.5*Easing.easeInBounce(2*t):.5*Easing.easeOutBounce(2*t-1)+.5}}function bounceV1(t,e,i,s,n,a=!1,r=null,o={},h=null){const{t:l,easedT:c,completed:_,state:u}=Motion._frame(s,n,a,r,o,h),d=1/(i+1),p=Math.min(Math.floor(c/d),i),g=c%d/d,f=t*Math.pow(.6,p),m=e-Math.sin(g*Math.PI)*(e-f);return Motion.animationResult({y:m,segment:p,bounceHeight:f},l,a,_,u)}function floatV1(t,e,i,s,n,a,r=!0,o=null,h={},l=null){if(i<=0)return Motion.animationResult({x:t.x,y:t.y,moving:!1},1,!1,!0);l||(l={initialX:t.x,initialY:t.y,started:!1,completed:!1,loopCount:0});const c=l.initialX,_=l.initialY,{t:u,easedT:d,completed:p,state:g}=Motion._frame(e,i,r,o,h,l);l={...l,...g};const f=e*s,m=Math.max(0,Math.min(1,n)),v=c+(Math.sin(.7*f)+.4*m*Math.sin(2.3*f+.5))*a,y=_+(Math.cos(.9*f)+.4*m*Math.cos(1.9*f+.7))*a,x=.7*Math.cos(.7*f)+.4*m*2.3*Math.cos(2.3*f+.5),w=-.9*Math.sin(.9*f)+.4*m*-1.9*Math.sin(1.9*f+.7),M=Math.sqrt(x*x+w*w),b=M>.8,P=Math.sqrt((v-c)*(v-c)+(y-_)*(y-_));return Motion.animationResult({x:v,y:y,centerX:c,centerY:_,offsetX:v-c,offsetY:y-_,distance:P,moving:b,velocity:M},u,r,p,l)}function followPath(t,e=!1,i,s,n=!1,a=null,r={},o=null){if(!t||t.length<2)return this._createResult({x:0,y:0},0,n,!1);const{t:h,easedT:l,completed:c,state:_}=Motion._frame(i,s,n,a,r,o);if(!o||!o.pathData){const i={segmentLengths:[],totalLength:0,points:[...t]};for(let e=0;e<t.length-1;e++){const s=t[e],n=t[e+1],a=n[0]-s[0],r=n[1]-s[1],o=Math.sqrt(a*a+r*r);i.segmentLengths.push(o),i.totalLength+=o}if(e){const e=t[t.length-1],s=t[0],n=s[0]-e[0],a=s[1]-e[1],r=Math.sqrt(n*n+a*a);i.segmentLengths.push(r),i.totalLength+=r}_.pathData=i}const{segmentLengths:u,totalLength:d,points:p}=_.pathData,g=l*d;let f=0,m=0;for(let t=0;t<u.length;t++){if(f+u[t]>=g){m=t;break}f+=u[t]}const v=(g-f)/u[m],y=p[m],x=m<p.length-1?p[m+1]:p[0],w=Tween.lerp(y[0],x[0],v),M=Tween.lerp(y[1],x[1],v),b=Math.atan2(x[1]-y[1],x[0]-y[0]);return Motion.animationResult({x:w,y:M,angle:b,segmentIndex:m,segmentProgress:v,pathProgress:l},h,n,c,_)}function orbitV1(t,e,i,s,n,a,r,o=!0,h=!0,l=null,c={},_=null){const{t:u,easedT:d,completed:p,state:g}=Motion._frame(a,r,o,l,c,_),f=n+(h?1:-1)*d*Math.PI*2,m=t+i*Math.cos(f),v=e+s*Math.sin(f);return Motion.animationResult({x:m,y:v,angle:f},u,o,p,g)}function oscillateV1(t,e,i,s,n=!0,a=null,r={},o=null){const{t:h,easedT:l,completed:c,state:_}=Motion._frame(i,s,n,a,r,o),u=(e-t)/2,d=t+u+u*Math.sin(l*Math.PI*2);return Motion.animationResult({value:d},h,n,c,_)}function parabolicV1(t,e,i,s,n,a=!1,r=!1,o=null,h={},l=null){l||(l={started:!1,loopCount:0,direction:1,lastDirection:1,completed:!1});let c=n>0?s/n:1,_=!1,u={...h};if(r||a)if(a)if(r){const t=2*n,e=s%t,i=Math.floor(s/t),a=e<n?1:-1;c=1===a?e/n:2-e/n,a!==l.direction&&(l.direction=a,1===l.direction&&u.onLoop&&u.onLoop(i)),i>l.loopCount&&(l.loopCount=i)}else{c%=1;const t=Math.floor(s/n);t>l.loopCount&&u.onLoop&&(u.onLoop(t),l.loopCount=t)}else r&&!a&&(c<=1?l.direction=1:c<=2?(c=2-c,l.direction=-1):(c=0,_=!0,l.direction=1));else c>=1&&(c=1,_=!0);!l.started&&u.onStart&&(u.onStart(),l.started=!0),_&&!l.completed&&u.onComplete&&(u.onComplete(),l.completed=!0);const d=o?o(c):c,p=(t+i-2*e)*d*d+2*(e-t)*d+t,g={...l,lastDirection:l.direction,completed:_||l.completed};return Motion.animationResult({value:p,direction:l.direction},c,a||r&&!_,_,g)}function patrolV1(t,e,i,s,n,a,r=!0,o=null){o||(o={currentX:t,currentY:e,targetX:t,targetY:e,isWaiting:!0,waitStartTime:0,moveStartTime:0,moveCount:0,direction:"idle"});const h=()=>Math.random();let l=o.isWaiting,c=o.currentX,_=o.currentY,u=o.direction;if(l){if(i-o.waitStartTime>=n){l=!1,o.moveStartTime=i;u=["up","down","left","right"][Math.floor(4*h())];let s=o.currentX,n=o.currentY;const r=a*(.2+.6*h());switch(u){case"up":n=o.currentY-r;break;case"down":n=o.currentY+r;break;case"left":s=o.currentX-r;break;case"right":s=o.currentX+r}Math.pow(s-t,2)+Math.pow(n-e,2)>a*a&&("up"===u||"down"===u?(n=e,u=o.currentY>e?"up":"down"):(s=t,u=o.currentX>t?"left":"right")),o.targetX=s,o.targetY=n,o.direction=u,o.moveCount++}}else{const t=(i-o.moveStartTime)/s;t>=1?(l=!0,o.waitStartTime=i,o.currentX=o.targetX,o.currentY=o.targetY,u="idle"):(c=o.currentX+(o.targetX-o.currentX)*t,_=o.currentY+(o.targetY-o.currentY)*t)}o.isWaiting=l,o.direction=u,l||(o.currentX=c,o.currentY=_);const d=s+n,p=i%d/d,g=Math.sqrt(Math.pow(c-t,2)+Math.pow(_-e,2));return Motion.animationResult({x:c,y:_,moving:!l,direction:u,distanceFromCenter:g},p,r,!1,o)}function pendulumV1(t,e,i,s,n=!0,a=!1,r=null,o={},h=null){const{t:l,easedT:c,completed:_,state:u}=Motion._frame(i,s,n,null,o,h),d=a&&!n?Math.exp(-4*l):1;let p=t+e*Math.cos(2*c*Math.PI)*d;if(r){p=t+r(((p-t)/(e*d)+1)/2)*e*d*2-e*d}return Motion.animationResult({angle:p},l,n,_,u)}function pulseV1(t,e,i,s,n=!0,a=!1,r=null,o={}){let h,l=i/s,c="forward";if(n){const t=Math.floor(l);l%=1,t>0&&o.onLoop&&o.onLoop(t)}else l>1&&(l=1);if(l>0&&i<=s&&o.onStart&&o.onStart(),a)if(l<.5){const i=2*l;h=t+(e-t)*(r?r(i):i),c="forward"}else{const i=2*(l-.5);h=e-(e-t)*(r?r(i):i),c="return",l>=.5&&l<.51&&o.onYoyoTurn&&o.onYoyoTurn()}else{const i=r?r(l):l;h=t+(e-t)*(i<.5?2*i:2-2*i)}const _=!n&&l>=1;return _&&o.onComplete&&o.onComplete(),Motion.animationResult({value:h,phase:c},l,n,_)}function hopV1(t,e,i,s,n=!0,a=!0,r=null,o={},h=null){const{t:l,easedT:c,completed:_,state:u}=Motion._frame(i,s,n,r,o,h,a);let d=0;d=n||a?a?Math.sin(c*Math.PI):Math.sin(Math.min(l,1)*Math.PI*.5):_?1:Math.sin(Math.min(l,1)*Math.PI*.5);const p=t-e*d;return Motion.animationResult({y:p},l,n,_,u)}function shakeV1(t,e,i,s,n,a,r,o,h=!1,l=null,c={},_=null){const{t:u,easedT:d,completed:p,state:g}=Motion._frame(r,o,h,l,c,_),f=Math.pow(1-d,a),m=d*Math.PI*2*n,v=d*Math.PI*2*n*1.3,y=f*i*(.6*Math.sin(m)+.3*Math.sin(2.5*m)+.1*Math.sin(5.6*m)),x=f*s*(.6*Math.cos(v)+.3*Math.cos(2.7*v)+.1*Math.cos(6.3*v));let w=t+y,M=e+x;if(d>.9){const i=(d-.9)/.1;w=t+y*(1-i),M=e+x*(1-i)}return Motion.animationResult({x:w,y:M,intensity:f},u,h,p,g)}function spiralV1(t,e,i,s,n,a,r,o,h=!1,l=!1,c=null,_={},u=null){u||(u={started:!1,loopCount:0,direction:1,lastDirection:1});let d=o>0?r/o:1,p=!1,g={..._};if(l||h)if(h)if(l){const t=2*o,e=r%t,i=Math.floor(r/t),s=e<o?1:-1;d=1===s?e/o:2-e/o,s!==u.direction&&(u.direction=s,1===u.direction&&g.onLoop&&g.onLoop(i)),i>u.loopCount&&(u.loopCount=i)}else{d%=1;const t=Math.floor(r/o);t>u.loopCount&&g.onLoop&&(g.onLoop(t),u.loopCount=t)}else l&&!h&&(d<=1?u.direction=1:d<=2?(d=2-d,u.direction=-1):(d=0,p=!0,u.direction=1));else d>=1&&(d=1,p=!0);!u.started&&g.onStart&&(g.onStart(),u.started=!0),p&&!u.completed&&g.onComplete&&(g.onComplete(),u.completed=!0);const f=c?c(d):d,m=Tween.lerp(i,s,f),v=n+f*a*Math.PI*2,y=t+m*Math.cos(v),x=e+m*Math.sin(v),w={...u,lastDirection:u.direction};return Motion.animationResult({x:y,y:x,radius:m,angle:v,direction:u.direction},d,h||l&&!p,p,w)}function springV1(t,e,i,s,n=!1,a=!1,r={},o={}){if(s<=0)return this.animationResult({value:e,velocity:0,done:!0,phase:"complete"},1,!1,!0);let h,l,c,_=i/s,u="forward",d=0;n?(d=Math.floor(_),_%=1,d>0&&o.onLoop&&o.onLoop(d)):_>1&&(_=1),_>0&&i<=s&&o.onStart&&o.onStart(),a?_>=.5?(h=t,l=e,c=2*(_-.5),u="return",_>=.5&&_<.51&&o.onYoyoTurn&&o.onYoyoTurn()):(h=e,l=t,c=2*_,u="forward"):(h=e,l=t,c=_);const p=void 0!==r.stiffness?r.stiffness:.3,g=void 0!==r.damping?r.damping:.6,f=Math.max(.1,1/(1.5*g)),m=Math.max(.1,.8/(1.5*p+.5));let v;if(c<.99)v=Easing.easeOutElastic(c,f,m);else{const t=(c-.99)/.01;v=Easing.easeOutElastic(.99,f,m)*(1-t)+1*t}const y=Tween.lerp(l,h,v),x=Math.min(c+.01,1);let w;if(x<.99)w=Easing.easeOutElastic(x,f,m);else{const t=(x-.99)/.01;w=Easing.easeOutElastic(.99,f,m)*(1-t)+1*t}const M=(Tween.lerp(l,h,w)-y)/.01*s,b=!n&&_>=1;return b&&o.onComplete&&o.onComplete(),Motion.animationResult({value:y,velocity:M,delta:"forward"===u?e-y:t-y,done:b,phase:u},_,n,b)}function swingV1(t,e,i,s,n,a=!0,r=!0,o=null,h={},l=null){const{t:c,easedT:_,completed:u,state:d}=Motion._frame(s,n,a,o,h,l),p=(r?Math.sin(_*Math.PI*2):Math.sin(_*Math.PI))*i;return Motion.animationResult({angle:p},c,a,u,d)}function waypointV1(t,e,i,s,n,a=!0,r={},o=null){if(!i||!Array.isArray(i)||i.length<2)return console.warn("Patrol animation requires at least 2 waypoints"),Motion._createResult({x:0,y:0,moving:!1,direction:"idle",waypoint:0},0,!1,!0);o||(o={currentWaypoint:0,nextWaypoint:1,isWaiting:!0,waitStartTime:0,lastWaypointTime:0,lastWaypointReached:-1,completed:!1});let h=0;for(let t=0;t<i.length;t++){const e=(t+1)%i.length;if(!a&&t===i.length-1)break;const s=i[e][0]-i[t][0],n=i[e][1]-i[t][1];h+=Math.abs(s)+Math.abs(n)}const l=h/s+n*i.length;let c=e;c=a?e%l:Math.min(e,l);const _=c/l;let u,d,p,g=c,f=0,m=1,v=!0,y=0,x=0,w=!1;if(g<n)y=g/n,f=0,m=1,v=!0;else{g-=n;for(let t=0;t<i.length;t++){if(!a&&t===i.length-1){f=t,m=t,v=!0,y=1,w=!0;break}const e=(t+1)%i.length,h=i[e][0]-i[t][0],l=i[e][1]-i[t][1],c=(Math.abs(h)+Math.abs(l))/s;if(g<c){f=t,m=e,v=!1,x=g/c;break}if(g-=c,g<n){f=e,m=(e+1)%i.length,v=!0,y=g/n,o.lastWaypointReached!==f&&(r.onWaypointReached&&r.onWaypointReached(f),r.onWaitStart&&r.onWaitStart(f),o.lastWaypointReached=f);break}g-=n}}if(v||w)u=i[f][0],d=i[f][1],p="idle",!o.isWaiting&&v&&r.onWaitEnd&&r.onWaitEnd(f);else{const t=i[f],e=i[m],s=e[0]-t[0],n=e[1]-t[1],a=Math.abs(s)+Math.abs(n),r=Math.abs(s)/a;if(x<=r&&0!==s){const e=x/r;u=t[0]+s*e,d=t[1],p=s>0?"right":"left"}else{const i=(x-r)/(1-r);u=e[0],d=t[1]+n*i,p=n>0?"down":"up"}}return o.currentWaypoint=f,o.nextWaypoint=m,o.isWaiting=v,!o.completed&&w&&r.onPatrolComplete&&(r.onPatrolComplete(),o.completed=!0),Motion.animationResult({x:u,y:d,moving:!v,waiting:v,waitProgress:v?y:0,direction:p,waypoint:f,nextWaypoint:m},_,a,w,o)}class Motion{static animationResult(t,e,i,s=!1,n=null){return{...t,t:e,progress:e,loop:i,completed:s,state:n}}static _step(t,e,i,s={},n={started:!1,loopCount:0}){let a=e>0?t/e:1,r=!1;if(!(n=n||{started:!1,loopCount:0}).started&&s.onStart&&(s.onStart(),n.started=!0),i){a%=1;const i=Math.floor(t/e);i>n.loopCount&&s.onLoop&&(s.onLoop(i),n.loopCount=i)}else a>=1&&(a=1,r=!0,!n.completed&&s.onComplete&&(s.onComplete(),n.completed=!0));return{t:a,completed:r,state:n}}static _frame(t,e,i,s=null,n={},a=null){const{t:r,completed:o,state:h}=this._step(t,e,i,n,a);return{t:r,easedT:s?s(r):r,completed:o,state:h}}static oscillate(t,e,i,s,n=!0,a=null,r={},o=null){return oscillateV1(t,e,i,s,n,a,r,o)}static parabolic(t,e,i,s,n,a=!1,r=!1,o=null,h={},l=null){return parabolicV1(t,e,i,s,n,a,r,o,h,l)}static float(t,e,i,s,n,a,r=!0,o=null,h={},l=null){return floatV1(t,e,i,s,n,a,r,o,h,l)}static spring(t,e,i,s,n=!1,a=!1,r={},o={}){return springV1(t,e,i,s,n,a,r,o)}static swing(t,e,i,s,n,a=!0,r=!0,o=null,h={},l=null){return swingV1(t,e,i,s,n,a,r,o,h,l)}static pendulum(t,e,i,s,n=!0,a=!1,r=null,o={},h=null){return pendulumV1(t,e,i,s,n,a,r,o,h)}static pulse(t,e,i,s,n=!0,a=!1,r=null,o={}){return pulseV1(t,e,i,s,n,a,r,{})}static spiral(t,e,i,s,n,a,r,o,h=!1,l=!1,c=null,_={},u=null){return spiralV1(t,e,i,s,n,a,r,o,h,l,c,_,u)}static orbit(t,e,i,s,n,a,r,o=!0,h=!0,l=null,c={},_=null){return orbitV1(t,e,i,s,n,a,r,o,h,l,c,_)}static bezier(t,e,i,s,n,a,r=!1,o=!1,h=null,l={},c=null){return bezierV1(t,e,i,s,n,a,r,o,h,l,c)}static bounce(t,e,i,s,n,a=!1,r=null,o={},h=null){return bounceV1(t,e,i,s,n,a,r,o,h)}static shake(t,e,i,s,n,a,r,o,h=!1,l=null,c={},_=null){return shakeV1(t,e,i,s,n,a,r,o,h,l,c,_)}static follow(t,e=!1,i,s,n=!1,a=null,r={},o=null){return followPath(t,e,i,s,n,a,r,o)}static waypoint(t,e,i,s,n,a=!0,r={},o=null){return waypointV1(t,e,i,s,n,a,r,o)}static patrol(t,e,i,s,n,a,r=!0,o=null){return patrolV1(t,e,i,s,n,a,r,o)}static hop(t,e,i,s,n=!0,a=!0,r=null,o={},h=null){return hopV1(t,e,i,s,n,a,r,o,h)}static group(t,e,i,s,n=!1,a=null,r={},o=null){o||(o={started:!1,loopCount:0,animationStates:Array(t.length).fill(null)});const{t:h,easedT:l,completed:c,state:_}=this._frame(i,s,n,a,r,o),u={};for(let o=0;o<t.length;o++){const h=t[o],l=[...e[o]];h===this.parabolic||h===this.oscillate||h===this.pulse?(l[3]=i,l[4]=s,l[5]=n,void 0===l[6]&&(l[6]=a)):h===this.spring?(l[2]=i,l[3]=s,l[4]=n):h===this.spiral||h===this.bezier?(l[6]=i,l[7]=s,l[8]=n,void 0===l[9]&&(l[9]=a)):h===this.orbit?(l[5]=i,l[6]=s,l[7]=n,void 0===l[9]&&(l[9]=a)):h===this.bounce||h===this.shake?(l[6]=i,l[7]=s,l[8]=n,void 0===l[9]&&(l[9]=a)):h===this.followPath&&(l[2]=i,l[3]=s,l[4]=n,void 0===l[5]&&(l[5]=a)),l.push(r),l.push(_.animationStates[o]);const c=h.apply(this,l);_.animationStates[o]=c.state;u[`anim${o}`]=c}return this.animationResult(u,h,n,c,_)}static sequence(t,e,i,s,n=!1,a=null,r={},o=null,h=null){if(!h){h={started:!1,loopCount:0,animationStates:Array(t.length).fill(null),currentAnim:0,animStartTimes:[0],totalDuration:0};let e=0;for(let t=0;t<i.length;t++)e+=i[t],t<i.length-1&&h.animStartTimes.push(e);h.totalDuration=e}let l=s;if(n&&h.totalDuration>0){l=s%h.totalDuration;const t=Math.floor(s/h.totalDuration);t>h.loopCount&&r.onLoop&&(r.onLoop(t),h.loopCount=t)}!h.started&&r.onStart&&(r.onStart(),h.started=!0);let c=0;for(let e=t.length-1;e>=0;e--)if(l>=h.animStartTimes[e]){c=e;break}h.currentAnim=c;const _=l-h.animStartTimes[c],u=i[c],d=t[c],p=[...e[c]];d===this.parabolic||d===this.oscillate||d===this.pulse?(p[3]=_,p[4]=u,p[5]=!1,a&&a[c]&&(p[6]=a[c])):d===this.spring?(p[2]=_,p[3]=u,p[4]=!1):d===this.spiral||d===this.bezier?(p[6]=_,p[7]=u,p[8]=!1,a&&a[c]&&(p[9]=a[c])):d===this.orbit?(p[5]=_,p[6]=u,p[7]=!1,a&&a[c]&&(p[9]=a[c])):d===this.bounce||d===this.shake?(p[6]=_,p[7]=u,p[8]=!1,a&&a[c]&&(p[9]=a[c])):d===this.followPath&&(p[2]=_,p[3]=u,p[4]=!1,a&&a[c]&&(p[5]=a[c]));const g=o&&o[c]?o[c]:{},f=d.apply(this,[...p,g,h.animationStates[c]]);h.animationStates[c]=f.state;const m=!n&&l>=h.totalDuration;return m&&!h.completed&&r.onComplete&&(r.onComplete(),h.completed=!0),this.animationResult({...f,currentAnim:c,totalAnimations:t.length,sequenceProgress:Math.min(l/h.totalDuration,1)},l/h.totalDuration,n,m,h)}}function bezierV1(t,e,i,s,n,a,r=!1,o=!1,h=null,l={},c=null){if(a<=0)return Motion.animationResult({x:s[0],y:s[1],phase:"complete"},1,!1,!0);let _=n/a,u="forward",d=0;r?(d=Math.floor(_),_%=1,d>0&&l.onLoop&&l.onLoop(d)):_>1&&(_=1),_>0&&n<=a&&l.onStart&&l.onStart();let p=h?h(_):_;o&&(_>=.5?(p=1-2*(_-.5),u="return",_>=.5&&_<.51&&l.onYoyoTurn&&l.onYoyoTurn()):(p=2*_,u="forward"),p=h?h(p):p);const g=3*(e[0]-t[0]),f=3*(i[0]-e[0])-g,m=s[0]-t[0]-g-f,v=3*(e[1]-t[1]),y=3*(i[1]-e[1])-v,x=s[1]-t[1]-v-y,w=m*Math.pow(p,3)+f*Math.pow(p,2)+g*p+t[0],M=x*Math.pow(p,3)+y*Math.pow(p,2)+v*p+t[1],b=!r&&_>=1;return b&&l.onComplete&&l.onComplete(),Motion.animationResult({x:w,y:M,phase:u},_,r,b,c)}class Tweenetik{constructor(t,e,i,s,n={}){this.target=t,this.toProps={...e},this.duration=i,this.easingFn=s||Easing.easeOutQuad,this.delay=n.delay||0,this.onStart=n.onStart||null,this.onComplete=n.onComplete||null,this.onUpdate=n.onUpdate||null,this._elapsed=0,this._started=!1,this._finished=!1,this._startProps={};for(const t in this.toProps)t in this.target&&(this._startProps[t]=this.target[t])}static to(t,e,i,s,n){const a=new Tweenetik(t,e,i,s,n);return Tweenetik._active.push(a),a}update(t){if(this._finished)return;if(this._elapsed+=t,this._elapsed<this.delay)return;const e=this._elapsed-this.delay,i=Math.min(e/this.duration,1);!this._started&&i>0&&(this._started=!0,this.onStart&&this.onStart());const s=this.easingFn(i);for(const t in this._startProps){const e=this._startProps[t],i=this.toProps[t];this.target[t]=Tween.lerp(e,i,s)}this.onUpdate&&this.onUpdate(),i>=1&&(this._finished=!0,this.onComplete&&this.onComplete())}static updateAll(t){for(const e of Tweenetik._active)e.update(t);Tweenetik._active=Tweenetik._active.filter((t=>!t._finished))}}class Pipeline extends Loggable{constructor(t){super(),this.game=t,this._collection=new ZOrderedCollection,this._collection._owner=this;["inputdown","inputup","inputmove","click"].forEach((t=>{this.game.events.on(t,(e=>{this.dispatchInputEvent(t,e)}))}))}_hoverObject(t,e){if(!t.interactive||!t._hitTest)return;const i=t._hitTest(e.x,e.y);i&&!t._hovered?(t._hovered=!0,t.events.emit("mouseover",e)):!i&&t._hovered&&(t._hovered=!1,t.events.emit("mouseout",e))}_hoverScene(t,e){for(let i=t.children.length-1;i>=0;i--){const s=t.children[i];s instanceof Scene?this._hoverScene(s,e):this._hoverObject(s,e)}}dispatchInputEvent(t,e){var i;for(let s=this.gameObjects.length-1;s>=0;s--){const n=this.gameObjects[s];if(n instanceof Scene){if(this._dispatchToScene(n,t,e))break}else if(n.interactive&&(null==(i=n._hitTest)?void 0:i.call(n,e.x,e.y))){n.events.emit(t,e);break}}"inputmove"===t&&this._dispatchHover(e)}_dispatchHover(t){for(let e=this.gameObjects.length-1;e>=0;e--){const i=this.gameObjects[e];i instanceof Scene?this._hoverScene(i,t):this._hoverObject(i,t)}}_dispatchToScene(t,e,i){var s;for(let n=t.children.length-1;n>=0;n--){const a=t.children[n];if(a instanceof Scene){if(this._dispatchToScene(a,e,i))return!0}else if(a.interactive&&(null==(s=a._hitTest)?void 0:s.call(a,i.x,i.y)))return a.events.emit(e,i),!0}return!1}add(t){t.parent=this.game;const e=this._collection.add(t);return e.init&&e.init(),e}remove(t){null!=t?this._collection.remove(t):this.logger.warn("Cannot remove undefined or null object",t)}bringToFront(t){return this._collection.bringToFront(t)}sendToBack(t){return this._collection.sendToBack(t)}bringForward(t){return this._collection.bringForward(t)}sendBackward(t){return this._collection.sendBackward(t)}clear(){return this._collection.clear()}get gameObjects(){return this._collection.children}update(t){this.logger.groupCollapsed("Pipeline.update"),this._collection.children.filter((t=>t.active)).forEach((e=>e.update(t))),Tweenetik.updateAll(t),this.logger.groupEnd()}render(){this.logger.groupCollapsed("Pipeline.render"),this._collection.getSortedChildren().filter((t=>t.visible)).filter((t=>t.active)).forEach((t=>t.render())),this.logger.groupEnd()}}class Cursor extends GameObject{constructor(t,e,i=null,s={}){super(t,s),this.normalShape=e,this.pressedShape=i||e,this.active=!1,this.offsetX=0,this.offsetY=0,this.isDown=!1,this.game.events.on("inputmove",(t=>{this.x=t.x,this.y=t.y})),this.game.events.on("inputdown",(()=>{this.isDown=!0})),this.game.events.on("inputup",(()=>{this.isDown=!1})),this.game.events.on("mouseover",(()=>{this.visible=!1})),this.game.events.on("mouseout",(()=>{this.visible=!0}))}activate(){this.active=!0,this.game.canvas.style.cursor="none"}deactivate(){this.active=!1,this.game.canvas.style.cursor="default"}draw(){if(super.draw(),!this.active)return;const t=this.isDown&&this.pressedShape?this.pressedShape:this.normalShape;t&&t.render()}}class Game{constructor(t){__privateAdd(this,_prevWidth,0),__privateAdd(this,_prevHeight,0),this.canvas=t,this.ctx=t.getContext("2d"),this.events=new EventEmitter,this._cursor=null,this.lastTime=0,this.dt=0,this.running=!1,this._frame=0,this.pipeline=new Pipeline(this),Painter.init(this.ctx),this.targetFPS=60,this._frameInterval=1e3/this.targetFPS,this._accumulator=0,this._pauseOnBlur=!1,this._isPaused=!1,this._init=!1,this.initLogging()}setFPS(t){this.targetFPS=t,this._frameInterval=1e3/t}init(){this.initIO(),this.initMotion(),this._init=!0,this.logger.log("[Game] Initialized")}initMouse(){Mouse.init(this)}initTouch(){Touch.init(this)}initInput(){Input.init(this)}initKeyboard(){Keys.init(this)}initIO(){this.initMouse(),this.initTouch(),this.initInput(),this.initKeyboard()}initMotion(){Tweenetik._active=[]}initLogging(){this.logger=new Logger("Game"),Logger.setOutput(console),Logger.disableAll(),Logger.disable(),Logger.setLevel(Logger.INFO),this.logger.groupCollapsed("Initializing Game...")}enableLogging(){Logger.enable()}disableLogging(){Logger.disableAll(),Logger.disable()}markBoundsDirty(){this._boundsDirty=!0}get boundsDirty(){return this._boundsDirty}set boundsDirty(t){this._boundsDirty=t}enableFluidSize(t=window){if(t===window){const t=()=>{var t;this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight,__privateGet(this,_prevWidth)===this.canvas.width&&__privateGet(this,_prevHeight)===this.canvas.height||(this.markBoundsDirty(),null==(t=this.onResize)||t.call(this)),__privateSet(this,_prevWidth,this.canvas.width),__privateSet(this,_prevHeight,this.canvas.height)};t(),window.addEventListener("resize",t),this._fluidResizeCleanup=()=>{window.removeEventListener("resize",t)}}else{if(!("ResizeObserver"in window))return void console.warn("ResizeObserver not supported in this browser.");const e=()=>{const e=t.getBoundingClientRect();this.canvas.width=e.width,this.canvas.height=e.height},i=new ResizeObserver((()=>{e()}));i.observe(t),e(),this._fluidResizeCleanup=()=>i.disconnect()}}disableFluidSize(){this._fluidResizeCleanup&&(this._fluidResizeCleanup(),this._fluidResizeCleanup=null)}start(){if(this.logger.groupCollapsed("[Game] Starting..."),this.init(),!this._init)throw new Error("Game not initialized. Did you call init()? Remember to call super.init() in your subclass.");this.running=!0,this.loop=this.loop.bind(this),requestAnimationFrame(this.loop),this.logger.log("[Game] Started"),this.logger.groupEnd()}stop(){this.running=!1,this.logger.log("[Game] Stopped")}restart(){this.pipeline.clear(),this.init(),this.start(),this.logger.log("[Game] Restarted")}loop(t){if(!this.running)return;const e=t-this.lastTime;if(this.lastTime=t,this._accumulator+=e,this.actualFps=1e3/e,this._accumulator>=this._frameInterval){const t=this._frameInterval/1e3;this.dt=t,this._frame++,this.logger.groupCollapsed(`Frame #${this._frame}`),this.logger.time("render time"),this.update(t),this.render(),this.logger.timeEnd("render time"),this.logger.groupEnd(),this._accumulator-=this._frameInterval}this.boundsDirty&&(this.boundsDirty=!1),requestAnimationFrame(this.loop)}update(t){this.pipeline.update(t)}render(){Painter.setContext(this.ctx),this.running&&this.clear(),this.pipeline.render()}clear(){Painter.clear()}get width(){return this.canvas.width}get height(){return this.canvas.height}set backgroundColor(t){this.canvas.style.backgroundColor=t}set cursor(t){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor)),this._cursor=t,this._cursor.activate(),this.pipeline.add(t)}get cursor(){return this._cursor}resetCursor(){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor),this._cursor=null)}enablePauseOnBlur(t){this._pauseOnBlur=t,t?window.addEventListener("visibilitychange",this._handleVisibilityChange.bind(this),!1):window.removeEventListener("visibilitychange",this._handleVisibilityChange.bind(this),!1)}_handleVisibilityChange(){this.logger.log("Visibility change detected"),document.hidden?this._pauseOnBlur&&this.running&&(this._isPaused=!0,this.stop(),this.logger.log("Paused due to tab visibility change")):this._isPaused&&(this._isPaused=!1,this.start(),this.logger.log("Resumed after tab visibility change"))}}_prevWidth=new WeakMap,_prevHeight=new WeakMap;class Button extends GameObject{constructor(t,e={}){super(t,e);const{x:i=0,y:s=0,width:n=120,height:a=40,text:r="Button",font:o="14px monospace",textColor:h="#000",textAlign:l="center",textBaseline:c="middle",shape:_=null,label:u=null,onClick:d=null,onHover:p=null,onPressed:g=null,onRelease:f=null,padding:m=10,colorDefaultBg:v="#eee",colorDefaultStroke:y="#999",colorDefaultText:x="#333",colorHoverBg:w="#222",colorHoverStroke:M="#16F529",colorHoverText:b="#16F529",colorPressedBg:P="#111",colorPressedStroke:G="#00aaff",colorPressedText:S="#00aaff"}=e;this.x=i,this.y=s,this.width=n,this.height=a,this.padding=m,this.textAlign=l,this.textBaseline=c,this.initColorScheme({colorDefaultBg:v,colorDefaultStroke:y,colorDefaultText:x,colorHoverBg:w,colorHoverStroke:M,colorHoverText:b,colorPressedBg:P,colorPressedStroke:G,colorPressedText:S}),this.initBackground(_),this.initLabel(r,o,h,u),this.initGroup(),this.initEvents(d,p,g,f),this.setState("default")}initColorScheme(t){this.colors={default:{bg:t.colorDefaultBg,stroke:t.colorDefaultStroke,text:t.colorDefaultText},hover:{bg:t.colorHoverBg,stroke:t.colorHoverStroke,text:t.colorHoverText},pressed:{bg:t.colorPressedBg,stroke:t.colorPressedStroke,text:t.colorPressedText}}}initBackground(t){this.bg=t??new Rectangle({width:this.width,height:this.height,color:this.colors.default.bg,stroke:this.colors.default.stroke,lineWidth:2})}initLabel(t,e,i,s){this.label=s??new TextShape(t,{font:e,color:i,align:this.textAlign,baseline:this.textBaseline}),this.alignText()}alignText(){if(!this.label)return;const t=this.width/2,e=this.height/2;switch(this.textAlign){case"left":this.label.x=-t+this.padding;break;case"right":this.label.x=t-this.padding;break;default:this.label.x=0}switch(this.textBaseline){case"top":this.label.y=-e+this.padding;break;case"bottom":this.label.y=e-this.padding;break;default:this.label.y=0}}initGroup(){this.group=new Group,this.group.add(this.bg),this.group.add(this.label)}initEvents(t,e,i,s){this.interactive=!0,this.onHover=e,this.onPressed=i,this.onRelease=s,this.on("mouseover",this.setState.bind(this,"hover")),this.on("mouseout",this.setState.bind(this,"default")),this.on("inputdown",this.setState.bind(this,"pressed")),this.on("inputup",(()=>{"pressed"===this.state&&"function"==typeof t&&t(),this.setState("hover")}))}setState(t){var e,i,s;if(this.state!==t)switch(this.state=t,t){case"default":this.game.cursor&&setTimeout((()=>{this.game.cursor.activate()}),0),this.bg.color=this.colors.default.bg,this.bg.stroke=this.colors.default.stroke,this.label.color=this.colors.default.text,this.game.canvas.style.cursor="default",null==(e=this.onRelease)||e.call(this);break;case"hover":this.game.cursor&&this.game.cursor.deactivate(),this.bg.color=this.colors.hover.bg,this.bg.stroke=this.colors.hover.stroke,this.label.color=this.colors.hover.text,this.game.canvas.style.cursor="pointer",null==(i=this.onHover)||i.call(this);break;case"pressed":this.game.cursor&&this.game.cursor.deactivate(),this.bg.color=this.colors.pressed.bg,this.bg.stroke=this.colors.pressed.stroke,this.label.color=this.colors.pressed.text,this.game.canvas.style.cursor="pointer",null==(s=this.onPressed)||s.call(this)}}update(t){super.update(t),this._boundsDirty&&this.alignText()}get text(){return this.label.text}set text(t){this.label.text=t,this._boundsDirty=!0}setTextAlign(t){this.textAlign=t,this.label.align=t,this._boundsDirty=!0}setTextBaseline(t){this.textBaseline=t,this.label.baseline=t,this._boundsDirty=!0}setFont(t){this.label.font=t,this._boundsDirty=!0}resize(t,e){this.width=t,this.height=e,this.bg.width=t,this.bg.height=e,this._boundsDirty=!0}draw(){super.draw(),this.group.render()}}class ToggleButton extends Button{constructor(t,e={}){const i=e.onClick;super(t,{...e,onClick:()=>{this.toggled=!this.toggled,"function"==typeof e.onToggle&&e.onToggle(this.toggled),"function"==typeof i&&i(),this.refreshToggleVisual()}}),this.colorActiveBg=e.colorActiveBg||"#444",this.colorActiveStroke=e.colorActiveStroke||"#0f0",this.colorActiveText=e.colorActiveText||"#0f0",this.toggled=!!e.startToggled,this.refreshToggleVisual()}toggle(t){this.toggled=t,this.refreshToggleVisual()}refreshToggleVisual(){this.toggled?(this.bg.fillColor=this.colorActiveBg,this.bg.strokeColor=this.colorActiveStroke,this.label.color=this.colorActiveText):(this.bg.fillColor=this.colors.default.bg,this.bg.strokeColor=this.colors.default.stroke,this.label.color=this.colors.default.text)}setState(t){super.setState(t),this.toggled&&(this.bg.fillColor=this.colorActiveBg,this.bg.strokeColor=this.colorActiveStroke,this.label.color=this.colorActiveText)}}class Tooltip extends GameObject{constructor(t,e={}){super(t,{...e,zIndex:9999}),this.font=e.font||"12px monospace",this.textColor=e.textColor||"#fff",this.bgColor=e.bgColor||"rgba(0,0,0,0.85)",this.borderColor=e.borderColor||"rgba(255,255,255,0.3)",this.padding=e.padding??8,this.offsetX=e.offsetX??15,this.offsetY=e.offsetY??15,this.maxWidth=e.maxWidth??300,this.lineHeightMultiplier=e.lineHeight??1.4,this._text="",this._lines=[],this._visible=!1,this.bg=new Rectangle({width:100,height:30,color:this.bgColor,stroke:this.borderColor,lineWidth:1}),this.lineShapes=[],this.group=new Group,this.group.add(this.bg),this.game.events.on("inputmove",(t=>{this._visible&&this.updatePosition(t.x,t.y)}))}wrapText(t){const e=this.game.ctx;e.font=this.font;const i=[],s=t.split("\n");for(const t of s){const s=t.split(" ");let n="";for(const t of s){const s=n?`${n} ${t}`:t;e.measureText(s).width>this.maxWidth&&n?(i.push(n),n=t):n=s}n?i.push(n):""===t&&i.push("")}return i}show(t,e,i){this._text=t,this._visible=!0,this._lines=this.wrapText(t),this.updateLineShapes(),this.updateSize(),void 0!==e&&void 0!==i&&this.updatePosition(e,i)}updateLineShapes(){for(const t of this.lineShapes)this.group.remove(t);this.lineShapes=this._lines.map((t=>new TextShape(t,{font:this.font,color:this.textColor,align:"left",baseline:"top"})));for(const t of this.lineShapes)this.group.add(t)}hide(){this._visible=!1}updatePosition(t,e){const i=this.bg.width,s=this.bg.height;let n=t+this.offsetX+i/2,a=e+this.offsetY+s/2;n+i/2>this.game.width&&(n=t-this.offsetX-i/2),a+s/2>this.game.height&&(a=e-this.offsetY-s/2),n-i/2<0&&(n=i/2+5),a-s/2<0&&(a=s/2+5),this.x=n,this.y=a}updateSize(){const t=this.game.ctx;t.font=this.font;let e=0;for(const i of this._lines){const s=t.measureText(i);e=Math.max(e,s.width)}const i=Math.min(e,this.maxWidth),s=parseInt(this.font)*this.lineHeightMultiplier,n=s*this._lines.length;this.bg.width=i+2*this.padding,this.bg.height=n+2*this.padding;const a=-this.bg.width/2+this.padding,r=-this.bg.height/2+this.padding;for(let t=0;t<this.lineShapes.length;t++)this.lineShapes[t].x=a,this.lineShapes[t].y=r+t*s}draw(){this._visible&&this.group.render()}}class FPSCounter extends Text{constructor(t,e={}){super(t,"0 FPS",{x:0,y:0,font:"12px monospace",color:"#0f0",align:"center",baseline:"middle",debug:!1,...e}),this.fps=0,this._frames=0,this._accum=0}update(t){const e=this.game.actualFps;e&&(this._frames++,this._accum+=t,this._accum>=.5&&(this.fps=Math.round(e),this.text=`${this.fps} FPS`,this._accum=0,this._frames=0),super.update(t))}getBounds(){if(this.shape&&this.shape.getTextBounds){const t=this.shape.getTextBounds();return{x:t.x,y:t.y,width:t.width,height:t.height}}return super.getBounds()}getDebugBounds(){if(this.shape&&this.shape.getDebugBounds){const t=this.shape.getDebugBounds();return{x:t.x,y:t.y,width:t.width,height:t.height}}return super.getDebugBounds()}}const _FluentGO=class t{constructor(t,e,i,s){__privateAdd(this,_FluentGO_instances),__privateAdd(this,_parent),__privateAdd(this,_go),__privateAdd(this,_refs),__privateAdd(this,_state),__privateAdd(this,_shapes,[]),__privateAdd(this,_motions,[]),__privateSet(this,_parent,t),__privateSet(this,_go,e),__privateSet(this,_refs,i),__privateSet(this,_state,s)}circle(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{radius:i=30,...s}=e,n=new Circle(i,s);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,n)}rect(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),i=new Rectangle(e);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,i)}roundRect(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{radius:i=10,...s}=e,n=new RoundedRectangle(i,s);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,n)}square(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{size:i=50,...s}=e,n=new Square(i,s);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,n)}star(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{radius:i=40,points:s=5,inset:n=.5,...a}=e,r=new Star(i,s,n,a);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,r)}triangle(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{size:i=50,...s}=e,n=new Triangle(i,s);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,n)}poly(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),i=new Polygon(e);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,i)}line(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{length:i=40,...s}=e,n=new Line(i,s);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,n)}hexagon(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{radius:i=30,...s}=e,n=new Hexagon(i,s);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,n)}diamond(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),i=new Diamond(e);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,i)}heart(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{size:i,...s}=e;i&&!s.width&&(s.width=i),i&&!s.height&&(s.height=i);const n=new Heart(s);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,n)}arc(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{radius:i=30,startAngle:s=0,endAngle:n=Math.PI,...a}=e,r=new Arc(i,s,n,a);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,r)}ring(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{outerRadius:i=40,innerRadius:s=20,...n}=e,a=new Ring(i,s,n);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,a)}arrow(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{length:i=50,...s}=e,n=new Arrow(i,s);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,n)}cross(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{size:i=40,thickness:s=10,...n}=e,a=new Cross(i,s,n);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,a)}pin(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{radius:i=20,...s}=e,n=new Pin(i,s);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,n)}cloud(t={}){const e=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,t),{size:i,width:s,height:n,...a}=e,r=i||Math.min(s||40,n||40),o=new Cloud(r,a);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,o)}text(t,e={}){const i=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,e);i.fillColor&&(i.color=i.fillColor,delete i.fillColor);const s=new TextShape(t,i);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,s)}image(t,e={}){const i=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,e);if("string"==typeof t){const s=new Image;s.src=t;const n=new ImageShape(s,i);return s.onload=()=>{n._bitmap=s,n._width=e.width??s.width,n._height=e.height??s.height},__privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,n)}{const e=new ImageShape(t,i);return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,e)}}svg(t,e={}){const i=__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,e),s=new SVGShape({path:t,...i});return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,s)}add(t,e={}){const i=new t(__privateMethod(this,_FluentGO_instances,normalizeShapeOpts_fn).call(this,e));return __privateMethod(this,_FluentGO_instances,addShapeInstance_fn).call(this,i)}oscillate(t={}){return this.motion("oscillate",t)}pulse(t={}){return this.motion("pulse",t)}orbit(t={}){return this.motion("orbit",t)}float(t={}){return this.motion("float",t)}shake(t={}){return this.motion("shake",t)}bounce(t={}){return this.motion("bounce",t)}spring(t={}){return this.motion("spring",t)}spiral(t={}){return this.motion("spiral",t)}pendulum(t={}){return this.motion("pendulum",t)}waypoint(t={}){return this.motion("waypoint",t)}motion(t,e={}){var i;if(__privateGet(this,_motions).push({type:t,opts:e}),!__privateGet(this,_go)._fluentMotions){__privateGet(this,_go)._fluentMotions=[],__privateGet(this,_go)._motionTime=0,__privateGet(this,_go)._baseX=__privateGet(this,_go).x,__privateGet(this,_go)._baseY=__privateGet(this,_go).y;const t=(null==(i=__privateGet(this,_go).update)?void 0:i.bind(__privateGet(this,_go)))||(()=>{}),e=this;__privateGet(this,_go).update=function(i){var s;t(i),this._motionTime+=i,__privateMethod(s=e,_FluentGO_instances,processMotions_fn).call(s,i)}}return __privateGet(this,_go)._fluentMotions.push({type:t,opts:e,state:null}),this}tween(t,e={}){const{duration:i=1,easing:s="easeOutQuad",delay:n=0,onComplete:a}=e;return n>0?setTimeout((()=>{Tweenetik.to(__privateGet(this,_go),t,i,s,{onComplete:a})}),1e3*n):Tweenetik.to(__privateGet(this,_go),t,i,s,{onComplete:a}),this}child(e,i,s){let n,a,r;"function"==typeof e&&e.prototype?(n=e,"function"==typeof i?(a={},r=i):(a=i||{},r=s)):(n=GameObject,a=e||{},r=i);const o=new n(__privateGet(this,_go).game,a);__privateGet(this,_go).addChild(o),a.name&&(__privateGet(this,_refs)[a.name]=o);const h=new t(this,o,__privateGet(this,_refs),__privateGet(this,_state));return r?(r(h),this):h}on(t,e){const i={go:__privateGet(this,_go),shapes:__privateGet(this,_shapes),refs:__privateGet(this,_refs),state:__privateGet(this,_state)};return["click","mousedown","mouseup","mousemove","mouseover","mouseout","inputdown","inputup","inputmove"].includes(t)&&(__privateGet(this,_go).interactive=!0),__privateGet(this,_go).events&&__privateGet(this,_go).events.on(t,(t=>e(i,t))),this}update(t){var e;const i=(null==(e=__privateGet(this,_go).update)?void 0:e.bind(__privateGet(this,_go)))||(()=>{}),s=__privateGet(this,_shapes),n=__privateGet(this,_refs),a=__privateGet(this,_state),r=__privateGet(this,_go);return __privateGet(this,_go).update=e=>{i(e),t(e,{go:r,shapes:s,refs:n,state:a})},this}pos(t,e){return __privateGet(this,_go).x=t,__privateGet(this,_go).y=e,this}scale(t,e){return __privateGet(this,_go).scaleX=t,__privateGet(this,_go).scaleY=e??t,this}rotate(t){return __privateGet(this,_go).rotation=t*(Math.PI/180),this}opacity(t){return __privateGet(this,_go).opacity=t,__privateGet(this,_go).renderable&&(__privateGet(this,_go).renderable.opacity=t),this}zIndex(t){return __privateGet(this,_go).zIndex=t,this}end(){return __privateGet(this,_parent)}go(t){var e;let i=__privateGet(this,_parent);for(;i&&!i.sceneInstance;)i=null==(e=i.end)?void 0:e.call(i);if(i&&i.go)return i.go(t);throw new Error("Cannot find scene context")}scene(t,e){var i;let s=__privateGet(this,_parent);for(;s&&!s.sceneInstance;)s=null==(i=s.end)?void 0:i.call(s);if(s&&s.scene)return s.scene(t,e);throw new Error("Cannot find game context")}start(){let t=__privateGet(this,_parent);for(;t&&t.end;){const e=t.end();if(e===t)break;t=e}return t.start()}get goInstance(){return __privateGet(this,_go)}get shapes(){return __privateGet(this,_shapes)}get refs(){return __privateGet(this,_refs)}get state(){return __privateGet(this,_state)}};_parent=new WeakMap,_go=new WeakMap,_refs=new WeakMap,_state=new WeakMap,_shapes=new WeakMap,_motions=new WeakMap,_FluentGO_instances=new WeakSet,addShapeInstance_fn=function(t){var e;if(__privateGet(this,_shapes).push(t),1===__privateGet(this,_shapes).length){__privateGet(this,_go)._fluentShape=t,__privateGet(this,_go).renderable=t;const i=(null==(e=__privateGet(this,_go).draw)?void 0:e.bind(__privateGet(this,_go)))||(()=>{});__privateGet(this,_go).draw=function(){i(),this._fluentShape&&this.visible&&this._fluentShape.render()};const s=__privateGet(this,_go);__privateGet(this,_go).getBounds=function(){return s._fluentShape&&s._fluentShape.getBounds?s._fluentShape.getBounds():null}}else{if(!(__privateGet(this,_go)._fluentShape instanceof Group)){const t=__privateGet(this,_shapes)[0],e=new Group;e.add(t),__privateGet(this,_go)._fluentShape=e,__privateGet(this,_go).renderable=e}__privateGet(this,_go)._fluentShape.add(t)}return this},normalizeShapeOpts_fn=function(t){const e={...t};return void 0!==t.fill&&(e.color=t.fill,e.fillColor=t.fill,delete e.fill),void 0!==t.stroke&&(e.strokeColor=t.stroke,delete e.stroke),e},processMotions_fn=function(t){for(const e of __privateGet(this,_go)._fluentMotions){const i=__privateMethod(this,_FluentGO_instances,applyMotion_fn).call(this,e,t);e.state=null==i?void 0:i.state}},applyMotion_fn=function(t,e){const{type:i,opts:s,state:n}=t,a=__privateGet(this,_go)._motionTime,r=__privateGet(this,_go);switch(i){case"oscillate":{const{prop:t="y",min:e=-50,max:i=50,duration:n=2}=s,o=Motion.oscillate(e,i,a,n,!0),h=`_base_${t}`;return void 0===r[h]&&(r[h]=r[t]),r[t]=r[h]+o.value,o}case"pulse":{const{prop:t="scale",min:e=.8,max:i=1.2,duration:n=1}=s,o=Motion.pulse(e,i,a,n,!0);return"scale"===t?(r.scaleX=o.value,r.scaleY=o.value):"opacity"===t&&r.renderable?r.renderable.opacity=o.value:r[t]=o.value,o}case"orbit":{const{centerX:t=r._baseX,centerY:e=r._baseY,radiusX:i=100,radiusY:n=100,duration:o=3,clockwise:h=!0}=s;r._orbitCenter||(r._orbitCenter={x:t,y:e});const l=Motion.orbit(r._orbitCenter.x,r._orbitCenter.y,i,n,0,a,o,!0,h);return r.x=l.x,r.y=l.y,l}case"float":{const{radius:t=20,speed:e=.5,randomness:i=.3,duration:n=5}=s;r._floatState||(r._floatState={baseX:r._baseX,baseY:r._baseY});const o=Motion.float(r._floatState,a,n,e,i,t,!0);return r.x=o.x,r.y=o.y,o}case"shake":{const{intensity:t=5,frequency:e=20,decay:i=.9,duration:n=.5}=s,o=Motion.shake(r._baseX,r._baseY,t,t,e,i,a,n,!0);return r.x=o.x,r.y=o.y,o}case"bounce":{const{height:t=100,bounces:e=3,duration:i=2}=s,n=Motion.bounce(t,r._baseY,e,a,i,!0);return r.y=n.y,n}case"spiral":{const{startRadius:t=50,endRadius:e=150,revolutions:i=3,duration:n=4}=s;r._spiralCenter||(r._spiralCenter={x:r._baseX,y:r._baseY});const o=Motion.spiral(r._spiralCenter.x,r._spiralCenter.y,t,e,0,i,a,n,!0);return r.x=o.x,r.y=o.y,o}case"pendulum":{const{amplitude:t=45,duration:e=2,damped:i=!1}=s,n=Motion.pendulum(0,t,a,e,!0,i);return r.rotation=n.value*(Math.PI/180),n}case"waypoint":{const{waypoints:t=[],speed:e=100,waitTime:i=0}=s;if(0===t.length)return{state:null};const o=Motion.waypoint(r,a,t,e,i,!0,null,n);return r.x=o.x??r.x,r.y=o.y??r.y,o}default:return console.warn(`Unknown motion type: ${i}`),{state:null}}};let FluentGO=_FluentGO;class FluentLayer{constructor(t,e,i,s,n){__privateAdd(this,_parent2),__privateAdd(this,_layerGO),__privateAdd(this,_group),__privateAdd(this,_refs2),__privateAdd(this,_state2),__privateSet(this,_parent2,t),__privateSet(this,_layerGO,e),__privateSet(this,_group,i),__privateSet(this,_refs2,s),__privateSet(this,_state2,n)}go(t={},e){var i;const{name:s,x:n=0,y:a=0,visible:r=!0,...o}=t,h=new GameObject({x:n,y:a,visible:r,...o});(null==(i=__privateGet(this,_parent2).parent)?void 0:i.game)&&(h.game=__privateGet(this,_parent2).parent.game),__privateGet(this,_group).add(h),s&&(h.name=s,__privateGet(this,_refs2)[s]=h);const l=new FluentGO(this,h,__privateGet(this,_refs2),__privateGet(this,_state2));return e?(e(l),this):l}visible(t){return __privateGet(this,_layerGO).visible=t,this}opacity(t){return __privateGet(this,_group).opacity=t,this}endLayer(){return __privateGet(this,_parent2)}end(){return __privateGet(this,_parent2)}scene(t,e){return __privateGet(this,_parent2).scene(t,e)}start(){return __privateGet(this,_parent2).start()}get layerGO(){return __privateGet(this,_layerGO)}get group(){return __privateGet(this,_group)}get refs(){return __privateGet(this,_refs2)}get state(){return __privateGet(this,_state2)}}_parent2=new WeakMap,_layerGO=new WeakMap,_group=new WeakMap,_refs2=new WeakMap,_state2=new WeakMap;class FluentScene{constructor(t,e,i,s){__privateAdd(this,_parent3),__privateAdd(this,_scene),__privateAdd(this,_refs3),__privateAdd(this,_state3),__privateAdd(this,_lastGO,null),__privateSet(this,_parent3,t),__privateSet(this,_scene,e),__privateSet(this,_refs3,i),__privateSet(this,_state3,s)}go(t,e,i){let s,n,a;"function"==typeof t&&t.prototype?(s=t,"function"==typeof e?(n={},a=e):(n=e||{},a=i)):(s=GameObject,n=t||{},a=e);const{name:r,x:o=0,y:h=0,visible:l=!0,...c}=n,_=new s(__privateGet(this,_parent3).game,{x:o,y:h,visible:l,...c});__privateGet(this,_scene).add(_),__privateSet(this,_lastGO,_),r&&(_.name=r,__privateGet(this,_refs3)[r]=_);const u=new FluentGO(this,_,__privateGet(this,_refs3),__privateGet(this,_state3));return a?(a(u),this):u}group(t,e){const i="string"==typeof t?t:null,s=[];return("function"==typeof t?t:e)({go:t=>{const e=this.go(t);return s.push(e.goInstance),e}}),i&&(__privateGet(this,_refs3)[i]=s),this}layer(t,e=0){var i;const s=new Group({zIndex:e});s.name=t;const n=new GameObject(__privateGet(this,_parent3).game,{x:0,y:0});n._fluentShape=s,n.renderable=s,n.zIndex=e;const a=(null==(i=n.draw)?void 0:i.bind(n))||(()=>{});return n.draw=function(){a(),this._fluentShape&&this.visible&&this._fluentShape.render()},__privateGet(this,_scene).add(n),t&&(__privateGet(this,_refs3)[`${__privateGet(this,_scene).name}_${t}`]=n),new FluentLayer(this,n,s,__privateGet(this,_refs3),__privateGet(this,_state3))}onEnter(t){return __privateGet(this,_scene)._onEnter=t,this}onExit(t){return __privateGet(this,_scene)._onExit=t,this}scene(t,e){return __privateGet(this,_parent3).scene(t,e)}end(){return __privateGet(this,_parent3)}start(){return __privateGet(this,_parent3).start()}stop(){return __privateGet(this,_parent3).stop()}on(t,e){return __privateGet(this,_parent3).on(t,e)}use(t){return __privateGet(this,_parent3).use(t)}state(t){return __privateGet(this,_parent3).state(t)}get sceneInstance(){return __privateGet(this,_scene)}get refs(){return __privateGet(this,_refs3)}get state(){return __privateGet(this,_state3)}get parent(){return __privateGet(this,_parent3)}}function gcanvas(t={}){return new FluentGame(t)}_parent3=new WeakMap,_scene=new WeakMap,_refs3=new WeakMap,_state3=new WeakMap,_lastGO=new WeakMap;class FluentGame{constructor(t={}){__privateAdd(this,_FluentGame_instances),__privateAdd(this,_game),__privateAdd(this,_scenes,new Map),__privateAdd(this,_currentScene,null),__privateAdd(this,_refs4,{}),__privateAdd(this,_state4,{}),__privateAdd(this,_plugins,[]),__privateAdd(this,_canvas,null);const{canvas:e,width:i=800,height:s=600,bg:n,fluid:a,container:r,fps:o=60,pixelRatio:h=("undefined"!=typeof window?window.devicePixelRatio:1)}=t;__privateSet(this,_canvas,e||__privateMethod(this,_FluentGame_instances,createCanvas_fn).call(this,i,s,r)),__privateSet(this,_game,new Game(__privateGet(this,_canvas))),__privateGet(this,_game).init(),n&&(__privateGet(this,_game).backgroundColor=n);(void 0!==a?a:!e)&&__privateGet(this,_game).enableFluidSize(),60!==o&&(__privateGet(this,_game).targetFPS=o),__privateGet(this,_game)._pixelRatio=h}scene(t,e,i){let s,n,a;"function"==typeof t?(n=t,s=n.name||"custom_scene",a=e||{}):"function"==typeof e?(s=t,n=e,a=i||{}):(s=t,n=Scene,a=e||{});const{zIndex:r=0,active:o=!0,onEnter:h,onExit:l,...c}=a;let _=__privateGet(this,_scenes).get(s);return _||(_=new n(__privateGet(this,_game),c),_.name=s,_.zIndex=r,_.visible=o,_._onEnter=h,_._onExit=l,__privateGet(this,_scenes).set(s,_),__privateGet(this,_game).pipeline.add(_)),__privateSet(this,_currentScene,_),new FluentScene(this,_,__privateGet(this,_refs4),__privateGet(this,_state4))}inScene(t){const e=__privateGet(this,_scenes).get(t);if(!e)throw new Error(`Scene '${t}' does not exist. Use .scene('${t}') to create it.`);return __privateSet(this,_currentScene,e),new FluentScene(this,e,__privateGet(this,_refs4),__privateGet(this,_state4))}go(t,e){return __privateGet(this,_currentScene)||this.scene("default"),new FluentScene(this,__privateGet(this,_currentScene),__privateGet(this,_refs4),__privateGet(this,_state4)).go(t,e)}showScene(t){var e;const i=__privateGet(this,_scenes).get(t);return i&&(i.visible=!0,null==(e=i._onEnter)||e.call(i,__privateMethod(this,_FluentGame_instances,createContext_fn).call(this))),this}hideScene(t){var e;const i=__privateGet(this,_scenes).get(t);return i&&(null==(e=i._onExit)||e.call(i,__privateMethod(this,_FluentGame_instances,createContext_fn).call(this)),i.visible=!1),this}transition(t,e,i={}){const{fade:s=0,onComplete:n}=i;return this.hideScene(t),this.showScene(e),null==n||n(),this}state(t){return Object.assign(__privateGet(this,_state4),t),this}getState(t){return __privateGet(this,_state4)[t]}setState(t,e){return __privateGet(this,_state4)[t]=e,this}on(t,e){const i=__privateMethod(this,_FluentGame_instances,createContext_fn).call(this);if("update"===t){const t=__privateGet(this,_game).update.bind(__privateGet(this,_game));__privateGet(this,_game).update=s=>{t(s),e(s,i)}}else if(t.startsWith("keydown:")){const s=t.split(":")[1];__privateGet(this,_game).events.on("keydown",(t=>{var n,a;(null==(n=t.key)?void 0:n.toLowerCase())!==s.toLowerCase()&&(null==(a=t.code)?void 0:a.toLowerCase())!==s.toLowerCase()||e(i,t)}))}else if(t.startsWith("keyup:")){const s=t.split(":")[1];__privateGet(this,_game).events.on("keyup",(t=>{var n;(null==(n=t.key)?void 0:n.toLowerCase())===s.toLowerCase()&&e(i,t)}))}else __privateGet(this,_game).events.on(t,(t=>e(i,t)));return this}use(t){return t(this),__privateGet(this,_plugins).push(t),this}start(){return __privateGet(this,_game).start(),this}stop(){return __privateGet(this,_game).stop(),this}restart(){return __privateGet(this,_game).restart(),this}get game(){return __privateGet(this,_game)}get refs(){return __privateGet(this,_refs4)}get scenes(){return __privateGet(this,_scenes)}get canvas(){return __privateGet(this,_canvas)}get width(){return __privateGet(this,_canvas).width}get height(){return __privateGet(this,_canvas).height}}function sketch(t=800,e=600,i="black"){const s=[];let n=null,a=null,r=null;const o={circle:(t,e,i,n="white")=>(s.push({type:"circle",x:t,y:e,radius:i,fill:n}),o),rect:(t,e,i,n,a="white")=>(s.push({type:"rect",x:t,y:e,width:i,height:n,fill:a}),o),square:(t,e,i,n="white")=>(s.push({type:"rect",x:t,y:e,width:i,height:i,fill:n}),o),star:(t,e,i,n,a="white")=>(s.push({type:"star",x:t,y:e,points:i,radius:n,fill:a}),o),triangle:(t,e,i,n="white")=>(s.push({type:"triangle",x:t,y:e,size:i,fill:n}),o),hexagon:(t,e,i,n="white")=>(s.push({type:"hexagon",x:t,y:e,radius:i,fill:n}),o),line:(t,e,i,n,a="white",r=1)=>(s.push({type:"line",x:t,y:e,x2:i,y2:n,stroke:a,lineWidth:r}),o),ring:(t,e,i,n,a="white")=>(s.push({type:"ring",x:t,y:e,innerRadius:i,outerRadius:n,fill:a}),o),text:(t,e,i,n={})=>(s.push({type:"text",content:t,x:e,y:i,...n}),o),grid:(t,e,i,s)=>{for(let n=0;n<t;n++)for(let t=0;t<e;t++){s(o,n*i+i/2,t*i+i/2,n,t)}return o},repeat:(t,e)=>{for(let i=0;i<t;i++)e(o,i,t);return o},radial:(t,e,i,s,n)=>{for(let a=0;a<s;a++){const r=a/s*Math.PI*2,h=t+Math.cos(r)*i,l=e+Math.sin(r)*i;n(o,h,l,r,a)}return o},setup:t=>(a=t,o),update:t=>(n=t,o),start:()=>{const h=gcanvas({width:t,height:e,bg:i});null==a||a(o);const l=[];let c=h.scene("default");if(s.forEach(((t,e)=>{const i=c.go({x:t.x??0,y:t.y??0,name:`shape_${e}`});switch(t.type){case"circle":i.circle({radius:t.radius,fill:t.fill});break;case"rect":i.rect({width:t.width,height:t.height,fill:t.fill});break;case"star":i.star({points:t.points,radius:t.radius,fill:t.fill});break;case"triangle":i.triangle({size:t.size,fill:t.fill});break;case"hexagon":i.hexagon({radius:t.radius,fill:t.fill});break;case"line":i.line({x2:t.x2-t.x,y2:t.y2-t.y,stroke:t.stroke,lineWidth:t.lineWidth});break;case"ring":i.ring({innerRadius:t.innerRadius,outerRadius:t.outerRadius,fill:t.fill});break;case"text":i.text(t.content,{fill:t.fill??"white",font:t.font??"16px monospace"})}l.push(i.goInstance),c=i.end()})),n){let i=0,s=0;h.on("update",((a,r)=>{var o,h;i++,s+=a,n(a,{shapes:l,time:s,frame:i,width:t,height:e,mouse:{x:(null==(o=r.game.mouse)?void 0:o.x)??0,y:(null==(h=r.game.mouse)?void 0:h.y)??0},refs:r.refs,game:r.game})}))}return r=h,h.start()},get width(){return t},get height(){return e},get game(){return r}};return o}_game=new WeakMap,_scenes=new WeakMap,_currentScene=new WeakMap,_refs4=new WeakMap,_state4=new WeakMap,_plugins=new WeakMap,_canvas=new WeakMap,_FluentGame_instances=new WeakSet,createCanvas_fn=function(t,e,i){const s=document.createElement("canvas");s.width=t,s.height=e,s.style.display="block";return(i||document.body).appendChild(s),s},createContext_fn=function(){return{refs:__privateGet(this,_refs4),state:__privateGet(this,_state4),scenes:Object.fromEntries(__privateGet(this,_scenes)),game:__privateGet(this,_game),width:__privateGet(this,_canvas).width,height:__privateGet(this,_canvas).height,showScene:t=>this.showScene(t),hideScene:t=>this.hideScene(t),transition:(t,e,i)=>this.transition(t,e,i)}};class SynthEnvelope{static applyADSR(t,e={}){const{attack:i=.01,decay:s=.1,sustain:n=.7,release:a=.2,startTime:r=0,duration:o=1,peakVolume:h=1}=e,l=h*n,c=Math.max(0,o-i-s);t.setValueAtTime(0,r),t.linearRampToValueAtTime(h,r+i),t.linearRampToValueAtTime(l,r+i+s),t.setValueAtTime(l,r+i+s+c),t.linearRampToValueAtTime(0,r+o+a)}static get presets(){return{pluck:{attack:.001,decay:.2,sustain:0,release:.1},pad:{attack:.5,decay:.3,sustain:.8,release:1},organ:{attack:.01,decay:0,sustain:1,release:.05},perc:{attack:.001,decay:.1,sustain:0,release:.05},string:{attack:.1,decay:.2,sustain:.7,release:.3},brass:{attack:.05,decay:.1,sustain:.8,release:.2},blip:{attack:.001,decay:.05,sustain:0,release:.02},laser:{attack:.001,decay:.15,sustain:0,release:.05},explosion:{attack:.001,decay:.3,sustain:.2,release:.5}}}}class SynthOscillators{static init(t,e){__privateSet(this,__ctx,t),__privateSet(this,__output,e)}static get ctx(){return __privateGet(this,__ctx)}static get now(){return __privateGet(this,__ctx).currentTime}static tone(t,e,i={}){const{type:s="sine",volume:n=.5,attack:a=.01,decay:r=.1,sustain:o=.7,release:h=.2,detune:l=0,startTime:c=__privateGet(this,__ctx).currentTime}=i,_=__privateGet(this,__ctx).createOscillator(),u=__privateGet(this,__ctx).createGain();return _.type=s,_.frequency.setValueAtTime(t,c),_.detune.setValueAtTime(l,c),SynthEnvelope.applyADSR(u.gain,{attack:a,decay:r,sustain:o,release:h,startTime:c,duration:e,peakVolume:n}),_.connect(u),u.connect(__privateGet(this,__output)),_.start(c),_.stop(c+e+h),_}static continuous(t={}){const{type:e="sine",frequency:i=440,volume:s=.5}=t,n=__privateGet(this,__ctx).createOscillator(),a=__privateGet(this,__ctx).createGain();n.type=e,n.frequency.value=i,a.gain.value=s,n.connect(a),a.connect(__privateGet(this,__output)),n.start();const r=__privateGet(this,__ctx);return{osc:n,gain:a,setFrequency:(t,e=0)=>{e>0?n.frequency.linearRampToValueAtTime(t,r.currentTime+e):n.frequency.setValueAtTime(t,r.currentTime)},setVolume:(t,e=0)=>{e>0?a.gain.linearRampToValueAtTime(t,r.currentTime+e):a.gain.setValueAtTime(t,r.currentTime)},stop:(t=0)=>{t>0?(a.gain.linearRampToValueAtTime(0,r.currentTime+t),n.stop(r.currentTime+t+.01)):n.stop()}}}static fm(t,e,i,s,n={}){const{volume:a=.5,startTime:r=__privateGet(this,__ctx).currentTime}=n,o=__privateGet(this,__ctx).createOscillator(),h=__privateGet(this,__ctx).createOscillator(),l=__privateGet(this,__ctx).createGain(),c=__privateGet(this,__ctx).createGain();return h.frequency.value=e,l.gain.value=i,o.frequency.value=t,c.gain.value=a,h.connect(l),l.connect(o.frequency),o.connect(c),c.connect(__privateGet(this,__output)),c.gain.setValueAtTime(a,r),c.gain.linearRampToValueAtTime(0,r+s),h.start(r),o.start(r),h.stop(r+s+.1),o.stop(r+s+.1),{carrier:o,modulator:h,outputGain:c}}static additive(t,e,i,s={}){const{volume:n=.5,startTime:a=__privateGet(this,__ctx).currentTime}=s,r=[],o=__privateGet(this,__ctx).createGain();return o.gain.value=n/e.length,o.connect(__privateGet(this,__output)),o.gain.setValueAtTime(n/e.length,a),o.gain.linearRampToValueAtTime(0,a+i),e.forEach(((e,s)=>{if(e>0){const n=__privateGet(this,__ctx).createOscillator(),h=__privateGet(this,__ctx).createGain();n.frequency.value=t*(s+1),h.gain.value=e,n.connect(h),h.connect(o),n.start(a),n.stop(a+i+.1),r.push(n)}})),r}static sweep(t,e,i,s={}){const{type:n="sine",volume:a=.5,exponential:r=!0,startTime:o=__privateGet(this,__ctx).currentTime}=s,h=__privateGet(this,__ctx).createOscillator(),l=__privateGet(this,__ctx).createGain();return h.type=n,h.frequency.setValueAtTime(t,o),r&&e>0?h.frequency.exponentialRampToValueAtTime(e,o+i):h.frequency.linearRampToValueAtTime(e,o+i),l.gain.setValueAtTime(a,o),l.gain.linearRampToValueAtTime(0,o+i),h.connect(l),l.connect(__privateGet(this,__output)),h.start(o),h.stop(o+i+.01),h}static pulse(t,e,i=.5,s={}){const{volume:n=.5,startTime:a=__privateGet(this,__ctx).currentTime}=s,r=__privateGet(this,__ctx).createOscillator(),o=__privateGet(this,__ctx).createOscillator(),h=__privateGet(this,__ctx).createGain(),l=__privateGet(this,__ctx).createGain(),c=__privateGet(this,__ctx).createGain();return r.type="sawtooth",o.type="sawtooth",r.frequency.value=t,o.frequency.value=t,h.gain.value=.5,l.gain.value=-.5,c.gain.setValueAtTime(n,a),c.gain.linearRampToValueAtTime(0,a+e),r.connect(h),o.connect(l),h.connect(c),l.connect(c),c.connect(__privateGet(this,__output)),r.start(a),o.start(a),r.stop(a+e+.01),o.stop(a+e+.01),{osc1:r,osc2:o,output:c}}}__ctx=new WeakMap,__output=new WeakMap,__privateAdd(SynthOscillators,__ctx,null),__privateAdd(SynthOscillators,__output,null);class SynthEffects{static init(t,e){__privateSet(this,__ctx2,t),__privateSet(this,__output2,e)}static get ctx(){return __privateGet(this,__ctx2)}static filter(t="lowpass",e=1e3,i=1){const s=__privateGet(this,__ctx2).createBiquadFilter();return s.type=t,s.frequency.value=e,s.Q.value=i,s}static delay(t=.3,e=.4,i=.5){const s=__privateGet(this,__ctx2).createDelay(5),n=__privateGet(this,__ctx2).createGain(),a=__privateGet(this,__ctx2).createGain(),r=__privateGet(this,__ctx2).createGain(),o=__privateGet(this,__ctx2).createGain(),h=__privateGet(this,__ctx2).createGain();return s.delayTime.value=t,n.gain.value=e,a.gain.value=i,r.gain.value=1-i,o.connect(s),o.connect(r),s.connect(n),n.connect(s),s.connect(a),a.connect(h),r.connect(h),{input:o,output:h,setTime:t=>s.delayTime.setValueAtTime(t,__privateGet(this,__ctx2).currentTime),setFeedback:t=>n.gain.setValueAtTime(t,__privateGet(this,__ctx2).currentTime),setMix:t=>{a.gain.setValueAtTime(t,__privateGet(this,__ctx2).currentTime),r.gain.setValueAtTime(1-t,__privateGet(this,__ctx2).currentTime)}}}static reverb(t=2,e=2){const i=__privateGet(this,__ctx2).createConvolver(),s=__privateGet(this,__ctx2).sampleRate,n=s*t,a=__privateGet(this,__ctx2).createBuffer(2,n,s);for(let t=0;t<2;t++){const i=a.getChannelData(t);for(let t=0;t<n;t++)i[t]=(2*Math.random()-1)*Math.pow(1-t/n,e)}return i.buffer=a,i}static distortion(t=50){const e=__privateGet(this,__ctx2).createWaveShaper(),i=t,s=44100,n=new Float32Array(s);for(let t=0;t<s;t++){const e=2*t/s-1;n[t]=(3+i)*e*20*(Math.PI/180)/(Math.PI+i*Math.abs(e))}return e.curve=n,e.oversample="4x",e}static tremolo(t=5,e=.5){const i=__privateGet(this,__ctx2).createOscillator(),s=__privateGet(this,__ctx2).createGain(),n=__privateGet(this,__ctx2).createGain();return i.frequency.value=t,s.gain.value=.5*e,n.gain.value=1-.5*e,i.connect(s),s.connect(n.gain),i.start(),{input:n,output:n,lfo:i,setRate:t=>i.frequency.setValueAtTime(t,__privateGet(this,__ctx2).currentTime),setDepth:t=>s.gain.setValueAtTime(.5*t,__privateGet(this,__ctx2).currentTime),stop:()=>i.stop()}}static compressor(t={}){const{threshold:e=-24,knee:i=30,ratio:s=12,attack:n=.003,release:a=.25}=t,r=__privateGet(this,__ctx2).createDynamicsCompressor();return r.threshold.value=e,r.knee.value=i,r.ratio.value=s,r.attack.value=n,r.release.value=a,r}static panner(t=0){const e=__privateGet(this,__ctx2).createStereoPanner();return e.pan.value=t,e}static gain(t=1){const e=__privateGet(this,__ctx2).createGain();return e.gain.value=t,e}}__ctx2=new WeakMap,__output2=new WeakMap,__privateAdd(SynthEffects,__ctx2,null),__privateAdd(SynthEffects,__output2,null);class SynthNoise{static white(t,e){const i=t.sampleRate*e,s=t.createBuffer(1,i,t.sampleRate),n=s.getChannelData(0);for(let t=0;t<i;t++)n[t]=2*Math.random()-1;const a=t.createBufferSource();return a.buffer=s,a}static pink(t,e){const i=t.sampleRate*e,s=t.createBuffer(1,i,t.sampleRate),n=s.getChannelData(0);let a=0,r=0,o=0,h=0,l=0,c=0,_=0;for(let t=0;t<i;t++){const e=2*Math.random()-1;a=.99886*a+.0555179*e,r=.99332*r+.0750759*e,o=.969*o+.153852*e,h=.8665*h+.3104856*e,l=.55*l+.5329522*e,c=-.7616*c-.016898*e,n[t]=.11*(a+r+o+h+l+c+_+.5362*e),_=.115926*e}const u=t.createBufferSource();return u.buffer=s,u}static brown(t,e){const i=t.sampleRate*e,s=t.createBuffer(1,i,t.sampleRate),n=s.getChannelData(0);let a=0;for(let t=0;t<i;t++){const e=2*Math.random()-1;n[t]=(a+.02*e)/1.02,a=n[t],n[t]*=3.5}const r=t.createBufferSource();return r.buffer=s,r}}class SynthMusical{static noteToFreq(t){const e=t.match(/^([A-G][#b]?)(\d+)$/);if(!e)throw new Error(`Invalid note: ${t}`);const[,i,s]=e,n=this.NOTE_FREQUENCIES[i];if(void 0===n)throw new Error(`Unknown note: ${i}`);return n*Math.pow(2,parseInt(s))}static scale(t,e="major",i=1){const s=this.noteToFreq(t),n=this.SCALES[e];if(!n)throw new Error(`Unknown scale: ${e}`);const a=[];for(let t=0;t<i;t++)for(const e of n)a.push(s*Math.pow(2,(e+12*t)/12));return a}static chord(t,e="major"){const i=this.noteToFreq(t),s=this.CHORDS[e];if(!s)throw new Error(`Unknown chord type: ${e}`);return s.map((t=>i*Math.pow(2,t/12)))}static mapToScale(t,e="C4",i="pentatonic",s=2){const n=this.scale(e,i,s),a=Math.max(0,Math.min(1,t));return n[Math.floor(a*n.length)%n.length]}static midiToFreq(t){return 440*Math.pow(2,(t-69)/12)}static freqToMidi(t){return Math.round(12*Math.log2(t/440)+69)}static randomNote(t="C4",e="pentatonic",i=2){const s=this.scale(t,e,i);return s[Math.floor(Math.random()*s.length)]}static detune(t,e){return t*Math.pow(2,e/1200)}}__publicField(SynthMusical,"NOTE_FREQUENCIES",{C:16.35,"C#":17.32,Db:17.32,D:18.35,"D#":19.45,Eb:19.45,E:20.6,F:21.83,"F#":23.12,Gb:23.12,G:24.5,"G#":25.96,Ab:25.96,A:27.5,"A#":29.14,Bb:29.14,B:30.87}),__publicField(SynthMusical,"SCALES",{major:[0,2,4,5,7,9,11],minor:[0,2,3,5,7,8,10],pentatonic:[0,2,4,7,9],pentatonicMinor:[0,3,5,7,10],blues:[0,3,5,6,7,10],dorian:[0,2,3,5,7,9,10],mixolydian:[0,2,4,5,7,9,10],chromatic:[0,1,2,3,4,5,6,7,8,9,10,11],wholeTone:[0,2,4,6,8,10],diminished:[0,2,3,5,6,8,9,11]}),__publicField(SynthMusical,"CHORDS",{major:[0,4,7],minor:[0,3,7],diminished:[0,3,6],augmented:[0,4,8],sus2:[0,2,7],sus4:[0,5,7],major7:[0,4,7,11],minor7:[0,3,7,10],dom7:[0,4,7,10],dim7:[0,3,6,9],add9:[0,4,7,14],power:[0,7]});class SynthAnalyzer{static init(t,e){__privateSet(this,__ctx3,t),__privateSet(this,__analyzer,t.createAnalyser()),__privateGet(this,__analyzer).fftSize=2048,e.connect(__privateGet(this,__analyzer)),__privateGet(this,__analyzer).connect(t.destination),__privateSet(this,__dataArray,new Uint8Array(__privateGet(this,__analyzer).frequencyBinCount)),__privateSet(this,__frequencyData,new Uint8Array(__privateGet(this,__analyzer).frequencyBinCount))}static get isInitialized(){return null!==__privateGet(this,__analyzer)}static get node(){return __privateGet(this,__analyzer)}static setFFTSize(t){__privateGet(this,__analyzer)&&(__privateGet(this,__analyzer).fftSize=t,__privateSet(this,__dataArray,new Uint8Array(__privateGet(this,__analyzer).frequencyBinCount)),__privateSet(this,__frequencyData,new Uint8Array(__privateGet(this,__analyzer).frequencyBinCount)))}static getWaveform(){return __privateGet(this,__analyzer)?(__privateGet(this,__analyzer).getByteTimeDomainData(__privateGet(this,__dataArray)),__privateGet(this,__dataArray)):new Uint8Array(0)}static getFrequency(){return __privateGet(this,__analyzer)?(__privateGet(this,__analyzer).getByteFrequencyData(__privateGet(this,__frequencyData)),__privateGet(this,__frequencyData)):new Uint8Array(0)}static getBands(t=8){const e=this.getFrequency();if(0===e.length)return new Array(t).fill(0);const i=Math.floor(e.length/t),s=[];for(let n=0;n<t;n++){let t=0;for(let s=0;s<i;s++)t+=e[n*i+s];s.push(t/(255*i))}return s}static getAmplitude(){const t=this.getWaveform();if(0===t.length)return 0;let e=0;for(let i=0;i<t.length;i++){const s=(t[i]-128)/128;e+=s*s}return Math.sqrt(e/t.length)}static getPeakFrequency(){if(!__privateGet(this,__analyzer)||!__privateGet(this,__ctx3))return 0;const t=this.getFrequency();let e=0,i=0;for(let s=0;s<t.length;s++)t[s]>i&&(i=t[s],e=s);return e*(__privateGet(this,__ctx3).sampleRate/2)/__privateGet(this,__analyzer).frequencyBinCount}static dispose(){__privateGet(this,__analyzer)&&(__privateGet(this,__analyzer).disconnect(),__privateSet(this,__analyzer,null)),__privateSet(this,__dataArray,null),__privateSet(this,__frequencyData,null)}}__ctx3=new WeakMap,__analyzer=new WeakMap,__dataArray=new WeakMap,__frequencyData=new WeakMap,__privateAdd(SynthAnalyzer,__ctx3,null),__privateAdd(SynthAnalyzer,__analyzer,null),__privateAdd(SynthAnalyzer,__dataArray,null),__privateAdd(SynthAnalyzer,__frequencyData,null);class Synth{static init(t={}){if(__privateGet(this,__initialized))return void console.warn("[Synth] Already initialized");const{masterVolume:e=.5,sampleRate:i=44100,enableAnalyzer:s=!1}=t;try{__privateSet(this,__ctx4,new(window.AudioContext||window.webkitAudioContext)({sampleRate:i})),__privateSet(this,__masterGain,__privateGet(this,__ctx4).createGain()),__privateGet(this,__masterGain).gain.value=e,__privateGet(this,__masterGain).connect(__privateGet(this,__ctx4).destination),SynthOscillators.init(__privateGet(this,__ctx4),__privateGet(this,__masterGain)),SynthEffects.init(__privateGet(this,__ctx4),__privateGet(this,__masterGain)),s&&SynthAnalyzer.init(__privateGet(this,__ctx4),__privateGet(this,__masterGain)),__privateSet(this,__initialized,!0),console.log("[Synth] Audio system initialized")}catch(t){console.error("[Synth] Failed to initialize audio:",t)}}static get isInitialized(){return __privateGet(this,__initialized)}static get ctx(){return __privateGet(this,__ctx4)}static get master(){return __privateGet(this,__masterGain)}static get osc(){return SynthOscillators}static get fx(){return SynthEffects}static get env(){return SynthEnvelope}static get noise(){return SynthNoise}static get music(){return SynthMusical}static get analyzer(){return SynthAnalyzer}static async resume(){__privateGet(this,__ctx4)&&"suspended"===__privateGet(this,__ctx4).state&&(await __privateGet(this,__ctx4).resume(),console.log("[Synth] Audio context resumed"))}static async suspend(){__privateGet(this,__ctx4)&&"running"===__privateGet(this,__ctx4).state&&await __privateGet(this,__ctx4).suspend()}static get now(){return __privateGet(this,__ctx4)?__privateGet(this,__ctx4).currentTime:0}static get state(){return __privateGet(this,__ctx4)?__privateGet(this,__ctx4).state:"closed"}static set volume(t){__privateGet(this,__masterGain)&&__privateGet(this,__masterGain).gain.setValueAtTime(Math.max(0,Math.min(1,t)),__privateGet(this,__ctx4).currentTime)}static get volume(){return __privateGet(this,__masterGain)?__privateGet(this,__masterGain).gain.value:0}static chain(...t){for(let e=0;e<t.length-1;e++)t[e].connect(t[e+1]);return{first:t[0],last:t[t.length-1],connectTo:e=>t[t.length-1].connect(e)}}static schedule(t,e){const i=Math.max(0,1e3*(e-this.now));return setTimeout(t,i)}static async close(){__privateGet(this,__ctx4)&&(SynthAnalyzer.dispose(),await __privateGet(this,__ctx4).close(),__privateSet(this,__ctx4,null),__privateSet(this,__masterGain,null),__privateSet(this,__initialized,!1),console.log("[Synth] Audio system closed"))}}__ctx4=new WeakMap,__masterGain=new WeakMap,__initialized=new WeakMap,__privateAdd(Synth,__ctx4,null),__privateAdd(Synth,__masterGain,null),__privateAdd(Synth,__initialized,!1);class Sound{static beep(t=440,e=.1,i={}){if(!Synth.isInitialized)return;const{volume:s=.3,type:n="sine"}=i;Synth.osc.tone(t,e,{type:n,volume:s,attack:.001,decay:.8*e,sustain:0,release:.2*e})}static click(t=.3){Synth.isInitialized&&Synth.osc.tone(1e3,.01,{type:"square",volume:t,attack:.001,decay:.009,sustain:0,release:.001})}static sweep(t,e,i,s={}){if(!Synth.isInitialized)return;const{volume:n=.3,type:a="sine"}=s;Synth.osc.sweep(t,e,i,{type:a,volume:n})}static fromValue(t,e={}){if(!Synth.isInitialized)return;const{root:i="C4",scale:s="pentatonic",octaves:n=2,duration:a=.2,volume:r=.3,type:o="sine"}=e,h=Synth.music.mapToScale(t,i,s,n);Synth.osc.tone(h,a,{volume:r,type:o})}static impact(t=.5){if(!Synth.isInitialized)return;const e=80+200*t,i=.05+.15*t;Synth.osc.tone(e,i,{type:"sine",volume:.4*t,attack:.001,decay:i,sustain:0,release:.02});const s=Synth.noise.white(Synth.ctx,.08),n=Synth.ctx.createGain();n.gain.setValueAtTime(.25*t,Synth.now),n.gain.exponentialRampToValueAtTime(.001,Synth.now+.08),s.connect(n),n.connect(Synth.master),s.start(),s.stop(Synth.now+.1)}static explosion(t=.7){if(!Synth.isInitialized)return;const e=.3+.4*t;Synth.osc.tone(50+30*t,e,{type:"sine",volume:.4*t,attack:.001,decay:.3*e,sustain:.3,release:.7*e});const i=Synth.noise.brown(Synth.ctx,e),s=Synth.ctx.createGain(),n=Synth.fx.filter("lowpass",800+400*t,1);s.gain.setValueAtTime(.5*t,Synth.now),s.gain.exponentialRampToValueAtTime(.001,Synth.now+e),i.connect(n),n.connect(s),s.connect(Synth.master),i.start(),i.stop(Synth.now+e+.1)}static laser(t={}){if(!Synth.isInitialized)return;const{startFreq:e=1200,endFreq:i=200,duration:s=.15,volume:n=.25,type:a="sawtooth"}=t;Synth.osc.sweep(e,i,s,{type:a,volume:n})}static powerUp(t={}){if(!Synth.isInitialized)return;const{startFreq:e=300,endFreq:i=1200,duration:s=.3,volume:n=.3}=t;Synth.osc.sweep(e,i,s,{type:"square",volume:n}),Synth.osc.sweep(1.5*e,1.5*i,s,{type:"sine",volume:.5*n})}static hurt(t=.5){Synth.isInitialized&&(Synth.osc.tone(80+40*t,.1,{type:"sine",volume:.4*t,attack:.001,decay:.08,sustain:0,release:.02}),Synth.osc.tone(200+100*t,.08,{type:"sawtooth",volume:.2*t,attack:.001,decay:.06,sustain:0,release:.02}))}static coin(t={}){if(!Synth.isInitialized)return;const{baseFreq:e=987.77,volume:i=.25}=t;Synth.osc.tone(e,.08,{type:"square",volume:i,attack:.001,decay:.05,sustain:.3,release:.02}),setTimeout((()=>{Synth.isInitialized&&Synth.osc.tone(1.5*e,.12,{type:"square",volume:i,attack:.001,decay:.08,sustain:.2,release:.04})}),80)}static jump(t={}){if(!Synth.isInitialized)return;const{startFreq:e=150,endFreq:i=400,duration:s=.15,volume:n=.25}=t;Synth.osc.sweep(e,i,s,{type:"square",volume:n})}static select(t={}){if(!Synth.isInitialized)return;const{frequency:e=660,volume:i=.2}=t;Synth.osc.tone(e,.08,{type:"sine",volume:i,attack:.001,decay:.05,sustain:.3,release:.03})}static error(t={}){if(!Synth.isInitialized)return;const{volume:e=.25}=t;Synth.osc.tone(400,.1,{type:"square",volume:e,attack:.001,decay:.08,sustain:0,release:.02}),setTimeout((()=>{Synth.isInitialized&&Synth.osc.tone(300,.15,{type:"square",volume:e,attack:.001,decay:.12,sustain:0,release:.03})}),100)}static drone(t="C2",e={}){if(!Synth.isInitialized)return null;const{volume:i=.2,richness:s=.5}=e,n=Synth.music.noteToFreq(t),a=[],r=[],o=[1,.5*s,.3*s,.2*s];return[n,1.5*n,2*n,3*n].forEach(((t,e)=>{const s=Synth.ctx.createOscillator(),n=Synth.ctx.createGain();s.type="sine",s.frequency.value=t,n.gain.value=o[e]*i,s.connect(n),n.connect(Synth.master),s.start(),a.push(s),r.push(n)})),{stop:(t=.5)=>{const e=Synth.now;r.forEach((i=>{i.gain.linearRampToValueAtTime(0,e+t)})),setTimeout((()=>{a.forEach((t=>{try{t.stop()}catch(t){}}))}),1e3*t+100)},setVolume:t=>{r.forEach(((e,i)=>{e.gain.linearRampToValueAtTime(o[i]*t,Synth.now+.1)}))}}}static note(t,e=.5,i={}){if(!Synth.isInitialized)return;const{volume:s=.3,type:n="sine",envelope:a={}}=i,r=Synth.music.noteToFreq(t);Synth.osc.tone(r,e,{type:n,volume:s,...Synth.env.presets.pluck,...a})}static chord(t,e="major",i=.5,s={}){if(!Synth.isInitialized)return;const{volume:n=.2,type:a="sine",strum:r=0}=s,o=Synth.music.chord(t,e);o.forEach(((t,e)=>{const s=r*e;Synth.osc.tone(t,i,{type:a,volume:n/o.length,attack:.01,decay:.1,sustain:.6,release:.2,startTime:Synth.now+s})}))}static sequence(t,e=.2,i=0,s={}){if(!Synth.isInitialized)return;const{volume:n=.3,type:a="sine"}=s,r=e+i;t.forEach(((t,i)=>{const s=Synth.now+i*r,o=Synth.music.noteToFreq(t);Synth.osc.tone(o,e,{type:a,volume:n,attack:.01,decay:.05,sustain:.5,release:.1,startTime:s})}))}static win(){if(!Synth.isInitialized)return;this.sequence(["C5","E5","G5","C6"],.15,.05,{volume:.25,type:"square"})}static lose(){if(!Synth.isInitialized)return;this.sequence(["E4","D4","C4"],.25,0,{volume:.25,type:"sawtooth"})}}class Collision{static rectRect(t,e){return t.x<e.x+e.width&&t.x+t.width>e.x&&t.y<e.y+e.height&&t.y+t.height>e.y}static intersects(t,e){return Collision.rectRect(t,e)}static pointRect(t,e,i){return t>=i.x&&t<=i.x+i.width&&e>=i.y&&e<=i.y+i.height}static circleCircle(t,e){const i=t.x-e.x,s=t.y-e.y,n=i*i+s*s,a=t.radius+e.radius;return n<=a*a}static pointCircle(t,e,i){const s=t-i.x,n=e-i.y;return s*s+n*n<=i.radius*i.radius}static circleRect(t,e){const i=Math.max(e.x,Math.min(t.x,e.x+e.width)),s=Math.max(e.y,Math.min(t.y,e.y+e.height)),n=t.x-i,a=t.y-s;return n*n+a*a<=t.radius*t.radius}static lineRect(t,e,i,s,n,a=0){const r=n.x-a/2,o=n.y-a/2,h=n.width+a,l=n.height+a;if(Collision.pointRect(t,e,{x:r,y:o,width:h,height:l})||Collision.pointRect(i,s,{x:r,y:o,width:h,height:l}))return!0;const c=Collision.lineLine(t,e,i,s,r,o,r,o+l),_=Collision.lineLine(t,e,i,s,r+h,o,r+h,o+l),u=Collision.lineLine(t,e,i,s,r,o,r+h,o),d=Collision.lineLine(t,e,i,s,r,o+l,r+h,o+l);return c||_||u||d}static lineLine(t,e,i,s,n,a,r,o){const h=(o-a)*(i-t)-(r-n)*(s-e);if(0===h)return!1;const l=((r-n)*(e-a)-(o-a)*(t-n))/h,c=((i-t)*(e-a)-(s-e)*(t-n))/h;return l>=0&&l<=1&&c>=0&&c<=1}static segmentsRect(t,e,i=0){for(const s of t)if(Collision.lineRect(s.x1,s.y1,s.x2,s.y2,e,i))return!0;return!1}static getOverlap(t,e){if(!Collision.rectRect(t,e))return null;return{x:Math.min(t.x+t.width,e.x+e.width)-Math.max(t.x,e.x),y:Math.min(t.y+t.height,e.y+e.height)-Math.max(t.y,e.y)}}static getMTV(t,e){const i=Collision.getOverlap(t,e);if(!i)return null;const s=t.x+t.width/2,n=t.y+t.height/2,a=e.x+e.width/2,r=e.y+e.height/2,o=s<a?-i.x:i.x,h=n<r?-i.y:i.y;return Math.abs(i.x)<Math.abs(i.y)?{x:o,y:0}:{x:0,y:h}}static sweep(t,e,i,s){const n=s.x-t.width/2,a=s.y-t.height/2,r=s.width+t.width,o=s.height+t.height,h=t.x+t.width/2,l=t.y+t.height/2;let c,_,u,d;0!==e?(c=(n-h)/e,_=(n+r-h)/e,c>_&&([c,_]=[_,c])):(c=h>=n&&h<=n+r?-1/0:1/0,_=h>=n&&h<=n+r?1/0:-1/0),0!==i?(u=(a-l)/i,d=(a+o-l)/i,u>d&&([u,d]=[d,u])):(u=l>=a&&l<=a+o?-1/0:1/0,d=l>=a&&l<=a+o?1/0:-1/0);const p=Math.max(c,u);if(p>Math.min(_,d)||p<0||p>1)return null;let g=0,f=0;return c>u?g=e>0?-1:1:f=i>0?-1:1,{time:p,normalX:g,normalY:f}}}class CollisionSystem{constructor(){this.groups=new Map,this.pairs=[],this.useQuadtree=!1}createGroup(t){return this.groups.has(t)||this.groups.set(t,new Set),this}add(t,e){const i=this.groups.get(t);if(!i)throw new Error(`Collision group '${t}' does not exist. Call createGroup('${t}') first.`);return i.add(e),this}remove(t,e){const i=this.groups.get(t);return!!i&&i.delete(e)}removeFromAll(t){for(const e of this.groups.values())e.delete(t)}clearGroup(t){const e=this.groups.get(t);e&&e.clear()}clearAll(){for(const t of this.groups.values())t.clear()}getGroup(t){const e=this.groups.get(t);return e?Array.from(e):[]}onCollision(t,e,i,s={}){return this.pairs.push({groupA:t,groupB:e,callback:i,once:s.once??!1}),this}offCollision(t,e){this.pairs=this.pairs.filter((i=>!(i.groupA===t&&i.groupB===e)))}update(){for(const t of this.pairs)this._checkPair(t)}check(t,e){const i=this.groups.get(t),s=this.groups.get(e);if(!i||!s)return[];const n=[];for(const t of i){if(!this._isActive(t))continue;const e=this._getBounds(t);if(e)for(const i of s){if(t===i)continue;if(!this._isActive(i))continue;const s=this._getBounds(i);s&&(Collision.rectRect(e,s)&&n.push([t,i]))}}return n}checkAgainstGroup(t,e){const i=this.groups.get(e);if(!i)return null;const s=this._getBounds(t);if(!s)return null;for(const e of i){if(t===e)continue;if(!this._isActive(e))continue;const i=this._getBounds(e);if(i&&Collision.rectRect(s,i))return e}return null}checkAllAgainstGroup(t,e){const i=this.groups.get(e);if(!i)return[];const s=this._getBounds(t);if(!s)return[];const n=[];for(const e of i){if(t===e)continue;if(!this._isActive(e))continue;const i=this._getBounds(e);i&&(Collision.rectRect(s,i)&&n.push(e))}return n}_checkPair(t){const e=this.groups.get(t.groupA),i=this.groups.get(t.groupB);if(e&&i)for(const s of e){if(!this._isActive(s))continue;const e=this._getBounds(s);if(e)for(const n of i){if(s===n)continue;if(!this._isActive(n))continue;const i=this._getBounds(n);if(i&&(Collision.rectRect(e,i)&&(t.callback(s,n),t.once)))break}}}_getBounds(t){return"function"==typeof t.getBounds?t.getBounds():t.bounds?t.bounds:void 0!==t.x&&void 0!==t.y?{x:t.x-(t.width||0)/2,y:t.y-(t.height||0)/2,width:t.width||0,height:t.height||0}:null}_isActive(t){return!1!==t.active&&(!0!==t.destroyed&&!1!==t.alive)}}class StateMachine{constructor(t={}){this.states=t.states||{},this.currentState=null,this.previousState=null,this.stateTime=0,this.context=t.context||null,this.paused=!1,this.onStateChange=null,t.initial&&this.setState(t.initial)}get state(){return this.currentState}get currentStateConfig(){return this.currentState?this.states[this.currentState]:null}is(t){return this.currentState===t}isAny(...t){return t.includes(this.currentState)}addState(t,e){return this.states[t]=e,this}removeState(t){return delete this.states[t],this}setState(t,e){if(!this.states[t])return console.warn(`StateMachine: Unknown state '${t}'`),!1;if(this.currentState){const t=this.states[this.currentState];(null==t?void 0:t.exit)&&this._call(t.exit,e)}this.previousState=this.currentState,this.currentState=t,this.stateTime=0;const i=this.states[t];return(null==i?void 0:i.enter)&&this._call(i.enter,e),this.onStateChange&&this.onStateChange(t,this.previousState,e),!0}trigger(t,e){const i=this.currentStateConfig;if(!(null==i?void 0:i.on))return!1;const s=i.on[t];return!!s&&("string"==typeof s?this.setState(s,e):!(s.guard&&!this._call(s.guard,e))&&(s.action&&this._call(s.action,e),!!s.target&&this.setState(s.target,e)))}update(t){if(this.paused||!this.currentState)return;this.stateTime+=t;const e=this.states[this.currentState];e&&(e.update&&this._call(e.update,t),void 0!==e.duration&&this.stateTime>=e.duration&&(e.next?this.setState(e.next):e.onComplete&&this._call(e.onComplete)))}get progress(){const t=this.currentStateConfig;return(null==t?void 0:t.duration)?Math.min(1,this.stateTime/t.duration):0}get remaining(){const t=this.currentStateConfig;return(null==t?void 0:t.duration)?Math.max(0,t.duration-this.stateTime):1/0}get isTimed(){var t;return void 0!==(null==(t=this.currentStateConfig)?void 0:t.duration)}pause(){this.paused=!0}resume(){this.paused=!1}reset(t){if(this.stateTime=0,this.previousState=null,t)this.setState(t);else{const t=Object.keys(this.states)[0];t&&this.setState(t)}}_call(t,...e){if("function"==typeof t)return this.context?t.call(this.context,...e):t(...e)}static fromSequence(t,e={}){var i;const s={};for(let i=0;i<t.length;i++){const n=t[i],a=i===t.length-1,r=a?e.loop?t[0].name:null:t[i+1].name;s[n.name]={duration:n.duration,next:r,enter:n.enter,update:n.update,exit:n.exit,onComplete:a&&!e.loop?e.onComplete:void 0}}return new StateMachine({initial:null==(i=t[0])?void 0:i.name,states:s,context:e.context})}}export{Arc,Arrow,BezierShape,Button,Camera3D,Circle,Cloud,Collision,CollisionSystem,Complex,Cone,Cross,Cube,Cursor,Cylinder,DebugTab,Diamond,Easing,Euclidian,EventEmitter,FPSCounter,FluentGO,FluentGame,FluentLayer,FluentScene,Fractals,Game,GameObject,GameObjectShapeWrapper,Geometry2d,GridLayout,Group,Heart,Hexagon,HorizontalLayout,ImageGo,Input,Keys,LayoutScene,Line,Loggable,Logger,Motion,Mouse,Noise,OutlinedText,Painter,PainterColors,PainterEffects,PainterImages,PainterLines,PainterOpacity,PainterShapes,PainterText,PatternRectangle,Patterns,PieSlice,Pin,Pipeline,Polygon,Position,Prism,Random,Rectangle,Renderable,Ring,RoundedRectangle,SVGShape,Scene,Shape,ShapeGOFactory,Sound,Sphere,Square,Star,StateMachine,StickFigure,Synth,SynthAnalyzer,SynthEffects,SynthEnvelope,SynthMusical,SynthNoise,SynthOscillators,TaskManager,Tensor,Text,TextShape,TileLayout,ToggleButton,Tooltip,Touch,Traceable,Transform,Transformable,Triangle,Tween,Tweenetik,VerticalLayout,WrappedText,ZOrderedCollection,applyAnchor,applyDraggable,applyLayout,bezierV1,bounceV1,floatV1,followPath,gcanvas,gridLayout,hopV1,horizontalLayout,orbitV1,oscillateV1,parabolicV1,patrolV1,pendulumV1,pulseV1,shakeV1,sketch,spiralV1,springV1,swingV1,tileLayout,verticalLayout,waypointV1};