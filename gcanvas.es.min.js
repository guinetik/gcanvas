var __defProp=Object.defineProperty,__defNormalProp=(t,e,i)=>e in t?__defProp(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i,__publicField=(t,e,i)=>__defNormalProp(t,"symbol"!=typeof e?e+"":e,i);class PainterColors{static fill(t){Painter.ctx.fillStyle=t}static strokeOptions(t){t.color&&(Painter.ctx.strokeStyle=t.color),void 0!==t.lineWidth&&(Painter.ctx.lineWidth=t.lineWidth),t.lineCap&&(Painter.ctx.lineCap=t.lineCap),t.lineJoin&&(Painter.ctx.lineJoin=t.lineJoin),t.strokeStyle&&(Painter.ctx.strokeStyle=t.strokeStyle)}static stroke(t,e){t&&(Painter.ctx.strokeStyle=t),void 0!==e&&(Painter.ctx.lineWidth=e),Painter.ctx.stroke()}static setFillColor(t){Painter.ctx.fillStyle=t}static setStrokeColor(t){Painter.ctx.strokeStyle=t}static randomColorRGB(){const t=Math.floor(360*Math.random()),e=70+Math.floor(30*Math.random()),i=50+Math.floor(20*Math.random());return Painter.colors.hslToRgb(t,e,i)}static randomColorHSL(){return`hsl(${360*Math.random()}, 100%, 50%)`}static randomColorHEX(){return"#"+(1048575*Math.random()*1e6).toString(16).slice(0,6)}static parseColorString(t){if((t=t.trim().toLowerCase()).startsWith("hsl")){const e=t.replace(/hsla?\(|\)/g,""),[i,s,n]=e.split(",").map((t=>t.trim())),o=parseFloat(i),a=parseFloat(s)/100,r=parseFloat(n)/100;return Painter.colors.hslToRgb(o,a,r)}if(t.startsWith("#"))return hexToRgb(t);if(t.startsWith("rgb")){const e=t.replace(/rgba?\(|\)/g,""),[i,s,n]=e.split(",").map((t=>parseInt(t.trim())));return[i,s,n]}return[0,0,0]}static rgbArrayToCSS([t,e,i]){return`rgb(${Math.round(t)}, ${Math.round(e)}, ${Math.round(i)})`}static hslToRgb(t,e,i){const s=(1-Math.abs(2*i-1))*e,n=t/60,o=s*(1-Math.abs(n%2-1));let[a,r,h]=[0,0,0];n>=0&&n<1?[a,r,h]=[s,o,0]:n>=1&&n<2?[a,r,h]=[o,s,0]:n>=2&&n<3?[a,r,h]=[0,s,o]:n>=3&&n<4?[a,r,h]=[0,o,s]:n>=4&&n<5?[a,r,h]=[o,0,s]:n>=5&&n<6&&([a,r,h]=[s,0,o]);const l=i-s/2;return[255*(a+l),255*(r+l),255*(h+l)]}static rgbToHsl(t,e,i){t/=255,e/=255,i/=255;const s=Math.max(t,e,i),n=Math.min(t,e,i),o=s-n;let a=0,r=0,h=(s+n)/2;if(0!==o)switch(r=o/(1-Math.abs(2*h-1)),s){case t:a=((e-i)/o+6)%6*60;break;case e:a=60*((i-t)/o+2);break;case i:a=60*((t-e)/o+4)}return[a%360,r,h]}static hexToRgb(t){const e=t.replace("#","");return[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}static linearGradient(t,e,i,s,n){const o=Painter.ctx.createLinearGradient(t,e,i,s);for(const t of n)o.addColorStop(t.offset,t.color);return o}static radialGradient(t,e,i,s,n,o,a){const r=Painter.ctx.createRadialGradient(t,e,i,s,n,o);for(const t of a)r.addColorStop(t.offset,t.color);return r}static verticalGradient(t,e,i,s,n){return Painter.colors.linearGradient(t,e,t,e+s,n)}static horizontalGradient(t,e,i,s,n){return Painter.colors.linearGradient(t,e,t+i,e,n)}static conicGradient(t,e,i,s){if("function"==typeof Painter.ctx.createConicGradient){const n=Painter.ctx.createConicGradient(i,t,e);for(const t of s)n.addColorStop(t.offset,t.color);return n}return null}static rgba(t,e,i,s=1){return`rgba(${Math.round(t)}, ${Math.round(e)}, ${Math.round(i)}, ${s})`}static hsl(t,e,i){return`hsl(${t}, ${e}%, ${i}%)`}static hsla(t,e,i,s){return`hsla(${t}, ${e}%, ${i}%, ${s})`}}class PainterEffects{static dropShadow(t,e,i=0,s=0){Painter.ctx.shadowColor=t,Painter.ctx.shadowBlur=e,Painter.ctx.shadowOffsetX=i,Painter.ctx.shadowOffsetY=s}static clearShadow(){Painter.ctx.shadowColor="rgba(0, 0, 0, 0)",Painter.ctx.shadowBlur=0,Painter.ctx.shadowOffsetX=0,Painter.ctx.shadowOffsetY=0}static setAlpha(t){Painter.ctx.globalAlpha=t}static setBlendMode(t){Painter.ctx.globalCompositeOperation=t}static clipRect(t,e,i,s){Painter.ctx.beginPath(),Painter.ctx.rect(t,e,i,s),Painter.ctx.clip()}static clipCircle(t,e,i){Painter.ctx.beginPath(),Painter.ctx.arc(t,e,i,0,2*Math.PI),Painter.ctx.clip()}static blurRegion(t,e,i,s,n){const o=Painter.ctx.filter;Painter.ctx.filter=`blur(${n}px)`;const a=Painter.ctx.getImageData(t,e,i,s);Painter.ctx.putImageData(a,t,e),Painter.ctx.filter=o}}class PainterImages{static fillPattern(t,e,i,s,n,o){const a=Painter.ctx.createPattern(t,e);Painter.ctx.fillStyle=a,Painter.ctx.fillRect(i,s,n,o)}static createPattern(t,e="repeat"){return Painter.ctx.createPattern(t,e)}}class PainterLines{static path(t,e,i,s=1){const n=Painter.ctx;n.beginPath();for(const e of t){const[t,...i]=e;"M"===t?n.moveTo(...i):"L"===t?n.lineTo(...i):"C"===t?n.bezierCurveTo(...i):"Q"===t?n.quadraticCurveTo(...i):"Z"===t&&n.closePath()}e&&(n.fillStyle=e,Painter.colors.fill()),i&&(n.strokeStyle=i,n.lineWidth=s,Painter.colors.stroke())}static line(t,e,i,s,n,o){Painter.ctx.beginPath(),Painter.ctx.moveTo(t,e),Painter.ctx.lineTo(i,s),n&&(Painter.ctx.strokeStyle=n),void 0!==o&&(Painter.ctx.lineWidth=o),Painter.colors.stroke()}static beginPath(){Painter.ctx.beginPath()}static closePath(){Painter.ctx.closePath()}static moveTo(t,e){Painter.ctx.moveTo(t,e)}static lineTo(t,e){Painter.ctx.lineTo(t,e)}static bezierCurveTo(t,e,i,s,n,o){Painter.ctx.bezierCurveTo(t,e,i,s,n,o)}static dashedLine(t,e,i,s,n,o,a){Painter.ctx.beginPath(),o&&(Painter.ctx.strokeStyle=o),void 0!==a&&(Painter.ctx.lineWidth=a),Painter.ctx.setLineDash(n),Painter.ctx.moveTo(t,e),Painter.ctx.lineTo(i,s),Painter.colors.stroke(),Painter.ctx.setLineDash([])}static dottedLine(t,e,i,s,n=2,o=5,a){return Painter.lines.dashedLine(t,e,i,s,[n,o],a,n)}static setLineDash(t){Painter.ctx.setLineDash(t)}static resetLineDash(){Painter.ctx.setLineDash([])}static setLineWidth(t){Painter.ctx.lineWidth=t}static quadraticCurve(t,e,i,s,n,o,a,r){Painter.ctx.beginPath(),Painter.ctx.moveTo(t,e),Painter.ctx.quadraticCurveTo(i,s,n,o),a&&(Painter.ctx.strokeStyle=a),void 0!==r&&(Painter.ctx.lineWidth=r),Painter.colors.stroke()}}class PainterOpacity{static pushOpacity(t){const e=this._opacityStack[this._opacityStack.length-1]*t;this._opacityStack.push(e),Painter.effects.setAlpha(e)}static popOpacity(){this._opacityStack.length>1&&(this._opacityStack.pop(),Painter.effects.setAlpha(this._opacityStack[this._opacityStack.length-1]))}static setOpacity(t){const e=this._opacityStack[this._opacityStack.length-1]*t;Painter.effects.setAlpha(e)}static _clone(){this._opacityStack=[...this._opacityStack]}}__publicField(PainterOpacity,"_opacityStack",[1]);class PainterShapes{static rect(t,e,i,s,n){const o=Painter.ctx.fillStyle;Painter.colors.fill(n),Painter.ctx.fillRect(t,e,i,s),Painter.ctx.fillStyle=o}static outlineRect(t,e,i,s,n,o=1){const a=Painter.ctx.strokeStyle,r=Painter.ctx.lineWidth;Painter.ctx.strokeStyle=n,Painter.ctx.lineWidth=o,Painter.ctx.strokeRect(t,e,i,s),Painter.ctx.strokeStyle=a,Painter.ctx.lineWidth=r}static roundRect(t,e,i,s,n=0,o,a,r){let h;h="number"==typeof n?[n,n,n,n]:Array.isArray(n)?4===n.length?n:[n[0]||0,n[1]||n[0]||0,n[2]||n[0]||0,n[3]||n[1]||n[0]||0]:[0,0,0,0];const[l,c,u,d]=h,p=t+i,g=e+s;Painter.lines.beginPath(),Painter.lines.moveTo(t+l,e),Painter.lines.lineTo(p-c,e),Painter.ctx.arc(p-c,e+c,c,-Math.PI/2,0),Painter.lines.lineTo(p,g-u),Painter.ctx.arc(p-u,g-u,u,0,Math.PI/2),Painter.lines.lineTo(t+d,g),Painter.ctx.arc(t+d,g-d,d,Math.PI/2,Math.PI),Painter.lines.lineTo(t,e+l),Painter.ctx.arc(t+l,e+l,l,Math.PI,-Math.PI/2),Painter.lines.closePath(),o&&(Painter.fillStyle=o,Painter.colors.fill()),a&&(Painter.strokeStyle=a,void 0!==r&&(Painter.lineWidth=r),Painter.colors.stroke())}static fillRoundRect(t,e,i,s,n=0,o){o&&(Painter.fillStyle=o),Painter.shapes.roundRect(t,e,i,s,n,o,null)}static strokeRoundRect(t,e,i,s,n=0,o,a){o&&(Painter.strokeStyle=o),void 0!==a&&(Painter.lineWidth=a),Painter.shapes.roundRect(t,e,i,s,n,null,o,a)}static fillCircle(t,e,i,s){Painter.lines.beginPath(),Painter.ctx.arc(t,e,i,0,2*Math.PI),s&&(Painter.fillStyle=s),Painter.colors.fill()}static strokeCircle(t,e,i,s,n){Painter.lines.beginPath(),Painter.ctx.arc(t,e,i,0,2*Math.PI),s&&(Painter.strokeStyle=s),void 0!==n&&(Painter.lineWidth=n),Painter.colors.stroke()}static fillEllipse(t,e,i,s,n=0,o){Painter.lines.beginPath(),Painter.ellipse(t,e,i,s,n,0,2*Math.PI),o&&(Painter.fillStyle=o),Painter.colors.fill()}static strokeEllipse(t,e,i,s,n=0,o,a){Painter.lines.beginPath(),Painter.ellipse(t,e,i,s,n,0,2*Math.PI),o&&(Painter.strokeStyle=o),void 0!==a&&(Painter.lineWidth=a),Painter.colors.stroke()}static polygon(t,e,i,s){if(!(t.length<2)){Painter.lines.beginPath(),Painter.lines.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++)Painter.lines.lineTo(t[e].x,t[e].y);Painter.lines.closePath(),e&&Painter.colors.fill(e),i&&(Painter.strokeStyle=i,void 0!==s&&(Painter.lineWidth=s),Painter.colors.stroke())}}}class PainterText{static setFont(t){Painter.ctx.font=t}static setTextAlign(t){Painter.ctx.textAlign=t}static setTextBaseline(t){Painter.ctx.textBaseline=t}static fillText(t,e,i,s,n){s&&(Painter.ctx.fillStyle=s),n&&(Painter.ctx.font=n),Painter.ctx.fillText(t,e,i)}static strokeText(t,e,i,s,n,o){s&&(Painter.ctx.strokeStyle=s),void 0!==n&&(Painter.ctx.lineWidth=n),o&&(Painter.ctx.font=o),Painter.ctx.strokeText(t,e,i)}static measureText(t){return Painter.ctx.measureText(t).width}static outlinedText(t,e,i,s,n,o,a){a&&(Painter.ctx.font=a),Painter.ctx.strokeStyle=n,Painter.ctx.lineWidth=o,Painter.ctx.strokeText(t,e,i),Painter.ctx.fillStyle=s,Painter.ctx.fillText(t,e,i)}static wrappedText(t,e,i,s,n,o,a){o&&(Painter.ctx.fillStyle=o),a&&(Painter.ctx.font=a);const r=t.split(" ");let h="",l="",c=1;for(let t=0;t<r.length;t++){l=h+r[t]+" ";Painter.ctx.measureText(l).width>s&&t>0?(Painter.ctx.fillText(h,e,i),h=r[t]+" ",i+=n,c++):h=l}return Painter.ctx.fillText(h,e,i),c*n}static textOnPath(t,e,i,s,n=!1){if(e.length<2)return;i&&(Painter.ctx.fillStyle=i),s&&(Painter.ctx.font=s);const o=t.split(""),a=o.map((t=>Painter.ctx.measureText(t).width));n&&(o.reverse(),a.reverse(),e.reverse());let r=0;for(let t=1;t<e.length;t++){const i=e[t].x-e[t-1].x,s=e[t].y-e[t-1].y;r+=Math.sqrt(i*i+s*s)}let h=(r-a.reduce(((t,e)=>t+e),0))/2;h<0&&(h=0);let l=h;for(let t=0;t<o.length;t++){const i=a[t],{x:s,y:n,angle:r}=getPositionOnPath(e,l);Painter.ctx.save(),Painter.ctx.translate(s,n),Painter.ctx.rotate(r),Painter.ctx.fillText(o[t],0,0),Painter.ctx.restore(),l+=i}}static getPositionOnPath(t,e){let i=0;for(let s=1;s<t.length;s++){const n=t[s-1],o=t[s],a=o.x-n.x,r=o.y-n.y,h=Math.sqrt(a*a+r*r);if(i+h>=e){const t=(e-i)/h;return{x:n.x+a*t,y:n.y+r*t,angle:Math.atan2(r,a)}}i+=h}const s=t[t.length-1],n=t[t.length-2],o=Math.atan2(s.y-n.y,s.x-n.x);return{x:s.x,y:s.y,angle:o}}}const _Painter=class t{static init(e){t.ctx=e}static save(){this.ctx.save(),t.opacity._clone()}static restore(){this.ctx.restore(),t.opacity.popOpacity()}static clear(e=0,i=0,s=t.ctx.canvas.width,n=t.ctx.canvas.height){t.ctx.clearRect(e,i,s,n)}static translate(e,i){t.ctx.translate(e,i)}static rotate(e){t.ctx.rotate(e)}static scale(e,i){t.ctx.scale(e,i)}};__publicField(_Painter,"colors",PainterColors),__publicField(_Painter,"effects",PainterEffects),__publicField(_Painter,"img",PainterImages),__publicField(_Painter,"lines",PainterLines),__publicField(_Painter,"opacity",PainterOpacity),__publicField(_Painter,"shapes",PainterShapes),__publicField(_Painter,"text",PainterText);let Painter=_Painter;const _Logger=class t{static disableAll(){t.enabledClasses=new Set,t.globalLevel=0}static disable(){t.enabled=!1}static enable(){t.enabled=!0}static setLevel(e){t.globalLevel=e}static enableFor(e){t.enabledClasses.add(e)}static disableFor(e){t.enabledClasses.delete(e)}static setOutput(e){t.output=e}constructor(t){this.className=t}static getLogger(e){return new t(e)}_log(e,i,...s){t.enabled&&(t.globalLevel>=e||t.enabledClasses.has(this.className))&&t.output[i](`[${this.className}]`,...s)}log(...e){this._log(t.INFO,"log",...e)}warn(...e){this._log(t.WARN,"warn",...e)}error(...e){this._log(t.ERROR,"error",...e)}debug(...e){this._log(t.DEBUG,"log",...e)}table(...e){this._log(t.INFO,"table",...e)}groupCollapsed(e){t.enabled&&t.output.groupCollapsed(`[${this.className}] ${e}`)}groupEnd(){t.enabled&&t.output.groupEnd()}time(e){t.enabled&&t.output.time(`[${this.className}] ${e}`)}timeEnd(e){t.enabled&&t.output.timeEnd(`[${this.className}] ${e}`)}clear(){t.output.clear()}};__publicField(_Logger,"ERROR",1),__publicField(_Logger,"WARN",2),__publicField(_Logger,"INFO",3),__publicField(_Logger,"DEBUG",4),__publicField(_Logger,"globalLevel",_Logger.ERROR),__publicField(_Logger,"enabledClasses",new Set),__publicField(_Logger,"output",console),__publicField(_Logger,"enabled",!0);let Logger=_Logger;const _DebugTab=class t{static getInstance(){return t.instance||(t.instance=new t),t.instance}constructor(){this.createTab()}createTab(){this.tab=document.createElement("div"),Object.assign(this.tab.style,{position:"fixed",bottom:"0",left:"0",right:"0",height:"30px",backgroundColor:"#333",color:"#fff",padding:"5px",cursor:"pointer",fontFamily:"monospace",zIndex:"10000",display:"flex",justifyContent:"space-between",alignItems:"center"}),this.tab.innerText="Console";const t=document.createElement("div"),e=(t,e)=>{const i=document.createElement("button");return i.innerText=t,Object.assign(i.style,{marginLeft:"5px",padding:"2px 5px",fontFamily:"monospace",cursor:"pointer"}),i.onclick=e,i};this.paused=!1,this.scrollLock=!0,t.appendChild(e("Clear",(()=>this.consoleArea.value=""))),t.appendChild(e("Pause",(()=>this.paused=!this.paused))),t.appendChild(e("Scroll Lock",(()=>this.scrollLock=!this.scrollLock))),this.tab.appendChild(t),document.body.appendChild(this.tab),this.consoleArea=document.createElement("textarea"),Object.assign(this.consoleArea.style,{position:"fixed",bottom:"30px",left:"0",right:"0",height:"200px",display:"none",backgroundColor:"#111",color:"#0f0",fontFamily:"monospace",zIndex:"9999",padding:"10px",resize:"none"}),this.consoleArea.readOnly=!0,document.body.appendChild(this.consoleArea),this.tab.onclick=t=>{t.target===this.tab&&(this.consoleArea.style.display="none"===this.consoleArea.style.display?"block":"none")}}appendMessage(t,e,...i){if(this.paused)return;const s=`[${t.toUpperCase()}] ${e} ${i.join(" ")}\n`;this.consoleArea.value+=s,this.scrollLock&&(this.consoleArea.scrollTop=this.consoleArea.scrollHeight)}log(t,...e){this.appendMessage("log",t,...e)}warn(t,...e){this.appendMessage("warn",t,...e)}error(t,...e){this.appendMessage("error",t,...e)}table(t){const e=JSON.stringify(t,null,2);this.appendMessage("table",e)}groupCollapsed(t){this.appendMessage("group",`Group Start: ${t}`)}groupEnd(){this.appendMessage("group","Group End")}time(t){this[`time_${t}`]=performance.now()}timeEnd(t){const e=(performance.now()-this[`time_${t}`]).toFixed(2);this.appendMessage("time",`${t}: ${e} ms`)}};__publicField(_DebugTab,"instance");let DebugTab=_DebugTab;class Loggable{constructor(){this.logger=Logger.getLogger(this.constructor.name)}}class Renderable extends Loggable{constructor(t={}){super(),this.options=t,this.name=String(t.name??""),this._x=Number(t.x??0),this._y=Number(t.y??0),this._width=Math.max(0,Number(t.width??0)),this._height=Math.max(0,Number(t.height??0)),this._rotation=Number(t.rotation??0),this._scaleX=Number(t.scaleX??1),this._scaleY=Number(t.scaleY??1),this._opacity=void 0!==t.opacity?Number(t.opacity):1,this._visible=!1!==t.visible,this._active=!1!==t.active,this._debug=!1!==t.debug,this._tick=0,this._debugColor=String(t.debugColor??"#0f0"),this.shadowColor=void 0!==t.shadowColor?String(t.shadowColor):void 0,this.shadowBlur=Math.max(0,Number(t.shadowBlur??0)),this.shadowOffsetX=Number(t.shadowOffsetX??0),this.shadowOffsetY=Number(t.shadowOffsetY??0),this.minX=void 0!==t.minX?Number(t.minX):void 0,this.maxX=void 0!==t.maxX?Number(t.maxX):void 0,this.minY=void 0!==t.minY?Number(t.minY):void 0,this.maxY=void 0!==t.maxY?Number(t.maxY):void 0,this.crisp=Boolean(t.crisp??!0)}get x(){return this._x}set x(t){this._x=t}get y(){return this._y}set y(t){this._y=t}get width(){return this._width}set width(t){this._width=t}get height(){return this._height}set height(t){this._height=t}get rotation(){return this._rotation}set rotation(t){this._rotation=t}get scaleX(){return this._scaleX}set scaleX(t){this._scaleX=t}get scaleY(){return this._scaleY}set scaleY(t){this._scaleY=t}get opacity(){return this._opacity}set opacity(t){const e="number"!=typeof t||isNaN(t)?1:t;this._opacity=Math.min(1,Math.max(0,e))}get visible(){return this._visible}set visible(t){this._visible=t}get active(){return this._active}set active(t){this._active=t}get tick(){return this._tick}get debug(){return this._debug}set debug(t){this._debug=t}get debugColor(){return this._debugColor}set debugColor(t){this._debugColor=t}update(t){this._tick+=t}getBounds(){return{x:this._x,y:this._y,width:this._width,height:this._height}}drawDebugBox(){const{x:t,y:e,width:i,height:s}=this.getBounds(),n=i/2,o=s/2;this.logger.log("Renderer.drawDebugBox",this.constructor.name,this.name,"x",t,"y",e,"width",i,"height",s),Painter.save(),Painter.translate(t-n,e-o),Painter.rotate(this._rotation),Painter.scale(this._scaleX,this.scaleY),Painter.shapes.outlineRect(0,0,i,s,this._debugColor,1),Painter.restore()}applyShadow(t){this.shadowColor&&(t.shadowColor=this.shadowColor,t.shadowBlur=this.shadowBlur,t.shadowOffsetX=this.shadowOffsetX,t.shadowOffsetY=this.shadowOffsetY)}applyConstraints(){void 0!==this.minX&&(this.x=Math.max(this.x,this.minX)),void 0!==this.maxX&&(this.x=Math.min(this.x,this.maxX)),void 0!==this.minY&&(this.y=Math.max(this.y,this.minY)),void 0!==this.maxY&&(this.y=Math.min(this.y,this.maxY)),this.crisp&&(this.x=Math.round(this.x),this.y=Math.round(this.y),this.width=Math.round(this.width),this.height=Math.round(this.height))}render(t){!this.visible||this.opacity<=0||(this.traceRender(),Painter.save(),Painter.opacity.pushOpacity(this.opacity),this.debug&&this.drawDebugBox(),t(),Painter.opacity.popOpacity(),Painter.restore())}traceRender(){this.logger.log("render",this.constructor.name,"x",this.x,"y",this.y,"w",this.width,"h",this.height,"a",this.opacity)}renderDebug(t){this.debug&&this.drawDebugBox(t)}}class Transformable extends Renderable{constructor(t={}){super(t)}getTransformedBounds(){const t=this.width/2,e=this.height/2,i=[{x:-t,y:-e},{x:t,y:-e},{x:t,y:e},{x:-t,y:e}],s=Math.cos(this.rotation),n=Math.sin(this.rotation),o=i.map((({x:t,y:e})=>{t*=this.scaleX,e*=this.scaleY;const i=t*n+e*s;return{x:t*s-e*n+this.x,y:i+this.y}}));let a=1/0,r=1/0,h=-1/0,l=-1/0;for(const t of o)a=Math.min(a,t.x),r=Math.min(r,t.y),h=Math.max(h,t.x),l=Math.max(l,t.y);return{x:a+(h-a)/2,y:r+(l-r)/2,width:h-a,height:l-r}}getBounds(){return this.getTransformedBounds()}render(t){this.traceRender();super.render((()=>{Painter.ctx.translate(this.x,this.y),Painter.ctx.rotate(this.rotation),Painter.ctx.scale(this.scaleX,this.scaleY),t()}).bind(this))}static aggregateBounds(t){let e=1/0,i=1/0,s=-1/0,n=-1/0;for(const o of t){if(!o.getBounds)continue;const t=o.getBounds();if(!t)continue;const a=t.width/2,r=t.height/2,h=t.x-a,l=t.x+a,c=t.y-r,u=t.y+r;e=Math.min(e,h),s=Math.max(s,l),i=Math.min(i,c),n=Math.max(n,u)}return e===1/0?{x:0,y:0,width:0,height:0}:{x:e+(s-e)/2,y:i+(n-i)/2,width:s-e,height:n-i}}}class Shape extends Transformable{constructor(t,e,i={}){super(i),this.x=t,this.y=e,this.fillColor=i.fillColor||null,this.strokeColor=i.strokeColor||null,this.lineWidth=i.lineWidth||1}draw(){this.applyConstraints()}render(){this.traceRender(),super.render(this.draw.bind(this))}}const _Mouse=class t{static init(e){t.game=e,t.canvas=e.canvas,t.x=0,t.y=0,t.leftDown=!1,t.middleDown=!1,t.rightDown=!1,t.canvas.addEventListener("mousemove",t._onMove),t.canvas.addEventListener("mousedown",t._onDown),t.canvas.addEventListener("mouseup",t._onUp),t.canvas.addEventListener("click",t._onClick),t.canvas.addEventListener("wheel",t._onWheel)}static _updatePosition(e){const i=t.canvas.getBoundingClientRect();t.x=e.clientX-i.left,t.y=e.clientY-i.top}};__publicField(_Mouse,"_onMove",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("mousemove",t)})),__publicField(_Mouse,"_onDown",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!0),1===t.button&&(_Mouse.middleDown=!0),2===t.button&&(_Mouse.rightDown=!0),_Mouse.game.events.emit("mousedown",t)})),__publicField(_Mouse,"_onUp",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!1),1===t.button&&(_Mouse.middleDown=!1),2===t.button&&(_Mouse.rightDown=!1),_Mouse.game.events.emit("mouseup",t)})),__publicField(_Mouse,"_onClick",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("click",t)})),__publicField(_Mouse,"_onWheel",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("wheel",t)}));let Mouse=_Mouse;const _Keys=class t{static init(e){t.game=e,window.addEventListener("keydown",t._onKeyDown),window.addEventListener("keyup",t._onKeyUp)}static isDown(e){return t._down.has(e)}static _onKeyDown(e){const i=t._codeMap[e.code];i&&(t._down.has(i)||(t._down.add(i),t.game.events.emit(i,e))),t.game.events.emit(e.type,e)}static _onKeyUp(e){const i=t._codeMap[e.code];i&&t._down.has(i)&&(t._down.delete(i),t.game.events.emit(i+"_up",e)),t.game.events.emit(e.type,e)}};__publicField(_Keys,"W","W"),__publicField(_Keys,"A","A"),__publicField(_Keys,"S","S"),__publicField(_Keys,"D","D"),__publicField(_Keys,"UP","UP"),__publicField(_Keys,"DOWN","DOWN"),__publicField(_Keys,"LEFT","LEFT"),__publicField(_Keys,"RIGHT","RIGHT"),__publicField(_Keys,"SPACE","SPACE"),__publicField(_Keys,"SHIFT","SHIFT"),__publicField(_Keys,"ENTER","ENTER"),__publicField(_Keys,"ESC","ESC"),__publicField(_Keys,"_codeMap",{KeyW:_Keys.W,KeyA:_Keys.A,KeyS:_Keys.S,KeyD:_Keys.D,ArrowUp:_Keys.UP,ArrowDown:_Keys.DOWN,ArrowLeft:_Keys.LEFT,ArrowRight:_Keys.RIGHT,Space:_Keys.SPACE,ShiftLeft:_Keys.SHIFT,ShiftRight:_Keys.SHIFT,Enter:_Keys.ENTER,NumpadEnter:_Keys.ENTER,Escape:_Keys.ESC}),__publicField(_Keys,"_down",new Set),__publicField(_Keys,"game",null);let Keys=_Keys;const _Touch=class t{static init(e){t.game=e,t.canvas=e.canvas,t.x=0,t.y=0,t.active=!1,t.canvas.addEventListener("touchstart",t._onStart),t.canvas.addEventListener("touchend",t._onEnd),t.canvas.addEventListener("touchmove",t._onMove)}static _updatePosition(e){const i=t.canvas.getBoundingClientRect();t.x=e.clientX-i.left,t.y=e.clientY-i.top}};__publicField(_Touch,"_onStart",(t=>{t.touches.length>0&&(_Touch.active=!0,_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchstart",t))})),__publicField(_Touch,"_onEnd",(t=>{_Touch.active=!1,_Touch.game.events.emit("touchend",t)})),__publicField(_Touch,"_onMove",(t=>{t.touches.length>0&&(_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchmove",t))}));let Touch=_Touch;const _Input=class t{static init(e){t.game=e,t.x=0,t.y=0,t.down=!1,e.events.on("mousedown",t._onDown),e.events.on("mouseup",t._onUp),e.events.on("mousemove",t._onMove),e.events.on("touchstart",t._onTouchStart),e.events.on("touchend",t._onTouchEnd),e.events.on("touchmove",t._onTouchMove)}static _setPosition(e,i){t.x=e,t.y=i}};__publicField(_Input,"_onDown",(t=>{_Input.down=!0,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onUp",(t=>{_Input.down=!1,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onMove",(t=>{_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputmove",t)})),__publicField(_Input,"_onTouchStart",(t=>{const e=t.touches[0],i=_Input.game.canvas.getBoundingClientRect();_Input.down=!0,_Input._setPosition(e.clientX-i.left,e.clientY-i.top),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onTouchEnd",(t=>{_Input.down=!1,_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onTouchMove",(t=>{const e=t.touches[0],i=_Input.game.canvas.getBoundingClientRect();_Input._setPosition(e.clientX-i.left,e.clientY-i.top),_Input.game.events.emit("inputmove",t)}));let Input=_Input;class EventEmitter{constructor(){this.listeners={}}on(t,e){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e)}off(t,e){this.listeners[t]&&(this.listeners[t]=this.listeners[t].filter((t=>t!==e)))}emit(t,e){this.listeners[t]&&this.listeners[t].forEach((t=>t(e)))}}function applyAnchor(t,e={}){var i;t.anchor=e.anchor??null,t.padding=e.padding??10;const s=t.game,n=null==(i=t.update)?void 0:i.bind(t);t.update=function(e){if(t.anchor){const{x:e,y:i,align:n,baseline:o}=((e,i)=>{const n=s.width,o=s.height;switch(e){case"top-left":return{x:i,y:i,align:"left",baseline:"top"};case"top-center":return{x:(n-t.width)/2,y:i,align:"center",baseline:"top"};case"top-right":return{x:n-t.width-i,y:i,align:"right",baseline:"top"};case"center-left":return{x:i,y:(o-t.height)/2,align:"left",baseline:"middle"};case"center":return{x:(n-t.width)/2,y:(o-t.height)/2,align:"center",baseline:"middle"};case"center-right":return{x:n-t.width-i,y:o/2,align:"right",baseline:"middle"};case"bottom-left":return{x:i,y:o-i,align:"left",baseline:"bottom"};case"bottom-center":return{x:(n-t.width)/2,y:o-t.height-i,align:"center",baseline:"bottom"};case"bottom-right":return{x:n-i,y:o-i,align:"right",baseline:"bottom"};default:return{x:10,y:10,align:"left",baseline:"top"}}})(t.anchor,t.padding);t.x=e,t.y=i,"align"in t&&(t.align=n),"baseline"in t&&(t.baseline=o)}null==n||n(e)}}class GameObject extends Transformable{constructor(t,e={}){super(e),this.game=t,this.events=new EventEmitter,this.interactive=!1,this._hovered=!1,this.parent=null,applyAnchor(this,e)}enableInteractivity(t){this.interactive=!0,this.shape=t,this._hovered=!1}_hitTest(t,e){var i,s,n;const o=(null==(s=null==(i=this.shape)?void 0:i.getBounds)?void 0:s.call(i))??(null==(n=this.getBounds)?void 0:n.call(this));if(!o)return!1;const{x:a,y:r,width:h,height:l}=o,c=h/2,u=l/2;return t>=a-c&&t<=a+c&&e>=r-u&&e<=r+u}on(t,e){this.events.on(t,e)}off(t,e){this.events.off(t,e)}}class ShapeGOFactory{static create(t,e,i={}){return new GameObjectShapeWrapper(t,e,i)}}class GameObjectShapeWrapper extends GameObject{constructor(t,e,i={}){super(t,{...{x:(null==e?void 0:e.x)??0,y:(null==e?void 0:e.y)??0,width:(null==e?void 0:e.width)??0,height:(null==e?void 0:e.height)??0,scaleX:(null==e?void 0:e.scaleX)??1,scaleY:(null==e?void 0:e.scaleY)??1,name:e.constructor.name},...i}),this.shape=e}update(t){super.update(t),this.shape&&this.active&&(this.shape.x=this.x,this.shape.y=this.y,this.shape.width=this.width,this.shape.height=this.height,this.shape.opacity=this.opacity,this.shape.visible=this.visible,this.shape.scaleX=this.scaleX,this.shape.scaleY=this.scaleY,this.shape.offsetX=this.offsetX,this.shape.offsetY=this.offsetY)}render(){this.traceRender(),super.render(this.shape.render.bind(this.shape))}}class Scene extends GameObject{constructor(t,e={}){super(t,e),this.children=[],this.x=e.x??0,this.y=e.y??0,this.naturalWidth=0,this.naturalHeight=0,this.forceWidth=null,this.forceHeight=null}add(t){if(null!=t.parent)throw new Error("This GameObject already has a parent!");return t.parent=this,this.children.push(t),t}remove(t){this.children=this.children.filter((e=>e!==t)),t.parent=null}clear(){this.children.forEach((t=>t.parent=null)),this.children=[]}bringToFront(t){this.remove(t),this.add(t)}sendToBack(t){this.remove(t),this.children.unshift(t),t.parent=this}update(t){super.update(t);for(let e of this.children)e.update&&e.active&&e.update(t)}get width(){if(null!==this.forceWidth)return this.forceWidth;if(null===this.naturalWidth){const t=this.calculateNaturalBounds();this.naturalWidth=t.width,this.naturalHeight=t.height}return this.naturalWidth}set width(t){this.forceWidth=t}get height(){if(null!==this.forceHeight)return this.forceHeight;if(null===this.naturalHeight){const t=this.calculateNaturalBounds();this.naturalWidth=t.width,this.naturalHeight=t.height}return this.naturalHeight}set height(t){this.forceHeight=t}calculateNaturalBounds(){let t=1/0,e=1/0,i=-1/0,s=-1/0;for(const n of this.children){if(!n.getBounds)continue;const o=n.getBounds();if(!o)continue;const a=o.width/2,r=o.height/2;t=Math.min(t,o.x-this.x-a),e=Math.min(e,o.y-this.y-r),i=Math.max(i,o.x-this.x+a),s=Math.max(s,o.y-this.y+r)}return t===1/0?{width:0,height:0}:{width:i-t,height:s-e}}render(){this.logger.log("Scene.render"),super.render(this.renderWithScaling.bind(this))}renderWithScaling(){this.logger.log("Scene.render.renderWithScaling");const t=this.width,e=this.height;null!==this.forceWidth&&t>0&&this.forceWidth,null!==this.forceHeight&&e>0&&this.forceHeight;const i=this.scaleX,s=this.scaleY;for(let t of this.children)t.render&&t.visible&&t.render();this.scaleX=i,this.scaleY=s}getBounds(){if(0===this.children.length)return super.getBounds();let t=1/0,e=1/0,i=-1/0,s=-1/0;for(const n of this.children){if(!n.getBounds)continue;const o=n.getBounds();if(!o)continue;const a=o.width/2,r=o.height/2,h=[{x:o.x-a,y:o.y-r},{x:o.x+a,y:o.y-r},{x:o.x+a,y:o.y+r},{x:o.x-a,y:o.y+r}];for(const n of h)t=Math.min(t,n.x),e=Math.min(e,n.y),i=Math.max(i,n.x),s=Math.max(s,n.y)}if(t===1/0)return super.getBounds();const n=i-t,o=s-e;return this.blalbla&&this.logger.log("Scene bounds:",{x:this.x,y:this.y,width:n,height:o,children:this.children.length,minX:t,maxX:i,minY:e,maxY:s}),{x:t+n/2,y:e+o/2,width:n,height:o}}}class Text extends GameObject{constructor(t,e,i={}){super(t,i),this.text=e,this.x=i.x||0,this.y=i.y||0,this.font=i.font||"16px monospace",this.color=i.color||"#fff",this.align=i.align||"left",this.baseline=i.baseline||"top",this.stroke=i.stroke||!1,this.strokeColor=i.strokeColor||"#000",this.lineWidth=i.lineWidth||1}render(){Painter.text.setFont(this.font),Painter.text.setTextAlign(this.align),Painter.text.setTextBaseline(this.baseline),this.stroke&&Painter.text.strokeText(this.text,this.x,this.y,this.strokeColor,this.lineWidth,this.font),Painter.text.fillText(this.text,this.x,this.y,this.color,this.font)}}class Tween{static lerp(t,e,i){return t+(e-t)*i}static lerpAngle(t,e,i){let s=e-t;for(;s<-Math.PI;)s+=2*Math.PI;for(;s>Math.PI;)s-=2*Math.PI;return t+s*i}static tweenColor(t,e,i){return t.map(((t,s)=>Tween.lerp(t,e[s],i)))}static tweenGradient(t,e,i){let s=t[0],n=e[0];Math.abs(n-s)>180&&(s<n?s+=360:n+=360);return[Tween.lerp(s,n,i)%360,Tween.lerp(t[1],e[1],i),Tween.lerp(t[2],e[2],i)]}}class Easing{static easeInQuad(t){return t*t}static easeOutQuad(t){return t*(2-t)}static easeInOutQuad(t){return t<.5?2*t*t:(4-2*t)*t-1}static easeInCubic(t){return t*t*t}static easeOutCubic(t){return--t*t*t+1}static easeInOutCubic(t){return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1}static easeInQuart(t){return t*t*t*t}static easeOutQuart(t){return 1- --t*t*t*t}static easeInOutQuart(t){return t<.5?8*t*t*t*t:1-8*--t*t*t*t}static easeInSine(t){return 1-Math.cos(t*Math.PI/2)}static easeOutSine(t){return Math.sin(t*Math.PI/2)}static easeInOutSine(t){return-(Math.cos(Math.PI*t)-1)/2}static easeInExpo(t){return 0===t?0:Math.pow(2,10*(t-1))}static easeOutExpo(t){return 1===t?1:1-Math.pow(2,-10*t)}static easeInOutExpo(t){return 0===t||1===t?t:t<.5?.5*Math.pow(2,20*t-10):.5*(2-Math.pow(2,-20*t+10))}static easeInCirc(t){return 1-Math.sqrt(1-t*t)}static easeOutCirc(t){return Math.sqrt(1- --t*t)}static easeInOutCirc(t){return t<.5?.5*(1-Math.sqrt(1-4*t*t)):.5*(Math.sqrt(-(2*t-3)*(2*t-1))+1)}static easeInElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return-e*Math.pow(2,10*(t-1))*Math.sin((t-1-s)*(2*Math.PI)/i)}static easeOutElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return e*Math.pow(2,-10*t)*Math.sin((t-s)*(2*Math.PI)/i)+1}static easeInOutElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return t<.5?e*Math.pow(2,10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/i)*-.5:e*Math.pow(2,-10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/i)*.5+1}static easeInBack(t,e=1.70158){return t*t*((e+1)*t-e)}static easeOutBack(t,e=1.70158){return--t*t*((e+1)*t+e)+1}static easeInOutBack(t,e=1.70158){const i=1.525*e;return t<.5?2*t*.5*(2*t)*(2*(i+1)*t-i):.5*((2*t-2)*(2*t-2)*((i+1)*(2*t-2)+i)+2)}static easeOutBounce(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}static easeInBounce(t){return 1-Easing.easeOutBounce(1-t)}static easeInOutBounce(t){return t<.5?.5*Easing.easeInBounce(2*t):.5*Easing.easeOutBounce(2*t-1)+.5}}function bezierV1(t,e,i,s,n,o,a=!1,r=!1,h=null,l={},c=null){if(o<=0)return Motion.animationResult({x:s[0],y:s[1],phase:"complete"},1,!1,!0);let u=n/o,d="forward",p=0;a?(p=Math.floor(u),u%=1,p>0&&l.onLoop&&l.onLoop(p)):u>1&&(u=1),u>0&&n<=o&&l.onStart&&l.onStart();let g=h?h(u):u;r&&(u>=.5?(g=1-2*(u-.5),d="return",u>=.5&&u<.51&&l.onYoyoTurn&&l.onYoyoTurn()):(g=2*u,d="forward"),g=h?h(g):g);const f=3*(e[0]-t[0]),x=3*(i[0]-e[0])-f,m=s[0]-t[0]-f-x,P=3*(e[1]-t[1]),y=3*(i[1]-e[1])-P,b=s[1]-t[1]-P-y,_=m*Math.pow(g,3)+x*Math.pow(g,2)+f*g+t[0],M=b*Math.pow(g,3)+y*Math.pow(g,2)+P*g+t[1],w=!a&&u>=1;return w&&l.onComplete&&l.onComplete(),Motion.animationResult({x:_,y:M,phase:d},u,a,w,c)}function bounceV1(t,e,i,s,n,o=!1,a=null,r={},h=null){const{t:l,easedT:c,completed:u,state:d}=Motion._frame(s,n,o,a,r,h),p=1/(i+1),g=Math.min(Math.floor(c/p),i),f=c%p/p,x=t*Math.pow(.6,g),m=e-Math.sin(f*Math.PI)*(e-x);return Motion.animationResult({y:m,segment:g,bounceHeight:x},l,o,u,d)}function floatV1(t,e,i,s,n,o,a=!0,r=null,h={},l=null){if(i<=0)return Motion.animationResult({x:t.x,y:t.y,moving:!1},1,!1,!0);l||(l={initialX:0,initialY:0,started:!1,completed:!1,loopCount:0});const c=l.initialX,u=l.initialY,{t:d,easedT:p,completed:g,state:f}=Motion._frame(e,i,a,r,h,l);l={...l,...f};const x=e*s,m=Math.max(0,Math.min(1,n)),P=c+(Math.sin(.7*x)+.4*m*Math.sin(2.3*x+.5))*o,y=u+(Math.cos(.9*x)+.4*m*Math.cos(1.9*x+.7))*o,b=.7*Math.cos(.7*x)+.4*m*2.3*Math.cos(2.3*x+.5),_=-.9*Math.sin(.9*x)+.4*m*-1.9*Math.sin(1.9*x+.7),M=Math.sqrt(b*b+_*_),w=M>.8,C=Math.sqrt((P-c)*(P-c)+(y-u)*(y-u));return Motion.animationResult({x:P,y:y,centerX:c,centerY:u,offsetX:P-c,offsetY:y-u,distance:C,moving:w,velocity:M},d,a,g,l)}function followPath(t,e=!1,i,s,n=!1,o=null,a={},r=null){if(!t||t.length<2)return this._createResult({x:0,y:0},0,n,!1);const{t:h,easedT:l,completed:c,state:u}=Motion._frame(i,s,n,o,a,r);if(!r||!r.pathData){const i={segmentLengths:[],totalLength:0,points:[...t]};for(let e=0;e<t.length-1;e++){const s=t[e],n=t[e+1],o=n[0]-s[0],a=n[1]-s[1],r=Math.sqrt(o*o+a*a);i.segmentLengths.push(r),i.totalLength+=r}if(e){const e=t[t.length-1],s=t[0],n=s[0]-e[0],o=s[1]-e[1],a=Math.sqrt(n*n+o*o);i.segmentLengths.push(a),i.totalLength+=a}u.pathData=i}const{segmentLengths:d,totalLength:p,points:g}=u.pathData,f=l*p;let x=0,m=0;for(let t=0;t<d.length;t++){if(x+d[t]>=f){m=t;break}x+=d[t]}const P=(f-x)/d[m],y=g[m],b=m<g.length-1?g[m+1]:g[0],_=Tween.lerp(y[0],b[0],P),M=Tween.lerp(y[1],b[1],P),w=Math.atan2(b[1]-y[1],b[0]-y[0]);return Motion.animationResult({x:_,y:M,angle:w,segmentIndex:m,segmentProgress:P,pathProgress:l},h,n,c,u)}function orbitV1(t,e,i,s,n,o,a,r=!0,h=!0,l=null,c={},u=null){const{t:d,easedT:p,completed:g,state:f}=Motion._frame(o,a,r,l,c,u),x=n+(h?1:-1)*p*Math.PI*2,m=t+i*Math.cos(x),P=e+s*Math.sin(x);return Motion.animationResult({x:m,y:P,angle:x},d,r,g,f)}function oscillateV1(t,e,i,s,n=!0,o=null,a={},r=null){const{t:h,easedT:l,completed:c,state:u}=Motion._frame(i,s,n,o,a,r),d=(e-t)/2,p=t+d+d*Math.sin(l*Math.PI*2);return Motion.animationResult({value:p},h,n,c,u)}function parabolicV1(t,e,i,s,n,o=!1,a=!1,r=null,h={},l=null){l||(l={started:!1,loopCount:0,direction:1,lastDirection:1,completed:!1});let c=n>0?s/n:1,u=!1,d={...h};if(a||o)if(o)if(a){const t=2*n,e=s%t,i=Math.floor(s/t),o=e<n?1:-1;c=1===o?e/n:2-e/n,o!==l.direction&&(l.direction=o,1===l.direction&&d.onLoop&&d.onLoop(i)),i>l.loopCount&&(l.loopCount=i)}else{c%=1;const t=Math.floor(s/n);t>l.loopCount&&d.onLoop&&(d.onLoop(t),l.loopCount=t)}else a&&!o&&(c<=1?l.direction=1:c<=2?(c=2-c,l.direction=-1):(c=0,u=!0,l.direction=1));else c>=1&&(c=1,u=!0);!l.started&&d.onStart&&(d.onStart(),l.started=!0),u&&!l.completed&&d.onComplete&&(d.onComplete(),l.completed=!0);const p=r?r(c):c,g=(t+i-2*e)*p*p+2*(e-t)*p+t,f={...l,lastDirection:l.direction,completed:u||l.completed};return Motion.animationResult({value:g,direction:l.direction},c,o||a&&!u,u,f)}function patrolV1(t,e,i,s,n,o,a=!0,r=null){r||(r={currentX:t,currentY:e,targetX:t,targetY:e,isWaiting:!0,waitStartTime:0,moveStartTime:0,moveCount:0,direction:"idle"});const h=()=>Math.random();let l=r.isWaiting,c=r.currentX,u=r.currentY,d=r.direction;if(l){if(i-r.waitStartTime>=n){l=!1,r.moveStartTime=i;d=["up","down","left","right"][Math.floor(4*h())];let s=r.currentX,n=r.currentY;const a=o*(.2+.6*h());switch(d){case"up":n=r.currentY-a;break;case"down":n=r.currentY+a;break;case"left":s=r.currentX-a;break;case"right":s=r.currentX+a}Math.pow(s-t,2)+Math.pow(n-e,2)>o*o&&("up"===d||"down"===d?(n=e,d=r.currentY>e?"up":"down"):(s=t,d=r.currentX>t?"left":"right")),r.targetX=s,r.targetY=n,r.direction=d,r.moveCount++}}else{const t=(i-r.moveStartTime)/s;t>=1?(l=!0,r.waitStartTime=i,r.currentX=r.targetX,r.currentY=r.targetY,d="idle"):(c=r.currentX+(r.targetX-r.currentX)*t,u=r.currentY+(r.targetY-r.currentY)*t)}r.isWaiting=l,r.direction=d,l||(r.currentX=c,r.currentY=u);const p=s+n,g=i%p/p,f=Math.sqrt(Math.pow(c-t,2)+Math.pow(u-e,2));return Motion.animationResult({x:c,y:u,moving:!l,direction:d,distanceFromCenter:f},g,a,!1,r)}function pendulumV1(t,e,i,s,n=!0,o=!1,a=null,r={},h=null){const{t:l,easedT:c,completed:u,state:d}=Motion._frame(i,s,n,null,r,h),p=o&&!n?Math.exp(-4*l):1;let g=t+e*Math.cos(2*c*Math.PI)*p;if(a){g=t+a(((g-t)/(e*p)+1)/2)*e*p*2-e*p}return Motion.animationResult({angle:g},l,n,u,d)}function pulseV1(t,e,i,s,n=!0,o=!1,a=null,r={}){let h,l=i/s,c="forward";if(n){const t=Math.floor(l);l%=1,t>0&&r.onLoop&&r.onLoop(t)}else l>1&&(l=1);if(l>0&&i<=s&&r.onStart&&r.onStart(),o)if(l<.5){const i=2*l;h=t+(e-t)*(a?a(i):i),c="forward"}else{const i=2*(l-.5);h=e-(e-t)*(a?a(i):i),c="return",l>=.5&&l<.51&&r.onYoyoTurn&&r.onYoyoTurn()}else{const i=a?a(l):l;h=t+(e-t)*(i<.5?2*i:2-2*i)}const u=!n&&l>=1;return u&&r.onComplete&&r.onComplete(),Motion.animationResult({value:h,phase:c},l,n,u)}function hopV1(t,e,i,s,n=!0,o=!0,a=null,r={},h=null){const{t:l,easedT:c,completed:u,state:d}=Motion._frame(i,s,n,a,r,h,o);let p=0;p=n||o?o?Math.sin(c*Math.PI):Math.sin(Math.min(l,1)*Math.PI*.5):u?1:Math.sin(Math.min(l,1)*Math.PI*.5);const g=t-e*p;return Motion.animationResult({y:g},l,n,u,d)}function shakeV1(t,e,i,s,n,o,a,r,h=!1,l=null,c={},u=null){const{t:d,easedT:p,completed:g,state:f}=Motion._frame(a,r,h,l,c,u),x=Math.pow(1-p,o),m=p*Math.PI*2*n,P=p*Math.PI*2*n*1.3,y=x*i*(.6*Math.sin(m)+.3*Math.sin(2.5*m)+.1*Math.sin(5.6*m)),b=x*s*(.6*Math.cos(P)+.3*Math.cos(2.7*P)+.1*Math.cos(6.3*P));let _=t+y,M=e+b;if(p>.9){const i=(p-.9)/.1;_=t+y*(1-i),M=e+b*(1-i)}return Motion.animationResult({x:_,y:M,intensity:x},d,h,g,f)}function spiralV1(t,e,i,s,n,o,a,r,h=!1,l=!1,c=null,u={},d=null){d||(d={started:!1,loopCount:0,direction:1,lastDirection:1});let p=r>0?a/r:1,g=!1,f={...u};if(l||h)if(h)if(l){const t=2*r,e=a%t,i=Math.floor(a/t),s=e<r?1:-1;p=1===s?e/r:2-e/r,s!==d.direction&&(d.direction=s,1===d.direction&&f.onLoop&&f.onLoop(i)),i>d.loopCount&&(d.loopCount=i)}else{p%=1;const t=Math.floor(a/r);t>d.loopCount&&f.onLoop&&(f.onLoop(t),d.loopCount=t)}else l&&!h&&(p<=1?d.direction=1:p<=2?(p=2-p,d.direction=-1):(p=0,g=!0,d.direction=1));else p>=1&&(p=1,g=!0);!d.started&&f.onStart&&(f.onStart(),d.started=!0),g&&!d.completed&&f.onComplete&&(f.onComplete(),d.completed=!0);const x=c?c(p):p,m=Tween.lerp(i,s,x),P=n+x*o*Math.PI*2,y=t+m*Math.cos(P),b=e+m*Math.sin(P),_={...d,lastDirection:d.direction};return Motion.animationResult({x:y,y:b,radius:m,angle:P,direction:d.direction},p,h||l&&!g,g,_)}function springV1(t,e,i,s,n=!1,o=!1,a={},r={}){if(s<=0)return this.animationResult({value:e,velocity:0,done:!0,phase:"complete"},1,!1,!0);let h,l,c,u=i/s,d="forward",p=0;n?(p=Math.floor(u),u%=1,p>0&&r.onLoop&&r.onLoop(p)):u>1&&(u=1),u>0&&i<=s&&r.onStart&&r.onStart(),o?u>=.5?(h=t,l=e,c=2*(u-.5),d="return",u>=.5&&u<.51&&r.onYoyoTurn&&r.onYoyoTurn()):(h=e,l=t,c=2*u,d="forward"):(h=e,l=t,c=u);const g=void 0!==a.stiffness?a.stiffness:.3,f=void 0!==a.damping?a.damping:.6,x=Math.max(.1,1/(1.5*f)),m=Math.max(.1,.8/(1.5*g+.5));let P;if(c<.99)P=Easing.easeOutElastic(c,x,m);else{const t=(c-.99)/.01;P=Easing.easeOutElastic(.99,x,m)*(1-t)+1*t}const y=Tween.lerp(l,h,P),b=Math.min(c+.01,1);let _;if(b<.99)_=Easing.easeOutElastic(b,x,m);else{const t=(b-.99)/.01;_=Easing.easeOutElastic(.99,x,m)*(1-t)+1*t}const M=(Tween.lerp(l,h,_)-y)/.01*s,w=!n&&u>=1;return w&&r.onComplete&&r.onComplete(),Motion.animationResult({value:y,velocity:M,delta:"forward"===d?e-y:t-y,done:w,phase:d},u,n,w)}function swingV1(t,e,i,s,n,o=!0,a=!0,r=null,h={},l=null){const{t:c,easedT:u,completed:d,state:p}=Motion._frame(s,n,o,r,h,l),g=(a?Math.sin(u*Math.PI*2):Math.sin(u*Math.PI))*i;return Motion.animationResult({angle:g},c,o,d,p)}function waypointV1(t,e,i,s,n,o=!0,a={},r=null){if(!i||!Array.isArray(i)||i.length<2)return console.warn("Patrol animation requires at least 2 waypoints"),Motion._createResult({x:0,y:0,moving:!1,direction:"idle",waypoint:0},0,!1,!0);r||(r={currentWaypoint:0,nextWaypoint:1,isWaiting:!0,waitStartTime:0,lastWaypointTime:0,lastWaypointReached:-1,completed:!1});let h=0;for(let t=0;t<i.length;t++){const e=(t+1)%i.length;if(!o&&t===i.length-1)break;const s=i[e][0]-i[t][0],n=i[e][1]-i[t][1];h+=Math.abs(s)+Math.abs(n)}const l=h/s+n*i.length;let c=e;c=o?e%l:Math.min(e,l);const u=c/l;let d,p,g,f=c,x=0,m=1,P=!0,y=0,b=0,_=!1;if(f<n)y=f/n,x=0,m=1,P=!0;else{f-=n;for(let t=0;t<i.length;t++){if(!o&&t===i.length-1){x=t,m=t,P=!0,y=1,_=!0;break}const e=(t+1)%i.length,h=i[e][0]-i[t][0],l=i[e][1]-i[t][1],c=(Math.abs(h)+Math.abs(l))/s;if(f<c){x=t,m=e,P=!1,b=f/c;break}if(f-=c,f<n){x=e,m=(e+1)%i.length,P=!0,y=f/n,r.lastWaypointReached!==x&&(a.onWaypointReached&&a.onWaypointReached(x),a.onWaitStart&&a.onWaitStart(x),r.lastWaypointReached=x);break}f-=n}}if(P||_)d=i[x][0],p=i[x][1],g="idle",!r.isWaiting&&P&&a.onWaitEnd&&a.onWaitEnd(x);else{const t=i[x],e=i[m],s=e[0]-t[0],n=e[1]-t[1],o=Math.abs(s)+Math.abs(n),a=Math.abs(s)/o;if(b<=a&&0!==s){const e=b/a;d=t[0]+s*e,p=t[1],g=s>0?"right":"left"}else{const i=(b-a)/(1-a);d=e[0],p=t[1]+n*i,g=n>0?"down":"up"}}return r.currentWaypoint=x,r.nextWaypoint=m,r.isWaiting=P,!r.completed&&_&&a.onPatrolComplete&&(a.onPatrolComplete(),r.completed=!0),Motion.animationResult({x:d,y:p,moving:!P,waiting:P,waitProgress:P?y:0,direction:g,waypoint:x,nextWaypoint:m},u,o,_,r)}class Motion{static animationResult(t,e,i,s=!1,n=null){return{...t,t:e,progress:e,loop:i,completed:s,state:n}}static _step(t,e,i,s={},n={started:!1,loopCount:0}){let o=e>0?t/e:1,a=!1;if(!(n=n||{started:!1,loopCount:0}).started&&s.onStart&&(s.onStart(),n.started=!0),i){o%=1;const i=Math.floor(t/e);i>n.loopCount&&s.onLoop&&(s.onLoop(i),n.loopCount=i)}else o>=1&&(o=1,a=!0,!n.completed&&s.onComplete&&(s.onComplete(),n.completed=!0));return{t:o,completed:a,state:n}}static _frame(t,e,i,s=null,n={},o=null){const{t:a,completed:r,state:h}=this._step(t,e,i,n,o);return{t:a,easedT:s?s(a):a,completed:r,state:h}}static oscillate(t,e,i,s,n=!0,o=null,a={},r=null){return oscillateV1(t,e,i,s,n,o,a,r)}static parabolic(t,e,i,s,n,o=!1,a=!1,r=null,h={},l=null){return parabolicV1(t,e,i,s,n,o,a,r,h,l)}static float(t,e,i,s,n,o,a=!0,r=null,h={},l=null){return floatV1(t,e,i,s,n,o,a,r,h,l)}static spring(t,e,i,s,n=!1,o=!1,a={},r={}){return springV1(t,e,i,s,n,o,a,r)}static swing(t,e,i,s,n,o=!0,a=!0,r=null,h={},l=null){return swingV1(t,e,i,s,n,o,a,r,h,l)}static pendulum(t,e,i,s,n=!0,o=!1,a=null,r={},h=null){return pendulumV1(t,e,i,s,n,o,a,r,h)}static pulse(t,e,i,s,n=!0,o=!1,a=null,r={}){return pulseV1(t,e,i,s,n,o,a,{})}static spiral(t,e,i,s,n,o,a,r,h=!1,l=!1,c=null,u={},d=null){return spiralV1(t,e,i,s,n,o,a,r,h,l,c,u,d)}static orbit(t,e,i,s,n,o,a,r=!0,h=!0,l=null,c={},u=null){return orbitV1(t,e,i,s,n,o,a,r,h,l,c,u)}static bezier(t,e,i,s,n,o,a=!1,r=!1,h=null,l={},c=null){return bezierV1(t,e,i,s,n,o,a,r,h,l,c)}static bounce(t,e,i,s,n,o=!1,a=null,r={},h=null){return bounceV1(t,e,i,s,n,o,a,r,h)}static shake(t,e,i,s,n,o,a,r,h=!1,l=null,c={},u=null){return shakeV1(t,e,i,s,n,o,a,r,h,l,c,u)}static follow(t,e=!1,i,s,n=!1,o=null,a={},r=null){return followPath(t,e,i,s,n,o,a,r)}static waypoint(t,e,i,s,n,o=!0,a={},r=null){return waypointV1(t,e,i,s,n,o,a,r)}static patrol(t,e,i,s,n,o,a=!0,r=null){return patrolV1(t,e,i,s,n,o,a,r)}static hop(t,e,i,s,n=!0,o=!0,a=null,r={},h=null){return hopV1(t,e,i,s,n,o,a,r,h)}static group(t,e,i,s,n=!1,o=null,a={},r=null){r||(r={started:!1,loopCount:0,animationStates:Array(t.length).fill(null)});const{t:h,easedT:l,completed:c,state:u}=this._frame(i,s,n,o,a,r),d={};for(let r=0;r<t.length;r++){const h=t[r],l=[...e[r]];h===this.parabolic||h===this.oscillate||h===this.pulse?(l[3]=i,l[4]=s,l[5]=n,void 0===l[6]&&(l[6]=o)):h===this.spring?(l[2]=i,l[3]=s,l[4]=n):h===this.spiral||h===this.bezier?(l[6]=i,l[7]=s,l[8]=n,void 0===l[9]&&(l[9]=o)):h===this.orbit?(l[5]=i,l[6]=s,l[7]=n,void 0===l[9]&&(l[9]=o)):h===this.bounce||h===this.shake?(l[6]=i,l[7]=s,l[8]=n,void 0===l[9]&&(l[9]=o)):h===this.followPath&&(l[2]=i,l[3]=s,l[4]=n,void 0===l[5]&&(l[5]=o)),l.push(a),l.push(u.animationStates[r]);const c=h.apply(this,l);u.animationStates[r]=c.state;d[`anim${r}`]=c}return this.animationResult(d,h,n,c,u)}static sequence(t,e,i,s,n=!1,o=null,a={},r=null,h=null){if(!h){h={started:!1,loopCount:0,animationStates:Array(t.length).fill(null),currentAnim:0,animStartTimes:[0],totalDuration:0};let e=0;for(let t=0;t<i.length;t++)e+=i[t],t<i.length-1&&h.animStartTimes.push(e);h.totalDuration=e}let l=s;if(n&&h.totalDuration>0){l=s%h.totalDuration;const t=Math.floor(s/h.totalDuration);t>h.loopCount&&a.onLoop&&(a.onLoop(t),h.loopCount=t)}!h.started&&a.onStart&&(a.onStart(),h.started=!0);let c=0;for(let e=t.length-1;e>=0;e--)if(l>=h.animStartTimes[e]){c=e;break}h.currentAnim=c;const u=l-h.animStartTimes[c],d=i[c],p=t[c],g=[...e[c]];p===this.parabolic||p===this.oscillate||p===this.pulse?(g[3]=u,g[4]=d,g[5]=!1,o&&o[c]&&(g[6]=o[c])):p===this.spring?(g[2]=u,g[3]=d,g[4]=!1):p===this.spiral||p===this.bezier?(g[6]=u,g[7]=d,g[8]=!1,o&&o[c]&&(g[9]=o[c])):p===this.orbit?(g[5]=u,g[6]=d,g[7]=!1,o&&o[c]&&(g[9]=o[c])):p===this.bounce||p===this.shake?(g[6]=u,g[7]=d,g[8]=!1,o&&o[c]&&(g[9]=o[c])):p===this.followPath&&(g[2]=u,g[3]=d,g[4]=!1,o&&o[c]&&(g[5]=o[c]));const f=r&&r[c]?r[c]:{},x=p.apply(this,[...g,f,h.animationStates[c]]);h.animationStates[c]=x.state;const m=!n&&l>=h.totalDuration;return m&&!h.completed&&a.onComplete&&(a.onComplete(),h.completed=!0),this.animationResult({...x,currentAnim:c,totalAnimations:t.length,sequenceProgress:Math.min(l/h.totalDuration,1)},l/h.totalDuration,n,m,h)}}class Tweenetik{constructor(t,e,i,s,n={}){this.target=t,this.toProps={...e},this.duration=i,this.easingFn=s||Easing.easeOutQuad,this.delay=n.delay||0,this.onStart=n.onStart||null,this.onComplete=n.onComplete||null,this.onUpdate=n.onUpdate||null,this._elapsed=0,this._started=!1,this._finished=!1,this._startProps={};for(const t in this.toProps)Object.prototype.hasOwnProperty.call(this.target,t)&&(this._startProps[t]=this.target[t])}static to(t,e,i,s,n){const o=new Tweenetik(t,e,i,s,n);return Tweenetik._active.push(o),o}update(t){if(this._finished)return;if(this._elapsed+=t,this._elapsed<this.delay)return;const e=this._elapsed-this.delay,i=Math.min(e/this.duration,1);!this._started&&i>0&&(this._started=!0,this.onStart&&this.onStart());const s=this.easingFn(i);for(const t in this._startProps){const e=this._startProps[t],i=this.toProps[t];this.target[t]=Tween.lerp(e,i,s)}this.onUpdate&&this.onUpdate(),i>=1&&(this._finished=!0,this.onComplete&&this.onComplete())}static updateAll(t){for(const e of Tweenetik._active)e.update(t);Tweenetik._active=Tweenetik._active.filter((t=>!t._finished))}}class Pipeline extends Loggable{constructor(t){super(),this.game=t,this.gameObjects=[];["inputdown","inputup","inputmove"].forEach((t=>{this.game.events.on(t,(e=>{this.dispatchInputEvent(t,e)}))}))}_hoverObject(t,e){if(!t.interactive||!t._hitTest)return;const i=t._hitTest(e.x,e.y);i&&!t._hovered?(t._hovered=!0,t.events.emit("mouseover",e)):!i&&t._hovered&&(t._hovered=!1,t.events.emit("mouseout",e))}_hoverScene(t,e){for(let i=t.children.length-1;i>=0;i--){const s=t.children[i];s instanceof Scene?this._hoverScene(s,e):this._hoverObject(s,e)}}dispatchInputEvent(t,e){var i;for(let s=this.gameObjects.length-1;s>=0;s--){const n=this.gameObjects[s];if(n instanceof Scene){if(this._dispatchToScene(n,t,e))break}else if(n.interactive&&(null==(i=n._hitTest)?void 0:i.call(n,e.x,e.y))){n.events.emit(t,e);break}}"inputmove"===t&&this._dispatchHover(e)}_dispatchHover(t){for(let e=this.gameObjects.length-1;e>=0;e--){const i=this.gameObjects[e];i instanceof Scene?this._hoverScene(i,t):this._hoverObject(i,t)}}_dispatchToScene(t,e,i){var s;for(let n=t.children.length-1;n>=0;n--){const o=t.children[n];if(o instanceof Scene){if(this._dispatchToScene(o,e,i))return!0}else if(o.interactive&&(null==(s=o._hitTest)?void 0:s.call(o,i.x,i.y)))return o.events.emit(e,i),!0}return!1}add(t){return t.parent=this,this.gameObjects=[...this.gameObjects,t],t}remove(t){this.gameObjects=this.gameObjects.filter((e=>e!==t))}update(t){this.gameObjects.filter((t=>t.active)).forEach((e=>e.update(t))),Tweenetik.updateAll(t)}render(){this.gameObjects.filter((t=>t.visible)).forEach((t=>t.render()))}clear(){this.gameObjects=[]}}class Cursor extends GameObject{constructor(t,e,i=null,s={}){super(t,s),this.normalShape=e,this.pressedShape=i||e,this.active=!1,this.offsetX=0,this.offsetY=0,this.isDown=!1,this.game.events.on("inputmove",(t=>{this.x=t.x,this.y=t.y})),this.game.events.on("inputdown",(()=>{this.isDown=!0})),this.game.events.on("inputup",(()=>{this.isDown=!1}))}activate(){this.active=!0,this.game.canvas.style.cursor="none"}deactivate(){this.active=!1,this.game.canvas.style.cursor="default"}update(t){super.update(t)}render(){if(!this.active)return;const t=this.isDown&&this.pressedShape?this.pressedShape:this.normalShape;t&&(t.x=this.x+this.offsetX,t.y=this.y+this.offsetY,t.draw(),super.render())}}class Game{constructor(t){this.canvas=t,this.ctx=t.getContext("2d"),this.events=new EventEmitter,this._cursor=null,this.lastTime=0,this.dt=0,this.running=!1,this._frame=0,this.pipeline=new Pipeline(this),this.targetFPS=60,this._frameInterval=1e3/this.targetFPS,this._accumulator=0,Painter.init(this.ctx),this.initIO(),this.initMotion(),this.initLogging(),this.logger.log("[Game] Constructor")}setFPS(t){this.targetFPS=t,this._frameInterval=1e3/t}init(){this.logger.log("[Game] Initialized")}initMouse(){Mouse.init(this)}initTouch(){Touch.init(this)}initInput(){Input.init(this)}initKeyboard(){Keys.init(this)}initIO(){this.initMouse(),this.initTouch(),this.initInput(),this.initKeyboard()}initMotion(){Tweenetik._active=[]}initLogging(){Logger.setOutput(console),Logger.setLevel(Logger.DEBUG),this.logger=new Logger("Game")}enableFluidSize(t=window){if(t===window){const t=()=>{this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight};t(),window.addEventListener("resize",t),this._fluidResizeCleanup=()=>{window.removeEventListener("resize",t)}}else{if(!("ResizeObserver"in window))return void console.warn("ResizeObserver not supported in this browser.");const e=()=>{const e=t.getBoundingClientRect();this.canvas.width=e.width,this.canvas.height=e.height},i=new ResizeObserver((()=>{e()}));i.observe(t),e(),this._fluidResizeCleanup=()=>i.disconnect()}}disableFluidSize(){this._fluidResizeCleanup&&(this._fluidResizeCleanup(),this._fluidResizeCleanup=null)}start(){this.running=!0,this.loop=this.loop.bind(this),requestAnimationFrame(this.loop),this.logger.log("[Game] Started")}stop(){this.running=!1,this.logger.log("[Game] Stopped")}restart(){this.pipeline.clear(),this.init(),this.start(),this.logger.log("[Game] Restarted")}loop(t){if(!this.running)return;const e=t-this.lastTime;if(this.lastTime=t,this._accumulator+=e,this._accumulator>=this._frameInterval){const t=this._frameInterval/1e3;this.dt=t,this._frame++,this.logger.groupCollapsed(`Frame #${this._frame}`),this.logger.time("render time"),this.update(t),this.render(),this.logger.timeEnd("render time"),this.logger.groupEnd(),this._accumulator-=this._frameInterval}requestAnimationFrame(this.loop)}update(t){this.pipeline.update(t)}render(){this.running&&this.clear(),this.pipeline.render()}clear(){Painter.clear()}get width(){return this.canvas.width}get height(){return this.canvas.height}set backgroundColor(t){this.canvas.style.backgroundColor=t}set cursor(t){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor)),this._cursor=t,this._cursor.activate(),this.pipeline.add(t)}get cursor(){return this._cursor}resetCursor(){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor),this._cursor=null)}}class Arc extends Shape{constructor(t,e,i,s,n,o={}){super(t,e,o),this.radius=i,this.startAngle=s,this.endAngle=n}draw(){super.draw();const t=Painter.ctx;t.beginPath(),t.arc(0,0,this.radius,this.startAngle,this.endAngle,!1),this.strokeColor&&Painter.colors.stroke(this.strokeColor,this.lineWidth)}getBounds(){const t=this.radius;return{x:this.x,y:this.y,width:2*t,height:2*t}}}class Circle extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.radius=i}draw(){super.draw(),this.fillColor&&Painter.shapes.fillCircle(0,0,this.radius,this.fillColor),this.strokeColor&&Painter.shapes.strokeCircle(0,0,this.radius,this.strokeColor,this.lineWidth)}getBounds(){const t=2*this.radius;return{x:this.x,y:this.y,width:t,height:t}}}class Cloud extends Shape{constructor(t,e,i=40,s={}){super(t,e,s),this.size=i}draw(){super.draw();const t=this.size,e=[["M",-t,0],["C",-t,-t,0,-t,0,0],["C",0,1.2*-t,1.2*t,-t,t,0],["C",1.5*t,.5*t,.5*t,1.2*t,0,t],["C",.8*-t,1.3*t,1.2*-t,.3*t,-t,0],["Z"]];Painter.lines.path(e,this.fillColor,this.strokeColor,this.lineWidth)}getBounds(){const t=2*this.size;return{x:this.x,y:this.y,width:t,height:t}}}class BezierShape extends Shape{constructor(t,e,i=[],s={}){super(t,e,s),this.path=i}draw(){super.draw(),Painter.lines.path(this.path,this.fillColor,this.strokeColor,this.lineWidth)}getBounds(){return{x:this.x,y:this.y,width:100,height:100}}}class Rectangle extends Shape{constructor(t,e,i,s,n={}){super(t,e,n),this.width=i,this.height=s}draw(){this.logger.log("Rect.draw",this.constructor.name,"position",this.x,this.y,"color",this.fillColor,"opacity",this.opacity),this.fillColor&&Painter.shapes.rect(0,0,this.width,this.height,this.fillColor),this.strokeColor&&Painter.shapes.outlineRect(0,0,this.width,this.height,this.strokeColor,this.lineWidth)}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class RoundedRectangle extends Shape{constructor(t,e,i,s,n=0,o={}){super(t,e,o),this.width=i,this.height=s,"number"==typeof n?this.radii=[n,n,n,n]:Array.isArray(n)?this.radii=4===n.length?n:[n[0]||0,n[1]||n[0]||0,n[2]||n[0]||0,n[3]||n[1]||n[0]||0]:this.radii=[0,0,0,0]}draw(){super.draw();const t=-this.width/2,e=-this.height/2;this.fillColor&&this.strokeColor?Painter.shapes.roundRect(t,e,this.width,this.height,this.radii,this.fillColor,this.strokeColor,this.lineWidth):this.fillColor?Painter.shapes.fillRoundRect(t,e,this.width,this.height,this.radii,this.fillColor):this.strokeColor&&Painter.shapes.strokeRoundRect(t,e,this.width,this.height,this.radii,this.strokeColor,this.lineWidth)}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class PatternRectangle extends Shape{constructor(t,e,i,s,n,o="repeat",a={}){super(t,e,a),this.width=i,this.height=s,this.image=n,this.repetition=o,this.pattern=null,n.complete?this.createPattern():n.addEventListener("load",(()=>this.createPattern()))}createPattern(){this.pattern=Painter.ctx.createPattern(this.image,this.repetition)}draw(){super.draw(),!this.pattern&&this.image.complete&&this.createPattern();const t=-this.width/2,e=-this.height/2;this.pattern?Painter.fillPattern(this.image,this.repetition,t,e,this.width,this.height):this.strokeColor&&Painter.shapes.outlineRect(t,e,this.width,this.height,this.strokeColor,this.lineWidth)}setImage(t,e){this.image=t,e&&(this.repetition=e),this.pattern=null,t.complete?this.createPattern():t.addEventListener("load",(()=>this.createPattern()))}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class Square extends Rectangle{constructor(t,e,i,s={}){super(t,e,i,i,s)}}class Cube extends Shape{constructor(t,e,i=50,s={}){super(t,e,s),this.size=i,this.faceTopColor=s.faceTopColor||"#eee",this.faceBottomColor=s.faceBottomColor||"#ccc",this.faceLeftColor=s.faceLeftColor||"#aaa",this.faceRightColor=s.faceRightColor||"#888",this.faceFrontColor=s.faceFrontColor||"#666",this.faceBackColor=s.faceBackColor||"#444",this.strokeColor=s.strokeColor||null,this.lineWidth=s.lineWidth||1,this.rotationX=s.rotationX||0,this.rotationY=s.rotationY||0,this.rotationZ=s.rotationZ||0,this.visibleFaces=s.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.size/2,e=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let o=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=o*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-o*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),o=t,s=e,{x:t=o*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=o*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},i=(t,i,s)=>{const n=e(t,i,s);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z}},s={p0:i(-t,-t,-t),p1:i(t,-t,-t),p2:i(t,t,-t),p3:i(-t,t,-t),p4:i(-t,-t,t),p5:i(t,-t,t),p6:i(t,t,t),p7:i(-t,t,t)},n={top:{points:[s.p4,s.p5,s.p6,s.p7],color:this.faceTopColor,normal:[0,0,1]},bottom:{points:[s.p0,s.p1,s.p2,s.p3],color:this.faceBottomColor,normal:[0,0,-1]},left:{points:[s.p0,s.p4,s.p7,s.p3],color:this.faceLeftColor,normal:[-1,0,0]},right:{points:[s.p1,s.p5,s.p6,s.p2],color:this.faceRightColor,normal:[1,0,0]},front:{points:[s.p0,s.p1,s.p5,s.p4],color:this.faceFrontColor,normal:[0,-1,0]},back:{points:[s.p3,s.p2,s.p6,s.p7],color:this.faceBackColor,normal:[0,1,0]}};this.visibleFaces.map((t=>{const e=n[t];if(!e)return null;const i=e.points.reduce(((t,e)=>({x:t.x+e.x,y:t.y+e.y})),{x:0,y:0});i.x/=e.points.length,i.y/=e.points.length;return{key:t,face:e,depth:i.x*i.x+i.y*i.y}})).filter((t=>null!==t)).sort(((t,e)=>e.depth-t.depth)).forEach((({key:t,face:e})=>{(null==e?void 0:e.color)&&Painter.shapes.polygon(e.points,e.color,this.strokeColor,this.lineWidth)}))}getBounds(){const t=1.5*this.size;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cone extends Shape{constructor(t,e,i=50,s=100,n={}){super(t,e,n),this.radius=i,this.height=s,this.segments=n.segments||24,this.bottomColor=n.bottomColor||"#eee",this.sideColor=n.sideColor||"#aaa",this.strokeColor=n.strokeColor||null,this.lineWidth=n.lineWidth||1,this.rotationX=n.rotationX||0,this.rotationY=n.rotationY||0,this.rotationZ=n.rotationZ||0,this.visibleFaces=n.visibleFaces||["bottom","side"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.radius,e=this.height/2,i=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let o=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=o*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-o*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),o=t,s=e,{x:t=o*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=o*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},s=(t,e,s)=>{const n=i(t,e,s);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z}},n=s(0,0,e),o=[],a=2*Math.PI/this.segments;for(let i=0;i<this.segments;i++){const n=i*a,r=Math.cos(n)*t,h=Math.sin(n)*t;o.push(s(r,h,-e))}const r=[];for(let t=0;t<this.segments;t++){const e=(t+1)%this.segments;r.push({points:[n,o[t],o[e]],z:(n.z+o[t].z+o[e].z)/3})}const h=[];this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...o].reverse(),z:-e}),this.visibleFaces.includes("side")&&h.push(...r.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,e)=>e.z-t.z));for(const t of h){const e="bottom"===t.type?this.bottomColor:this.sideColor;Painter.shapes.polygon(t.points,e,this.strokeColor,this.lineWidth)}}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Prism extends Shape{constructor(t,e,i=80,s=60,n=100,o={}){super(t,e,o),this.width=i,this.height=s,this.depth=n,this.faceTopColor=o.faceTopColor||"#eee",this.faceBottomColor=o.faceBottomColor||"#ccc",this.faceLeftColor=o.faceLeftColor||"#aaa",this.faceRightColor=o.faceRightColor||"#888",this.faceFrontColor=o.faceFrontColor||"#666",this.faceBackColor=o.faceBackColor||"#444",this.strokeColor=o.strokeColor||null,this.lineWidth=o.lineWidth||1,this.rotationX=o.rotationX||0,this.rotationY=o.rotationY||0,this.rotationZ=o.rotationZ||0,this.visibleFaces=o.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.width/2,e=this.height/2,i=this.depth/2,s=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let o=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=o*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-o*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),o=t,s=e,{x:t=o*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=o*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},n=(t,e,i)=>{const n=s(t,e,i);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z}},o={p0:n(-t,-i,-e),p1:n(t,-i,-e),p2:n(0,-i,e),p3:n(-t,i,-e),p4:n(t,i,-e),p5:n(0,i,e)},a={front:{points:[o.p0,o.p1,o.p2],color:this.faceFrontColor},back:{points:[o.p3,o.p4,o.p5],color:this.faceBackColor},bottom:{points:[o.p0,o.p1,o.p4,o.p3],color:this.faceBottomColor},right:{points:[o.p1,o.p2,o.p5,o.p4],color:this.faceRightColor},left:{points:[o.p0,o.p2,o.p5,o.p3],color:this.faceLeftColor}};this.visibleFaces.filter((t=>a[t])).map((t=>{const e=a[t],i=e.points.reduce(((t,e)=>t+e.x),0)/e.points.length,s=e.points.reduce(((t,e)=>t+e.y),0)/e.points.length,n=e.points.reduce(((t,e)=>t+(e.z||0)),0)/e.points.length;return{key:t,face:e,depth:i*i+s*s+n*n}})).sort(((t,e)=>e.depth-t.depth)).forEach((({key:t,face:e})=>{(null==e?void 0:e.color)&&Painter.shapes.polygon(e.points,e.color,this.strokeColor,this.lineWidth)}))}getBounds(){const t=1.5*Math.max(this.width,this.height,this.depth);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cylinder extends Shape{constructor(t,e,i=40,s=80,n={}){super(t,e,n),this.radius=i,this.height=s,this.segments=n.segments||24,this.topColor=n.topColor||"#FF00FF",this.bottomColor=n.bottomColor||"#FF0FFF",this.sideColor=n.sideColor||"#00FF00",this.strokeColor=n.strokeColor||"#000000",this.lineWidth=n.lineWidth||1,this.rotationX=n.rotationX||0,this.rotationY=n.rotationY||0,this.rotationZ=n.rotationZ||0,this.visibleFaces=n.visibleFaces||["top","bottom","side"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.radius,e=this.height/2,i=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let o=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=o*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-o*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),o=t,s=e,{x:t=o*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=o*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},s=(t,e,s)=>{const n=i(t,e,s);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z}},n=[],o=[],a=2*Math.PI/this.segments;for(let i=0;i<this.segments;i++){const r=i*a,h=Math.cos(r)*t,l=Math.sin(r)*t;n.push(s(h,l,e)),o.push(s(h,l,-e))}const r=[];for(let t=0;t<this.segments;t++){const e=(t+1)%this.segments;r.push({points:[o[t],o[e],n[e],n[t]],z:(n[t].z+n[e].z+o[t].z+o[e].z)/4})}const h=[];this.visibleFaces.includes("top")&&h.push({type:"top",points:n,z:e}),this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...o].reverse(),z:-e}),this.visibleFaces.includes("side")&&h.push(...r.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,e)=>e.z-t.z));for(const t of h){let e;switch(t.type){case"top":e=this.topColor;break;case"bottom":e=this.bottomColor;break;case"side":e=this.sideColor}Painter.shapes.polygon(t.points,e,this.strokeColor,this.lineWidth)}}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Diamond extends Shape{constructor(t,e,i,s,n={}){super(t,e,n),this.width=i,this.height=s}draw(){super.draw();const t=this.width/2,e=this.height/2,i=[{x:0,y:-e},{x:t,y:0},{x:0,y:e},{x:-t,y:0}];Painter.shapes.polygon(i,this.fillColor,this.strokeColor,this.lineWidth)}}class Line extends Shape{constructor(t,e,i=40,s={}){super(t,e,s),this.length=i}draw(){super.draw();const t=this.length/2;Painter.lines.line(-t,-t,t,t,this.strokeColor,this.lineWidth)}}class Triangle extends Shape{constructor(t,e,i=50,s={}){super(t,e,s),this.size=i}draw(){super.draw();const t=this.size/2,e=[{x:0,y:-t},{x:t,y:t},{x:-t,y:t}];Painter.shapes.polygon(e,this.fillColor,this.strokeColor,this.lineWidth)}}class Star extends Shape{constructor(t,e,i=40,s=5,n=.5,o={}){super(t,e,o),this.radius=i,this.spikes=s,this.inset=n}draw(){super.draw();const t=Math.PI/this.spikes,e=-Math.PI/2;Painter.ctx.beginPath();for(let i=0;i<2*this.spikes;i++){const s=i%2==0?this.radius:this.radius*this.inset,n=i*t+e,o=Math.cos(n)*s,a=Math.sin(n)*s;0===i?Painter.ctx.moveTo(o,a):Painter.ctx.lineTo(o,a)}Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.colors.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.colors.stroke())}}class Sphere extends Shape{constructor(t,e,i=50,s={}){super(t,e,s),this.radius=i,this.hSegments=s.hSegments||16,this.vSegments=s.vSegments||12,this.color=s.color||"#6495ED",this.highlightColor=s.highlightColor||"#FFFFFF",this.wireframe=s.wireframe||!1,this.strokeColor=s.strokeColor||"#333333",this.lineWidth=s.lineWidth||1,this.rotationX=s.rotationX||0,this.rotationY=s.rotationY||0,this.rotationZ=s.rotationZ||0}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}calculateSurfaceColor(t,e,i){let s=t*(1/Math.sqrt(3))+e*(1/Math.sqrt(3))+i*(1/Math.sqrt(3));if(s=Math.max(.3,s),this.highlightColor){const t=this.hexToRgb(this.color),e=this.hexToRgb(this.highlightColor);return`rgb(${Math.round(t.r*(1-s)+e.r*s)}, ${Math.round(t.g*(1-s)+e.g*s)}, ${Math.round(t.b*(1-s)+e.b*s)})`}const n=this.hexToRgb(this.color);return`rgb(${Math.min(255,Math.round(n.r*s))}, ${Math.min(255,Math.round(n.g*s))}, ${Math.min(255,Math.round(n.b*s))})`}hexToRgb(t){const e={r:100,g:100,b:255};if(!t||"string"!=typeof t)return e;const i=t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,((t,e,i,s)=>e+e+i+i+s+s)),s=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(i);return s?{r:parseInt(s[1],16),g:parseInt(s[2],16),b:parseInt(s[3],16)}:e}draw(){super.draw();const t=this.radius,e=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let o=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=o*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-o*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),o=t,s=e,{x:t=o*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=o*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},i=(i,s,n)=>{const o=e(i,s,n);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z,z:o.z,nx:o.x/t,ny:o.y/t,nz:o.z/t}},s=[];for(let e=0;e<=this.vSegments;e++){const n=[],o=e/this.vSegments,a=Math.PI*o-Math.PI/2;for(let e=0;e<=this.hSegments;e++){const s=e/this.hSegments,o=2*Math.PI*s,r=t*Math.cos(a)*Math.cos(o),h=t*Math.cos(a)*Math.sin(o),l=t*Math.sin(a);n.push(i(r,h,l))}s.push(n)}const n=[];for(let t=0;t<this.vSegments;t++)for(let e=0;e<this.hSegments;e++){const i=s[t][e],o=s[t][e+1],a=s[t+1][e],r=s[t+1][e+1],h=(i.z+o.z+a.z+r.z)/4,l=(i.nx+o.nx+a.nx+r.nx)/4,c=(i.ny+o.ny+a.ny+r.ny)/4,u=(i.nz+o.nz+a.nz+r.nz)/4;n.push({points:[i,o,r,a],z:h,color:this.calculateSurfaceColor(l,c,u)})}if(n.sort(((t,e)=>e.z-t.z)),this.wireframe)for(const t of n){const e=t.points;for(let t=0;t<e.length;t++){const i=(t+1)%e.length;Painter.lines.line(e[t].x,e[t].y,e[i].x,e[i].y,this.strokeColor,this.lineWidth)}}else for(const t of n)Painter.shapes.polygon(t.points,t.color,this.strokeColor,this.lineWidth)}getBounds(){const t=2*this.radius*1.5;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class SVGPath extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.scale=s.scale||1,this.centerPath=void 0===s.centerPath||s.centerPath,this.animationProgress=void 0!==s.animationProgress?s.animationProgress:1,this.svgPathData=i,this.pathCommands=this.parseSVGPath(i),this.centerPath?this.pathCommands=this.centerAndScalePath(this.pathCommands,this.scale):this.pathCommands=this.scalePath(this.pathCommands,this.scale),this.prevX=0,this.prevY=0,this.currentPoint={x:0,y:0}}parseSVGPath(t){const e=/M\s*([-\d.]+)[,\s]*([-\d.]+)/g,i=/L\s*([-\d.]+)[,\s]*([-\d.]+)/g,s=/C\s*([-\d.]+)[,\s]*([-\d.]+)\s*([-\d.]+)[,\s]*([-\d.]+)\s*([-\d.]+)[,\s]*([-\d.]+)/g,n=[];let o;for(;null!==(o=e.exec(t));)n.push(["M",parseFloat(o[1]),parseFloat(o[2])]);for(;null!==(o=i.exec(t));){const t=parseFloat(o[1]),e=parseFloat(o[2]);let i=0,s=0;for(let t=n.length-1;t>=0;t--){const e=n[t];if("M"===e[0]){i=e[1],s=e[2];break}if("C"===e[0]){i=e[5],s=e[6];break}}const a=i+(t-i)/3,r=s+(e-s)/3,h=i+2*(t-i)/3,l=s+2*(e-s)/3;n.push(["C",a,r,h,l,t,e])}for(;null!==(o=s.exec(t));)n.push(["C",parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3]),parseFloat(o[4]),parseFloat(o[5]),parseFloat(o[6])]);return/Z/g.test(t)&&n.push(["Z"]),n}centerAndScalePath(t,e){let i=1/0,s=1/0,n=-1/0,o=-1/0;for(const e of t)"M"===e[0]?(i=Math.min(i,e[1]),s=Math.min(s,e[2]),n=Math.max(n,e[1]),o=Math.max(o,e[2])):"C"===e[0]&&(i=Math.min(i,e[1],e[3],e[5]),s=Math.min(s,e[2],e[4],e[6]),n=Math.max(n,e[1],e[3],e[5]),o=Math.max(o,e[2],e[4],e[6]));const a=(i+n)/2,r=(s+o)/2;return this.originalWidth=(n-i)*e,this.originalHeight=(o-s)*e,t.map((t=>"M"===t[0]?["M",(t[1]-a)*e,(t[2]-r)*e]:"C"===t[0]?["C",(t[1]-a)*e,(t[2]-r)*e,(t[3]-a)*e,(t[4]-r)*e,(t[5]-a)*e,(t[6]-r)*e]:[...t]))}scalePath(t,e){let i=1/0,s=1/0,n=-1/0,o=-1/0;for(const e of t)"M"===e[0]?(i=Math.min(i,e[1]),s=Math.min(s,e[2]),n=Math.max(n,e[1]),o=Math.max(o,e[2])):"C"===e[0]&&(i=Math.min(i,e[1],e[3],e[5]),s=Math.min(s,e[2],e[4],e[6]),n=Math.max(n,e[1],e[3],e[5]),o=Math.max(o,e[2],e[4],e[6]));return this.originalWidth=(n-i)*e,this.originalHeight=(o-s)*e,t.map((t=>"M"===t[0]?["M",t[1]*e,t[2]*e]:"C"===t[0]?["C",t[1]*e,t[2]*e,t[3]*e,t[4]*e,t[5]*e,t[6]*e]:[...t]))}getBezierPoint(t,e){if("M"===t[0])return{x:t[1],y:t[2]};if("C"===t[0]){const i=this.prevX,s=this.prevY,n=t[1],o=t[2],a=t[3],r=t[4],h=t[5],l=t[6];return{x:Math.pow(1-e,3)*i+3*Math.pow(1-e,2)*e*n+3*(1-e)*Math.pow(e,2)*a+Math.pow(e,3)*h,y:Math.pow(1-e,3)*s+3*Math.pow(1-e,2)*e*o+3*(1-e)*Math.pow(e,2)*r+Math.pow(e,3)*l}}return{x:0,y:0}}getPartialPath(){const t=[];let e=this.pathCommands.length,i=Math.floor(this.animationProgress*e),s=this.animationProgress*e%1,n=!1;this.prevX=0,this.prevY=0;for(let e=0;e<i;e++){const i=this.pathCommands[e];t.push([...i]),"M"===i[0]?(this.prevX=i[1],this.prevY=i[2],n=!0):"C"===i[0]&&(this.prevX=i[5],this.prevY=i[6],n=!0)}if(i<e){const e=this.pathCommands[i];if("M"===e[0])t.push([...e]),this.prevX=e[1],this.prevY=e[2],this.currentPoint={x:e[1],y:e[2]},n=!0;else if("C"===e[0]){if(!n){for(let t=i-1;t>=0;t--)if("M"===this.pathCommands[t][0]){this.prevX=this.pathCommands[t][1],this.prevY=this.pathCommands[t][2],n=!0;break}n||(this.prevX=0,this.prevY=0)}const o=this.getBezierPoint(e,s);t.push(["C",e[1],e[2],e[3],e[4],o.x,o.y]),this.currentPoint=o}}return t}draw(){super.draw();const t=this.getPartialPath();Painter.lines.path(t,this.fillColor,this.strokeColor,this.lineWidth)}getCurrentPoint(){return{x:this.x+this.currentPoint.x,y:this.y+this.currentPoint.y}}setAnimationProgress(t){this.animationProgress=Math.max(0,Math.min(1,t))}getBounds(){return{x:this.x,y:this.y,width:this.originalWidth||100,height:this.originalHeight||100}}}class StickFigure extends Shape{constructor(t,e,i=1,s={}){super(t,e,s),this.scale=i,this.strokeColor=s.strokeColor||"#000",this.headColor=s.headColor||this.strokeColor,this.jointColor=s.jointColor||this.strokeColor,this.lineWidth=s.lineWidth||2,this.showJoints=!1!==s.showJoints}draw(){super.draw();const t=this.scale,e=10*t,i=-30*t,s=i+e,n=s+40*t,o=s+10*t,a=15*t,r=10*t,h=n+40*t,l=3*t;if(Painter.shapes.fillCircle(0,i,e,this.headColor),Painter.shapes.strokeCircle(0,i,e,this.strokeColor,this.lineWidth),Painter.lines.line(0,s,0,n,this.strokeColor,this.lineWidth),Painter.lines.line(-a,o,a,o,this.strokeColor,this.lineWidth),Painter.lines.line(0,n,-r,h,this.strokeColor,this.lineWidth),Painter.lines.line(0,n,r,h,this.strokeColor,this.lineWidth),this.showJoints){[[0,s],[-a,o],[a,o],[0,n],[-r,h],[r,h]].forEach((([t,e])=>Painter.shapes.fillCircle(t,e,l,this.jointColor)))}}getBounds(){const t=100*this.scale,e=40*this.scale;return{x:this.x,y:this.y,width:e,height:t}}}class Ring extends Shape{constructor(t,e,i,s,n={}){super(t,e,n),this.outerRadius=i,this.innerRadius=s}draw(){super.draw(),Painter.ctx.beginPath(),Painter.ctx.arc(0,0,this.outerRadius,0,2*Math.PI),Painter.ctx.arc(0,0,this.innerRadius,0,2*Math.PI,!0),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.colors.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.colors.stroke())}}class Polygon extends Shape{constructor(t,e,i=6,s=40,n={}){super(t,e,n),this.sides=i,this.radius=s}draw(){super.draw();const t=[],e=2*Math.PI/this.sides;for(let i=0;i<this.sides;i++){const s=i*e;t.push({x:Math.cos(s)*this.radius,y:Math.sin(s)*this.radius})}Painter.shapes.polygon(t,this.fillColor,this.strokeColor,this.lineWidth)}}class Arrow extends Shape{constructor(t,e,i,s,n={}){super(t,e,n),this.length=i,this.width=s}draw(){super.draw();const t=this.width/2,e=.4*this.length,i=this.length-e;Painter.ctx.beginPath(),Painter.ctx.moveTo(-i/2,-t),Painter.ctx.lineTo(i/2,-t),Painter.ctx.lineTo(i/2,-this.width),Painter.ctx.lineTo(this.length/2,0),Painter.ctx.lineTo(i/2,this.width),Painter.ctx.lineTo(i/2,t),Painter.ctx.lineTo(-i/2,t),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.colors.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.colors.stroke())}}class Pin extends Shape{constructor(t,e,i=20,s={}){super(t,e,s),this.radius=i}draw(){super.draw();const t=this.radius,e=2.5*t;Painter.ctx.beginPath(),Painter.ctx.arc(0,0,t,Math.PI,0),Painter.ctx.lineTo(t,0),Painter.ctx.lineTo(0,e),Painter.ctx.lineTo(-t,0),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.colors.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.colors.stroke())}getBounds(){return{x:this.x,y:this.y+.98*this.radius,width:2*this.radius,height:2.5*this.radius}}}class PieSlice extends Shape{constructor(t,e,i,s,n,o={}){super(t,e,o),this.radius=i,this.startAngle=s,this.endAngle=n}draw(){super.draw(),Painter.ctx.beginPath(),Painter.ctx.moveTo(0,0),Painter.ctx.arc(0,0,this.radius,this.startAngle,this.endAngle),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.colors.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.colors.stroke())}}class Hexagon extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.radius=i}draw(){super.draw();const t=Array.from({length:6},((t,e)=>{const i=Math.PI/3*e;return{x:Math.cos(i)*this.radius,y:Math.sin(i)*this.radius}}));Painter.shapes.polygon(t,this.fillColor,this.strokeColor,this.lineWidth)}}class Heart extends Shape{constructor(t,e,i=50,s=50,n={}){super(t,e,n),this.width=i,this.height=s}draw(){super.draw();const t=this.width,e=this.height,i=.3*e,s=Painter.ctx;s.beginPath(),s.moveTo(0,i),s.bezierCurveTo(0,0,-t/2,0,-t/2,i),s.bezierCurveTo(-t/2,.8*e,0,e,0,e),s.bezierCurveTo(0,e,t/2,.8*e,t/2,i),s.bezierCurveTo(t/2,0,0,0,0,i),s.closePath(),this.fillColor&&(s.fillStyle=this.fillColor,Painter.colors.fill()),this.strokeColor&&(s.strokeStyle=this.strokeColor,s.lineWidth=this.lineWidth,Painter.colors.stroke())}getBounds(){return{x:this.x,y:this.y+this.height/2,width:this.width,height:this.height}}}class Cross extends Shape{constructor(t,e,i,s,n={}){super(t,e,n),this.size=i,this.thickness=s,this.diagonal=n.diagonal||!1}draw(){super.draw();const t=this.size/2,e=this.thickness/2;this.diagonal?(Painter.ctx.beginPath(),Painter.ctx.moveTo(-t,-t+e),Painter.ctx.lineTo(-t+e,-t),Painter.ctx.lineTo(0,-e),Painter.ctx.lineTo(t-e,-t),Painter.ctx.lineTo(t,-t+e),Painter.ctx.lineTo(e,0),Painter.ctx.lineTo(t,t-e),Painter.ctx.lineTo(t-e,t),Painter.ctx.lineTo(0,e),Painter.ctx.lineTo(-t+e,t),Painter.ctx.lineTo(-t,t-e),Painter.ctx.lineTo(-e,0),Painter.ctx.closePath()):(Painter.ctx.beginPath(),Painter.ctx.moveTo(-e,-t),Painter.ctx.lineTo(e,-t),Painter.ctx.lineTo(e,-e),Painter.ctx.lineTo(t,-e),Painter.ctx.lineTo(t,e),Painter.ctx.lineTo(e,e),Painter.ctx.lineTo(e,t),Painter.ctx.lineTo(-e,t),Painter.ctx.lineTo(-e,e),Painter.ctx.lineTo(-t,e),Painter.ctx.lineTo(-t,-e),Painter.ctx.lineTo(-e,-e),Painter.ctx.closePath()),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.colors.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.colors.stroke())}}class Group extends Transformable{constructor(t,e,i={}){super(t,e,i),this.children=[],this._cachedBounds=null,this._childrenVersion=0,this._childOriginalProps=new WeakMap,this._inheritanceConfig={opacity:void 0===i.inheritOpacity||i.inheritOpacity,visible:void 0===i.inheritVisible||i.inheritVisible,scaleX:void 0===i.inheritScale||i.inheritScale,scaleY:void 0===i.inheritScale||i.inheritScale}}add(t){if(!(t instanceof Transformable))throw new TypeError("Group can only add Transformable instances");if(this.children.includes(t))throw new Error("Object is already in this group");return this._childOriginalProps.set(t,{opacity:t.opacity,visible:t.visible,scaleX:t.scaleX,scaleY:t.scaleY}),this.children.push(t),this._invalidateBounds(),this._applyInheritanceToChild(t),t}remove(t){const e=this.children.indexOf(t);if(-1!==e){if(this._childOriginalProps.has(t)){const e=this._childOriginalProps.get(t);t.opacity=e.opacity,t.visible=e.visible,t.scaleX=e.scaleX,t.scaleY=e.scaleY,this._childOriginalProps.delete(t)}return this.children.splice(e,1),this._invalidateBounds(),!0}return!1}clear(){for(const t of this.children)if(this._childOriginalProps.has(t)){const e=this._childOriginalProps.get(t);t.opacity=e.opacity,t.visible=e.visible,t.scaleX=e.scaleX,t.scaleY=e.scaleY}this._childOriginalProps=new WeakMap,this.children=[],this._invalidateBounds()}_invalidateBounds(){this._cachedBounds=null,this._childrenVersion++}_applyInheritanceToChild(t){this._childOriginalProps.has(t)||this._childOriginalProps.set(t,{opacity:t.opacity??1,visible:t.visible??!0,scaleX:t.scaleX??1,scaleY:t.scaleY??1});const e=this._childOriginalProps.get(t);if(this._inheritanceConfig.opacity){const i=e.opacity??1,s=this.opacity??1;t.opacity=i*s}if(this._inheritanceConfig.visible){const i=e.visible??!0,s=this.visible??!0;t.visible=i&&s}if(this._inheritanceConfig.scaleX){const i=e.scaleX??1,s=this.scaleX??1;t.scaleX=i*s}if(this._inheritanceConfig.scaleY){const i=e.scaleY??1,s=this.scaleY??1;t.scaleY=i*s}}_updateChildrenInheritance(){for(const t of this.children)this._applyInheritanceToChild(t)}setInheritance(t,e){return"scale"===t?(this._inheritanceConfig.scaleX=e,this._inheritanceConfig.scaleY=e):t in this._inheritanceConfig&&(this._inheritanceConfig[t]=e),this._updateChildrenInheritance(),this}render(){this.traceRender();for(const t of this.children)t.visible&&t.render()}getBounds(){if(this._cachedBounds)return this._cachedBounds;if(0===this.children.length)return null;const t=this.children.map((t=>{const e="function"==typeof t.getBounds?t.getBounds():null;if(!e)return null;const i=e.width/2,s=e.height/2;return{minX:e.x-i,maxX:e.x+i,minY:e.y-s,maxY:e.y+s}})).filter((t=>null!==t));if(0===t.length)return null;const e=Math.min(...t.map((t=>t.minX))),i=Math.max(...t.map((t=>t.maxX))),s=Math.min(...t.map((t=>t.minY))),n=i-e,o=Math.max(...t.map((t=>t.maxY)))-s,a=e+n/2,r=s+o/2;return this._cachedBounds={x:this.x+a,y:this.y+r,width:n,height:o},this._cachedBounds}update(t){super.update(t);for(const e of this.children)e.active&&"function"==typeof e.update&&e.update(t)}set opacity(t){super.opacity=t,this._inheritanceConfig.opacity&&this._updateChildrenInheritance()}set visible(t){super.visible=t,this._inheritanceConfig.visible&&this._updateChildrenInheritance()}set scaleX(t){super.scaleX=t,this._inheritanceConfig.scaleX&&this._updateChildrenInheritance()}set scaleY(t){super.scaleY=t,this._inheritanceConfig.scaleY&&this._updateChildrenInheritance()}}class TextShape extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.text=i,this.font=s.font||"12px monospace",this.color=s.color||"#000",this.align=s.align||"center",this.baseline=s.baseline||"top"}draw(){super.draw(),Painter.text.setFont(this.font),Painter.text.setTextAlign(this.align),Painter.text.setTextBaseline(this.baseline),Painter.text.fillText(this.text,0,0,this.color)}getBounds(){const t=Painter.ctx;if(!t)return super.getBounds();t.font=this.font;const e=t.measureText(this.text),i=e.actualBoundingBoxLeft+e.actualBoundingBoxRight+this.lineWidth,s=e.actualBoundingBoxAscent+e.actualBoundingBoxDescent+this.lineWidth;return this.width=i,this.height=s,{x:this.x,y:this.y,width:i,height:s}}}class OutlinedText extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.text=i,this.centered=s.centered||!1,this.fillColor=s.fillColor||"#000000",this.strokeColor=s.strokeColor||"#FFFFFF",this.lineWidth=s.lineWidth||1,this.font=s.font||null,this.align=s.align||"left",this.baseline=s.baseline||"alphabetic",this.calculateDimensions()}calculateDimensions(){if(!Painter.ctx)return console.warn("Painter context not initialized. Cannot calculate text dimensions."),this.width=0,void(this.height=0);const t=Painter.ctx.font;this.font&&(Painter.ctx.font=this.font);const e=Painter.ctx.measureText(this.text);if(this.width=e.width,this.font){const t=parseInt(this.font);this.height=isNaN(t)?20:t}else this.height=e.actualBoundingBoxAscent+e.actualBoundingBoxDescent||20;this.width+=2*this.lineWidth,this.height+=2*this.lineWidth,Painter.ctx.font=t}setText(t){this.text=t,this.calculateDimensions()}draw(){if(super.draw(),!Painter.ctx)return void console.warn("Painter context not initialized. Cannot draw text.");let t=0;this.font&&(Painter.ctx.font=this.font),Painter.ctx.textAlign=this.align,Painter.ctx.textBaseline=this.baseline,this.centered&&("middle"===this.baseline||"alphabetic"===this.baseline?t=0:"top"===this.baseline?t=this.height/2:"bottom"===this.baseline&&(t=-this.height/2)),Painter.outlinedText(this.text,0,t,this.fillColor,this.strokeColor,this.lineWidth,this.font)}getBounds(){const t=Painter.ctx;if(!t)return super.getBounds();const e=t.font;t.font=this.font;const i=t.measureText(this.text),s=i.width,n=i.actualBoundingBoxAscent+i.actualBoundingBoxDescent||parseInt(this.font)||20;return t.font=e,this.width=s,this.height=n,{x:this.x,y:this.y,width:s,height:n}}}class WrappedText extends Shape{constructor(t,e,i,s,n=20,o={}){super(t,e,o),this.text=i,this.maxWidth=s,this.lineHeight=n,this.centered=o.centered||!1,this.fillColor=o.fillColor||"#000000",this.font=o.font||null,this.align=o.align||"left",this.baseline=o.baseline||"top",this.outlineColor=o.outlineColor||null,this.outlineWidth=o.outlineWidth||1,this.calculateDimensions()}calculateDimensions(){if(!Painter.ctx)return console.warn("Painter context not initialized. Cannot calculate text dimensions."),this.width=this.maxWidth,this.height=this.lineHeight,void(this.lines=[this.text]);const t=Painter.ctx.font,e=Painter.ctx.textAlign,i=Painter.ctx.textBaseline;this.font&&(Painter.ctx.font=this.font),Painter.ctx.textAlign="left",Painter.ctx.textBaseline="top";const s=this.text.split(" ");let n="",o="";this.lines=[],this.width=0;for(let t=0;t<s.length;t++){o=n+s[t]+" ";Painter.ctx.measureText(o).width>this.maxWidth&&t>0?(this.lines.push(n),this.width=Math.max(this.width,Painter.ctx.measureText(n).width),n=s[t]+" "):n=o}this.lines.push(n),this.width=Math.max(this.width,Painter.ctx.measureText(n).width),this.height=this.lines.length*this.lineHeight,Painter.ctx.font=t,Painter.ctx.textAlign=e,Painter.ctx.textBaseline=i}setText(t){this.text=t,this.calculateDimensions()}draw(){if(super.draw(),!Painter.ctx)return void console.warn("Painter context not initialized. Cannot draw text.");let t=0,e=0;this.centered&&(t=-this.width/2,e=-this.height/2),this.font&&(Painter.ctx.font=this.font),Painter.ctx.textAlign=this.align,Painter.ctx.textBaseline=this.baseline;let i=t;"center"===this.align?i=0:"right"===this.align&&(i=t+this.width);for(let t=0;t<this.lines.length;t++){const s=e+t*this.lineHeight;this.outlineColor?Painter.outlinedText(this.lines[t],i,s,this.fillColor,this.outlineColor,this.outlineWidth,this.font):Painter.text.fillText(this.lines[t],i,s,this.fillColor,this.font)}}getBounds(){return this.centered?{x:this.x,y:this.y,width:this.width,height:this.height}:{x:this.x+this.width/2,y:this.y+this.height/2,width:this.width,height:this.height}}}const index=Object.freeze(Object.defineProperty({__proto__:null,Arc:Arc,Arrow:Arrow,BezierShape:BezierShape,Circle:Circle,Cloud:Cloud,Cone:Cone,Cross:Cross,Cube:Cube,Cylinder:Cylinder,Diamond:Diamond,Group:Group,Heart:Heart,Hexagon:Hexagon,Line:Line,OutlinedText:OutlinedText,PatternRectangle:PatternRectangle,PieSlice:PieSlice,Pin:Pin,Polygon:Polygon,Prism:Prism,Rectangle:Rectangle,Renderable:Renderable,Ring:Ring,RoundedRectangle:RoundedRectangle,SVGShape:SVGPath,Shape:Shape,Sphere:Sphere,Square:Square,Star:Star,StickFigure:StickFigure,TextShape:TextShape,Transformable:Transformable,Triangle:Triangle,WrappedText:WrappedText},Symbol.toStringTag,{value:"Module"}));class Button extends GameObject{constructor(t,e={}){const{x:i=0,y:s=0,width:n=120,height:o=40,text:a="Button",shape:r=null,label:h=null,onClick:l=null,anchor:c,padding:u,...d}=e;super(t,{anchor:c,padding:u,...d}),this.x=i,this.y=s,this.width=n,this.height=o,this.state="default",this.bg=r??new Rectangle(0,0,n,o,{fillColor:"#eee",strokeColor:"#ccc",lineWidth:2}),this.label=h??new TextShape(0,0,a,{font:"16px monospace",color:"#333",align:"center",baseline:"middle"}),this.group=new Group(i,s),this.group.add(this.bg),this.group.add(this.label),this.enableInteractivity(this.group),this.on("mouseover",this.setState.bind(this,"hover")),this.on("mouseout",this.setState.bind(this,"default")),this.on("inputdown",this.setState.bind(this,"pressed")),this.on("inputup",(()=>{"pressed"===this.state&&"function"==typeof l&&l(),this.setState("hover")})),this.setState("default")}setState(t){if(this.state!==t)switch(this.state=t,t){case"default":this.game.cursor&&setTimeout((()=>{this.game.cursor.activate()}),0),this.bg.fillColor="#eee",this.bg.strokeColor="#ccc",this.label.color="#333",this.game.canvas.style.cursor="default";break;case"hover":this.game.cursor&&this.game.cursor.deactivate(),this.bg.fillColor="#222",this.bg.strokeColor="#16F529",this.label.color="#16F529",this.game.canvas.style.cursor="pointer";break;case"pressed":this.game.cursor&&this.game.cursor.deactivate(),this.bg.fillColor="#111",this.bg.strokeColor="#00aaff",this.label.color="#00aaff",this.game.canvas.style.cursor="pointer"}}update(t){this.group.x=this.x,this.group.y=this.y}render(){this.group.draw()}}class ToggleButton extends Button{constructor(t,e={}){const i=e.onClick;super(t,{...e,onClick:()=>{this.toggled=!this.toggled,"function"==typeof e.onToggle&&e.onToggle(this.toggled),"function"==typeof i&&i(),this.refreshToggleVisual()}}),this.toggled=!!e.startToggled,this.refreshToggleVisual()}toggle(t){this.toggled=t,this.refreshToggleVisual()}refreshToggleVisual(){this.toggled?(this.bg.fillColor="#444",this.bg.strokeColor="#0f0",this.label.color="#0f0"):(this.bg.fillColor="#eee",this.bg.strokeColor="#ccc",this.label.color="#333")}setState(t){super.setState(t),this.toggled&&(this.bg.fillColor="#444",this.bg.strokeColor="#0f0",this.label.color="#0f0")}}class FPSCounter extends Text{constructor(t,e={}){super(t,"0 FPS",{x:0,y:0,font:e.font||"12px monospace",color:e.color||"#0f0",align:e.align,baseline:e.baseline,stroke:e.stroke||!1,strokeColor:e.strokeColor||"#000",lineWidth:e.lineWidth||1,anchor:e.anchor||"top-left"}),this.fps=0,this._frames=0,this._accum=0}update(t){var e;this._frames++,this._accum+=t,this._accum>=.5&&(this.fps=Math.round(this._frames/this._accum),this.text=`${this.fps} FPS`,this._frames=0,this._accum=0),null==(e=super.update)||e.call(this,t)}}class LayoutScene extends Scene{constructor(t,e={}){super(t,e),this.spacing=e.spacing??10,this.padding=e.padding??0,this.autoSize=e.autoSize??!0,this.align=e.align??"start",this.debug=e.debug??!1,this.width=0,this.height=0}render(){super.render()}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}update(t){var e;null==(e=super.update)||e.call(this,t);for(let e of this.children)e.update&&e.update(t)}}class HorizontalLayout extends LayoutScene{update(t){let e=this.padding,i=0;for(let t of this.children)i=Math.max(i,t.height??0);for(let t=0;t<this.children.length;t++){const s=this.children[t],n=this.y+(s.height??0)/2;switch(s.x=this.x+e+(s.width??0)/2,this.align){case"center":s.y=n+this.padding+(i-(s.height??0))/2;break;case"end":s.y=n+this.padding+(i-(s.height??0));break;default:s.y=n+this.padding}e+=s.width??0,t<this.children.length-1&&(e+=this.spacing)}this.autoSize&&(this.width=e+this.padding,this.height=i+2*this.padding),super.update(t)}}class VerticalLayout extends LayoutScene{update(t){let e=this.padding,i=0;for(let t of this.children)i=Math.max(i,t.width??0);for(let t=0;t<this.children.length;t++){const s=this.children[t],n=this.x+(s.width??0)/2;switch(s.y=this.y+e+(s.height??0)/2,this.align){case"center":s.x=n+this.padding+(i-(s.width??0))/2;break;case"end":s.x=n+this.padding+(i-(s.width??0));break;default:s.x=n+this.padding}e+=s.height??0,t<this.children.length-1&&(e+=this.spacing)}this.autoSize&&(this.height=e+this.padding,this.width=i+2*this.padding),super.update(t)}}class TileLayout extends LayoutScene{constructor(t,e={}){super(t,e),this.columns=e.columns??4}update(t){if(!this.children.length)return void super.update(t);const e=this.children[0].width||0;let i=this.padding,s=this.padding,n=0;for(let t=0;t<this.children.length;t++){const o=this.children[t];o.x=this.x+i+e/2,o.y=this.y+s+e/2,n++,n<this.columns?i+=e+this.spacing:(n=0,i=this.padding,s+=e+this.spacing)}if(this.autoSize){const t=Math.ceil(this.children.length/this.columns);this.width=this.columns*e+(this.columns-1)*this.spacing+2*this.padding,this.height=t*e+(t-1)*this.spacing+2*this.padding}super.update(t)}}function applyDraggable(t,e,i={}){const s=t.game;t.dragging=!1,t.dragOffset={x:0,y:0},t.target={x:e.x,y:e.y},t.friction=i.friction??.2,t.enableInteractivity(e),t.on("inputdown",(s=>{t.dragging=!0,t.dragOffset.x=e.x-s.x,t.dragOffset.y=e.y-s.y,i.onDragStart&&i.onDragStart()})),s.events.on("inputmove",(e=>{t.dragging&&(t.target.x=e.x+t.dragOffset.x,t.target.y=e.y+t.dragOffset.y)})),s.events.on("inputup",(()=>{t.dragging&&(t.dragging=!1,i.onDragEnd&&i.onDragEnd())}));const n=t.update.bind(t);t.update=function(i){t.x+=(t.target.x-e.x)*t.friction,t.y+=(t.target.y-e.y)*t.friction,n(i)}}export{Arc,Arrow,BezierShape,Button,Circle,Cloud,Cone,Cross,Cube,Cursor,Cylinder,DebugTab,Diamond,Easing,EventEmitter,FPSCounter,Game,GameObject,Group,Heart,Hexagon,HorizontalLayout,Input,Keys,LayoutScene,Line,Loggable,Logger,Motion,Mouse,OutlinedText,Painter,PatternRectangle,PieSlice,Pin,Pipeline,Polygon,Prism,Rectangle,Renderable,Ring,RoundedRectangle,SVGPath as SVGShape,Scene,Shape,ShapeGOFactory,index as Shapes,Sphere,Square,Star,StickFigure,Text,TextShape,TileLayout,ToggleButton,Touch,Transformable,Triangle,Tween,Tweenetik,VerticalLayout,WrappedText,applyAnchor,applyDraggable};