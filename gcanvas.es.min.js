var __defProp=Object.defineProperty,__defNormalProp=(t,e,i)=>e in t?__defProp(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i,__publicField=(t,e,i)=>__defNormalProp(t,"symbol"!=typeof e?e+"":e,i);class Painter{static init(t){Painter.ctx=t}static save(){Painter.ctx.save()}static restore(){Painter.ctx.restore()}static clear(t=0,e=0,i=Painter.ctx.canvas.width,s=Painter.ctx.canvas.height){Painter.ctx.clearRect(t,e,i,s)}static translate(t,e){Painter.ctx.translate(t,e)}static rotate(t){Painter.ctx.rotate(t)}static scale(t,e){Painter.ctx.scale(t,e)}static fillRect(t,e,i,s,n){n&&(Painter.ctx.fillStyle=n),Painter.ctx.fillRect(t,e,i,s)}static strokeRect(t,e,i,s,n,o){n&&(Painter.ctx.strokeStyle=n),void 0!==o&&(Painter.ctx.lineWidth=o),Painter.ctx.strokeRect(t,e,i,s)}static roundRect(t,e,i,s,n=0,o,r,a){let h;h="number"==typeof n?[n,n,n,n]:Array.isArray(n)?4===n.length?n:[n[0]||0,n[1]||n[0]||0,n[2]||n[0]||0,n[3]||n[1]||n[0]||0]:[0,0,0,0];const[l,c,u,d]=h,p=t+i,g=e+s;Painter.ctx.beginPath(),Painter.ctx.moveTo(t+l,e),Painter.ctx.lineTo(p-c,e),Painter.ctx.arc(p-c,e+c,c,-Math.PI/2,0),Painter.ctx.lineTo(p,g-u),Painter.ctx.arc(p-u,g-u,u,0,Math.PI/2),Painter.ctx.lineTo(t+d,g),Painter.ctx.arc(t+d,g-d,d,Math.PI/2,Math.PI),Painter.ctx.lineTo(t,e+l),Painter.ctx.arc(t+l,e+l,l,Math.PI,-Math.PI/2),Painter.ctx.closePath(),o&&(Painter.ctx.fillStyle=o,Painter.ctx.fill()),r&&(Painter.ctx.strokeStyle=r,void 0!==a&&(Painter.ctx.lineWidth=a),Painter.ctx.stroke())}static fillRoundRect(t,e,i,s,n=0,o){o&&(Painter.ctx.fillStyle=o),Painter.roundRect(t,e,i,s,n,o,null)}static strokeRoundRect(t,e,i,s,n=0,o,r){o&&(Painter.ctx.strokeStyle=o),void 0!==r&&(Painter.ctx.lineWidth=r),Painter.roundRect(t,e,i,s,n,null,o,r)}static fillCircle(t,e,i,s){Painter.ctx.beginPath(),Painter.ctx.arc(t,e,i,0,2*Math.PI),s&&(Painter.ctx.fillStyle=s),Painter.ctx.fill()}static strokeCircle(t,e,i,s,n){Painter.ctx.beginPath(),Painter.ctx.arc(t,e,i,0,2*Math.PI),s&&(Painter.ctx.strokeStyle=s),void 0!==n&&(Painter.ctx.lineWidth=n),Painter.ctx.stroke()}static fillEllipse(t,e,i,s,n=0,o){Painter.ctx.beginPath(),Painter.ctx.ellipse(t,e,i,s,n,0,2*Math.PI),o&&(Painter.ctx.fillStyle=o),Painter.ctx.fill()}static path(t,e,i,s=1){const n=Painter.ctx;n.beginPath();for(const e of t){const[t,...i]=e;"M"===t?n.moveTo(...i):"L"===t?n.lineTo(...i):"C"===t?n.bezierCurveTo(...i):"Q"===t?n.quadraticCurveTo(...i):"Z"===t&&n.closePath()}e&&(n.fillStyle=e,n.fill()),i&&(n.strokeStyle=i,n.lineWidth=s,n.stroke())}static strokeEllipse(t,e,i,s,n=0,o,r){Painter.ctx.beginPath(),Painter.ctx.ellipse(t,e,i,s,n,0,2*Math.PI),o&&(Painter.ctx.strokeStyle=o),void 0!==r&&(Painter.ctx.lineWidth=r),Painter.ctx.stroke()}static line(t,e,i,s,n,o){Painter.ctx.beginPath(),Painter.ctx.moveTo(t,e),Painter.ctx.lineTo(i,s),n&&(Painter.ctx.strokeStyle=n),void 0!==o&&(Painter.ctx.lineWidth=o),Painter.ctx.stroke()}static beginPath(){Painter.ctx.beginPath()}static moveTo(t,e){Painter.ctx.moveTo(t,e)}static lineTo(t,e){Painter.ctx.lineTo(t,e)}static bezierCurveTo(t,e,i,s,n,o){Painter.ctx.bezierCurveTo(t,e,i,s,n,o)}static closePath(){Painter.ctx.closePath()}static fill(t){t&&(Painter.ctx.fillStyle=t),Painter.ctx.fill()}static strokeOptions(t){t.color&&(Painter.ctx.strokeStyle=t.color),void 0!==t.lineWidth&&(Painter.ctx.lineWidth=t.lineWidth),t.lineCap&&(Painter.ctx.lineCap=t.lineCap),t.lineJoin&&(Painter.ctx.lineJoin=t.lineJoin),t.strokeStyle&&(Painter.ctx.strokeStyle=t.strokeStyle)}static stroke(t,e){t&&(Painter.ctx.strokeStyle=t),void 0!==e&&(Painter.ctx.lineWidth=e),Painter.ctx.stroke()}static polygon(t,e,i,s){if(!(t.length<2)){Painter.ctx.beginPath(),Painter.ctx.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++)Painter.ctx.lineTo(t[e].x,t[e].y);Painter.ctx.closePath(),e&&(Painter.ctx.fillStyle=e,Painter.ctx.fill()),i&&(Painter.ctx.strokeStyle=i,void 0!==s&&(Painter.ctx.lineWidth=s),Painter.ctx.stroke())}}static heart(t,e,i,s,n="#FF0055"){const o=i/2;Painter.ctx.save(),Painter.ctx.translate(t,e),Painter.ctx.beginPath(),Painter.ctx.moveTo(0,.3*s),Painter.ctx.bezierCurveTo(.5*-o,.3*-s,-o,.6*-s,0,-s),Painter.ctx.bezierCurveTo(o,.6*-s,.5*o,.3*-s,0,.3*s),Painter.ctx.closePath(),Painter.ctx.fillStyle=n,Painter.ctx.fill(),Painter.ctx.restore()}static setFont(t){Painter.ctx.font=t}static setTextAlign(t){Painter.ctx.textAlign=t}static setTextBaseline(t){Painter.ctx.textBaseline=t}static fillText(t,e,i,s,n){s&&(Painter.ctx.fillStyle=s),n&&(Painter.ctx.font=n),Painter.ctx.fillText(t,e,i)}static strokeText(t,e,i,s,n,o){s&&(Painter.ctx.strokeStyle=s),void 0!==n&&(Painter.ctx.lineWidth=n),o&&(Painter.ctx.font=o),Painter.ctx.strokeText(t,e,i)}static measureText(t){return Painter.ctx.measureText(t).width}static setFillColor(t){Painter.ctx.fillStyle=t}static setStrokeColor(t){Painter.ctx.strokeStyle=t}static setLineWidth(t){Painter.ctx.lineWidth=t}static rgba(t,e,i,s=1){return`rgba(${Math.round(t)}, ${Math.round(e)}, ${Math.round(i)}, ${s})`}static hsl(t,e,i){return`hsl(${t}, ${e}%, ${i}%)`}static hsla(t,e,i,s){return`hsla(${t}, ${e}%, ${i}%, ${s})`}static randomColorRGB(){const t=Math.floor(360*Math.random()),e=70+Math.floor(30*Math.random()),i=50+Math.floor(20*Math.random());return Painter.hslToRgb(t,e,i)}static randomColorHSL(){return`hsl(${360*Math.random()}, 100%, 50%)`}static randomColorHEX(){return"#"+(1048575*Math.random()*1e6).toString(16).slice(0,6)}static parseColorString(t){if((t=t.trim().toLowerCase()).startsWith("hsl")){const e=t.replace(/hsla?\(|\)/g,""),[i,s,n]=e.split(",").map((t=>t.trim())),o=parseFloat(i),r=parseFloat(s)/100,a=parseFloat(n)/100;return Painter.hslToRgb(o,r,a)}if(t.startsWith("#"))return hexToRgb(t);if(t.startsWith("rgb")){const e=t.replace(/rgba?\(|\)/g,""),[i,s,n]=e.split(",").map((t=>parseInt(t.trim())));return[i,s,n]}return[0,0,0]}static rgbArrayToCSS([t,e,i]){return`rgb(${Math.round(t)}, ${Math.round(e)}, ${Math.round(i)})`}static hslToRgb(t,e,i){const s=(1-Math.abs(2*i-1))*e,n=t/60,o=s*(1-Math.abs(n%2-1));let[r,a,h]=[0,0,0];n>=0&&n<1?[r,a,h]=[s,o,0]:n>=1&&n<2?[r,a,h]=[o,s,0]:n>=2&&n<3?[r,a,h]=[0,s,o]:n>=3&&n<4?[r,a,h]=[0,o,s]:n>=4&&n<5?[r,a,h]=[o,0,s]:n>=5&&n<6&&([r,a,h]=[s,0,o]);const l=i-s/2;return[255*(r+l),255*(a+l),255*(h+l)]}static rgbToHsl(t,e,i){t/=255,e/=255,i/=255;const s=Math.max(t,e,i),n=Math.min(t,e,i),o=s-n;let r=0,a=0,h=(s+n)/2;if(0!==o)switch(a=o/(1-Math.abs(2*h-1)),s){case t:r=((e-i)/o+6)%6*60;break;case e:r=60*((i-t)/o+2);break;case i:r=60*((t-e)/o+4)}return[r%360,a,h]}static hexToRgb(t){const e=t.replace("#","");return[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}static linearGradient(t,e,i,s,n){const o=Painter.ctx.createLinearGradient(t,e,i,s);for(const t of n)o.addColorStop(t.offset,t.color);return o}static radialGradient(t,e,i,s,n,o,r){const a=Painter.ctx.createRadialGradient(t,e,i,s,n,o);for(const t of r)a.addColorStop(t.offset,t.color);return a}static verticalGradient(t,e,i,s,n){return Painter.linearGradient(t,e,t,e+s,n)}static horizontalGradient(t,e,i,s,n){return Painter.linearGradient(t,e,t+i,e,n)}static conicGradient(t,e,i,s){if("function"==typeof Painter.ctx.createConicGradient){const n=Painter.ctx.createConicGradient(i,t,e);for(const t of s)n.addColorStop(t.offset,t.color);return n}return null}static dropShadow(t,e,i=0,s=0){Painter.ctx.shadowColor=t,Painter.ctx.shadowBlur=e,Painter.ctx.shadowOffsetX=i,Painter.ctx.shadowOffsetY=s}static clearShadow(){Painter.ctx.shadowColor="rgba(0, 0, 0, 0)",Painter.ctx.shadowBlur=0,Painter.ctx.shadowOffsetX=0,Painter.ctx.shadowOffsetY=0}static setAlpha(t){Painter.ctx.globalAlpha=t}static setBlendMode(t){Painter.ctx.globalCompositeOperation=t}static dashedLine(t,e,i,s,n,o,r){Painter.ctx.beginPath(),o&&(Painter.ctx.strokeStyle=o),void 0!==r&&(Painter.ctx.lineWidth=r),Painter.ctx.setLineDash(n),Painter.ctx.moveTo(t,e),Painter.ctx.lineTo(i,s),Painter.ctx.stroke(),Painter.ctx.setLineDash([])}static dottedLine(t,e,i,s,n=2,o=5,r){return Painter.dashedLine(t,e,i,s,[n,o],r,n)}static quadraticCurve(t,e,i,s,n,o,r,a){Painter.ctx.beginPath(),Painter.ctx.moveTo(t,e),Painter.ctx.quadraticCurveTo(i,s,n,o),r&&(Painter.ctx.strokeStyle=r),void 0!==a&&(Painter.ctx.lineWidth=a),Painter.ctx.stroke()}static fillPattern(t,e,i,s,n,o){const r=Painter.ctx.createPattern(t,e);Painter.ctx.fillStyle=r,Painter.ctx.fillRect(i,s,n,o)}static outlinedText(t,e,i,s,n,o,r){r&&(Painter.ctx.font=r),Painter.ctx.strokeStyle=n,Painter.ctx.lineWidth=o,Painter.ctx.strokeText(t,e,i),Painter.ctx.fillStyle=s,Painter.ctx.fillText(t,e,i)}static wrappedText(t,e,i,s,n,o,r){o&&(Painter.ctx.fillStyle=o),r&&(Painter.ctx.font=r);const a=t.split(" ");let h="",l="",c=1;for(let t=0;t<a.length;t++){l=h+a[t]+" ";Painter.ctx.measureText(l).width>s&&t>0?(Painter.ctx.fillText(h,e,i),h=a[t]+" ",i+=n,c++):h=l}return Painter.ctx.fillText(h,e,i),c*n}static setLineDash(t){Painter.ctx.setLineDash(t)}static resetLineDash(){Painter.ctx.setLineDash([])}static clipRect(t,e,i,s){Painter.ctx.beginPath(),Painter.ctx.rect(t,e,i,s),Painter.ctx.clip()}static clipCircle(t,e,i){Painter.ctx.beginPath(),Painter.ctx.arc(t,e,i,0,2*Math.PI),Painter.ctx.clip()}static blurRegion(t,e,i,s,n){const o=Painter.ctx.filter;Painter.ctx.filter=`blur(${n}px)`;const r=Painter.ctx.getImageData(t,e,i,s);Painter.ctx.putImageData(r,t,e),Painter.ctx.filter=o}static textOnPath(t,e,i,s,n=!1){if(e.length<2)return;i&&(Painter.ctx.fillStyle=i),s&&(Painter.ctx.font=s);const o=t.split(""),r=o.map((t=>Painter.ctx.measureText(t).width));n&&(o.reverse(),r.reverse(),e.reverse());let a=0;for(let t=1;t<e.length;t++){const i=e[t].x-e[t-1].x,s=e[t].y-e[t-1].y;a+=Math.sqrt(i*i+s*s)}let h=(a-r.reduce(((t,e)=>t+e),0))/2;h<0&&(h=0);let l=h;for(let t=0;t<o.length;t++){const i=r[t],{x:s,y:n,angle:a}=getPositionOnPath(e,l);Painter.ctx.save(),Painter.ctx.translate(s,n),Painter.ctx.rotate(a),Painter.ctx.fillText(o[t],0,0),Painter.ctx.restore(),l+=i}}static getPositionOnPath(t,e){let i=0;for(let s=1;s<t.length;s++){const n=t[s-1],o=t[s],r=o.x-n.x,a=o.y-n.y,h=Math.sqrt(r*r+a*a);if(i+h>=e){const t=(e-i)/h;return{x:n.x+r*t,y:n.y+a*t,angle:Math.atan2(a,r)}}i+=h}const s=t[t.length-1],n=t[t.length-2],o=Math.atan2(s.y-n.y,s.x-n.x);return{x:s.x,y:s.y,angle:o}}static createPattern(t,e="repeat"){return Painter.ctx.createPattern(t,e)}}const _Mouse=class t{static init(e){t.game=e,t.canvas=e.canvas,t.x=0,t.y=0,t.leftDown=!1,t.middleDown=!1,t.rightDown=!1,t.canvas.addEventListener("mousemove",t._onMove),t.canvas.addEventListener("mousedown",t._onDown),t.canvas.addEventListener("mouseup",t._onUp),t.canvas.addEventListener("click",t._onClick),t.canvas.addEventListener("wheel",t._onWheel)}static _updatePosition(e){const i=t.canvas.getBoundingClientRect();t.x=e.clientX-i.left,t.y=e.clientY-i.top}};__publicField(_Mouse,"_onMove",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("mousemove",t)})),__publicField(_Mouse,"_onDown",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!0),1===t.button&&(_Mouse.middleDown=!0),2===t.button&&(_Mouse.rightDown=!0),_Mouse.game.events.emit("mousedown",t)})),__publicField(_Mouse,"_onUp",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!1),1===t.button&&(_Mouse.middleDown=!1),2===t.button&&(_Mouse.rightDown=!1),_Mouse.game.events.emit("mouseup",t)})),__publicField(_Mouse,"_onClick",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("click",t)})),__publicField(_Mouse,"_onWheel",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("wheel",t)}));let Mouse=_Mouse;const _Keys=class t{static init(e){t.game=e,window.addEventListener("keydown",t._onKeyDown),window.addEventListener("keyup",t._onKeyUp)}static isDown(e){return t._down.has(e)}static _onKeyDown(e){const i=t._codeMap[e.code];i&&(t._down.has(i)||(t._down.add(i),t.game.events.emit(i,e))),t.game.events.emit(e.type,e)}static _onKeyUp(e){const i=t._codeMap[e.code];i&&t._down.has(i)&&(t._down.delete(i),t.game.events.emit(i+"_up",e)),t.game.events.emit(e.type,e)}};__publicField(_Keys,"W","W"),__publicField(_Keys,"A","A"),__publicField(_Keys,"S","S"),__publicField(_Keys,"D","D"),__publicField(_Keys,"UP","UP"),__publicField(_Keys,"DOWN","DOWN"),__publicField(_Keys,"LEFT","LEFT"),__publicField(_Keys,"RIGHT","RIGHT"),__publicField(_Keys,"SPACE","SPACE"),__publicField(_Keys,"SHIFT","SHIFT"),__publicField(_Keys,"ENTER","ENTER"),__publicField(_Keys,"ESC","ESC"),__publicField(_Keys,"_codeMap",{KeyW:_Keys.W,KeyA:_Keys.A,KeyS:_Keys.S,KeyD:_Keys.D,ArrowUp:_Keys.UP,ArrowDown:_Keys.DOWN,ArrowLeft:_Keys.LEFT,ArrowRight:_Keys.RIGHT,Space:_Keys.SPACE,ShiftLeft:_Keys.SHIFT,ShiftRight:_Keys.SHIFT,Enter:_Keys.ENTER,NumpadEnter:_Keys.ENTER,Escape:_Keys.ESC}),__publicField(_Keys,"_down",new Set),__publicField(_Keys,"game",null);let Keys=_Keys;const _Touch=class t{static init(e){t.game=e,t.canvas=e.canvas,t.x=0,t.y=0,t.active=!1,t.canvas.addEventListener("touchstart",t._onStart),t.canvas.addEventListener("touchend",t._onEnd),t.canvas.addEventListener("touchmove",t._onMove)}static _updatePosition(e){const i=t.canvas.getBoundingClientRect();t.x=e.clientX-i.left,t.y=e.clientY-i.top}};__publicField(_Touch,"_onStart",(t=>{t.touches.length>0&&(_Touch.active=!0,_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchstart",t))})),__publicField(_Touch,"_onEnd",(t=>{_Touch.active=!1,_Touch.game.events.emit("touchend",t)})),__publicField(_Touch,"_onMove",(t=>{t.touches.length>0&&(_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchmove",t))}));let Touch=_Touch;const _Input=class t{static init(e){t.game=e,t.x=0,t.y=0,t.down=!1,e.events.on("mousedown",t._onDown),e.events.on("mouseup",t._onUp),e.events.on("mousemove",t._onMove),e.events.on("touchstart",t._onTouchStart),e.events.on("touchend",t._onTouchEnd),e.events.on("touchmove",t._onTouchMove)}static _setPosition(e,i){t.x=e,t.y=i}};__publicField(_Input,"_onDown",(t=>{_Input.down=!0,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onUp",(t=>{_Input.down=!1,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onMove",(t=>{_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputmove",t)})),__publicField(_Input,"_onTouchStart",(t=>{const e=t.touches[0],i=_Input.game.canvas.getBoundingClientRect();_Input.down=!0,_Input._setPosition(e.clientX-i.left,e.clientY-i.top),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onTouchEnd",(t=>{_Input.down=!1,_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onTouchMove",(t=>{const e=t.touches[0],i=_Input.game.canvas.getBoundingClientRect();_Input._setPosition(e.clientX-i.left,e.clientY-i.top),_Input.game.events.emit("inputmove",t)}));let Input=_Input;class EventEmitter{constructor(){this.listeners={}}on(t,e){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e)}off(t,e){this.listeners[t]&&(this.listeners[t]=this.listeners[t].filter((t=>t!==e)))}emit(t,e){this.listeners[t]&&this.listeners[t].forEach((t=>t(e)))}}function applyAnchor(t,e={}){var i;t.anchor=e.anchor??null,t.padding=e.padding??10;const s=t.game,n=null==(i=t.update)?void 0:i.bind(t);t.update=function(e){if(t.anchor){const{x:e,y:i,align:n,baseline:o}=((e,i)=>{const n=s.width,o=s.height;switch(e){case"top-left":return{x:i,y:i,align:"left",baseline:"top"};case"top-center":return{x:(n-t.width)/2,y:i,align:"center",baseline:"top"};case"top-right":return{x:n-t.width-i,y:i,align:"right",baseline:"top"};case"center-left":return{x:i,y:(o-t.height)/2,align:"left",baseline:"middle"};case"center":return{x:(n-t.width)/2,y:(o-t.height)/2,align:"center",baseline:"middle"};case"center-right":return{x:n-t.width-i,y:o/2,align:"right",baseline:"middle"};case"bottom-left":return{x:i,y:o-i,align:"left",baseline:"bottom"};case"bottom-center":return{x:(n-t.width)/2,y:o-t.height-i,align:"center",baseline:"bottom"};case"bottom-right":return{x:n-i,y:o-i,align:"right",baseline:"bottom"};default:return{x:10,y:10,align:"left",baseline:"top"}}})(t.anchor,t.padding);t.x=e,t.y=i,"align"in t&&(t.align=n),"baseline"in t&&(t.baseline=o)}null==n||n(e)}}class Transformable{constructor(t={}){this.options=t,this.x=t.x??0,this.y=t.y??0,this.width=t.width??0,this.height=t.height??0,this.rotation=t.rotation??0,this.scaleX=t.scaleX??1,this.scaleY=t.scaleY??1,this.offsetX=t.offsetX??1,this.offsetY=t.offsetY??1,this.opacity=t.opacity??1,this.visible=void 0===t.visible||t.visible}}class Shape extends Transformable{constructor(t,e,i={}){super(i),this.crisp=i.crisp??!0,this.x=t,this.y=e,this.fillColor=i.fillColor||null,this.strokeColor=i.strokeColor||null,this.lineWidth=i.lineWidth||1,this.shadowColor=i.shadowColor??null,this.shadowBlur=i.shadowBlur??0,this.shadowOffsetX=i.shadowOffsetX??0,this.shadowOffsetY=i.shadowOffsetY??0,this.minX=i.minX,this.maxX=i.maxX,this.minY=i.minY,this.maxY=i.maxY,this.rotation=i.rotation??0,this.scaleX=i.scaleX??1,this.scaleY=i.scaleY??1}applyConstraints(){void 0!==this.minX&&(this.x=Math.max(this.x,this.minX)),void 0!==this.maxX&&(this.x=Math.min(this.x,this.maxX)),void 0!==this.minY&&(this.y=Math.max(this.y,this.minY)),void 0!==this.maxY&&(this.y=Math.min(this.y,this.maxY)),this.crisp&&(this.x=Math.round(this.x),this.y=Math.round(this.y),this.width=Math.round(this.width),this.height=Math.round(this.height))}draw(){this.applyConstraints()}renderWithTransform(t){this.visible&&(Painter.ctx.save(),Painter.ctx.globalAlpha=this.opacity,this.shadowColor&&Painter.dropShadow(this.shadowColor,this.shadowBlur,this.shadowOffsetX,this.shadowOffsetY),Painter.ctx.translate(this.x,this.y),Painter.ctx.rotate(this.rotation),Painter.ctx.scale(this.scaleX,this.scaleY),t(),Painter.clearShadow(),Painter.ctx.restore())}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class Arc extends Shape{constructor(t,e,i,s,n,o={}){super(t,e,o),this.radius=i,this.startAngle=s,this.endAngle=n}draw(){super.draw(),this.renderWithTransform((()=>{const t=Painter.ctx;t.beginPath(),t.arc(0,0,this.radius,this.startAngle,this.endAngle,!1),this.strokeColor&&(t.strokeStyle=this.strokeColor,t.lineWidth=this.lineWidth,t.stroke())}))}getBounds(){const t=this.radius;return{x:this.x,y:this.y,width:2*t,height:2*t}}}class Circle extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.radius=i}draw(){super.draw(),this.renderWithTransform((()=>{this.fillColor&&Painter.fillCircle(0,0,this.radius,this.fillColor),this.strokeColor&&Painter.strokeCircle(0,0,this.radius,this.strokeColor,this.lineWidth)}))}getBounds(){const t=2*this.radius;return{x:this.x,y:this.y,width:t,height:t}}}class Cloud extends Shape{constructor(t,e,i=40,s={}){super(t,e,s),this.size=i}draw(){super.draw();const t=this.size,e=[["M",-t,0],["C",-t,-t,0,-t,0,0],["C",0,1.2*-t,1.2*t,-t,t,0],["C",1.5*t,.5*t,.5*t,1.2*t,0,t],["C",.8*-t,1.3*t,1.2*-t,.3*t,-t,0],["Z"]];this.renderWithTransform((()=>{Painter.path(e,this.fillColor,this.strokeColor,this.lineWidth)}))}getBounds(){const t=2*this.size;return{x:this.x,y:this.y,width:t,height:t}}}class BezierShape extends Shape{constructor(t,e,i=[],s={}){console.log("new Bezier",s),super(t,e,s),this.path=i}draw(){super.draw(),this.renderWithTransform((()=>{Painter.path(this.path,this.fillColor,this.strokeColor,this.lineWidth)}))}getBounds(){return{x:this.x,y:this.y,width:100,height:100}}}class Rectangle extends Shape{constructor(t,e,i,s,n={}){super(t,e,n),this.width=i,this.height=s}draw(){super.draw(),this.renderWithTransform((()=>{const t=-this.width/2,e=-this.height/2;this.fillColor&&Painter.fillRect(t,e,this.width,this.height,this.fillColor),this.strokeColor&&Painter.strokeRect(t,e,this.width,this.height,this.strokeColor,this.lineWidth)}))}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class RoundedRectangle extends Shape{constructor(t,e,i,s,n=0,o={}){super(t,e,o),this.width=i,this.height=s,"number"==typeof n?this.radii=[n,n,n,n]:Array.isArray(n)?this.radii=4===n.length?n:[n[0]||0,n[1]||n[0]||0,n[2]||n[0]||0,n[3]||n[1]||n[0]||0]:this.radii=[0,0,0,0]}draw(){super.draw(),this.renderWithTransform((()=>{const t=-this.width/2,e=-this.height/2;this.fillColor&&this.strokeColor?Painter.roundRect(t,e,this.width,this.height,this.radii,this.fillColor,this.strokeColor,this.lineWidth):this.fillColor?Painter.fillRoundRect(t,e,this.width,this.height,this.radii,this.fillColor):this.strokeColor&&Painter.strokeRoundRect(t,e,this.width,this.height,this.radii,this.strokeColor,this.lineWidth)}))}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class PatternRectangle extends Shape{constructor(t,e,i,s,n,o="repeat",r={}){super(t,e,r),this.width=i,this.height=s,this.image=n,this.repetition=o,this.pattern=null,n.complete?this.createPattern():n.addEventListener("load",(()=>this.createPattern()))}createPattern(){this.pattern=Painter.ctx.createPattern(this.image,this.repetition)}draw(){super.draw(),!this.pattern&&this.image.complete&&this.createPattern(),this.renderWithTransform((()=>{const t=-this.width/2,e=-this.height/2;this.pattern?Painter.fillPattern(this.image,this.repetition,t,e,this.width,this.height):this.strokeColor&&Painter.strokeRect(t,e,this.width,this.height,this.strokeColor,this.lineWidth)}))}setImage(t,e){this.image=t,e&&(this.repetition=e),this.pattern=null,t.complete?this.createPattern():t.addEventListener("load",(()=>this.createPattern()))}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class Square extends Rectangle{constructor(t,e,i,s={}){super(t,e,i,i,s)}}class Cube extends Shape{constructor(t,e,i=50,s={}){super(t,e,s),this.size=i,this.faceTopColor=s.faceTopColor||"#eee",this.faceBottomColor=s.faceBottomColor||"#ccc",this.faceLeftColor=s.faceLeftColor||"#aaa",this.faceRightColor=s.faceRightColor||"#888",this.faceFrontColor=s.faceFrontColor||"#666",this.faceBackColor=s.faceBackColor||"#444",this.strokeColor=s.strokeColor||null,this.lineWidth=s.lineWidth||1,this.rotationX=s.rotationX||0,this.rotationY=s.rotationY||0,this.rotationZ=s.rotationZ||0,this.visibleFaces=s.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.size/2,e=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let o=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=o*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-o*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),o=t,s=e,{x:t=o*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=o*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},i=(t,i,s)=>{const n=e(t,i,s);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z}},s={p0:i(-t,-t,-t),p1:i(t,-t,-t),p2:i(t,t,-t),p3:i(-t,t,-t),p4:i(-t,-t,t),p5:i(t,-t,t),p6:i(t,t,t),p7:i(-t,t,t)},n={top:{points:[s.p4,s.p5,s.p6,s.p7],color:this.faceTopColor,normal:[0,0,1]},bottom:{points:[s.p0,s.p1,s.p2,s.p3],color:this.faceBottomColor,normal:[0,0,-1]},left:{points:[s.p0,s.p4,s.p7,s.p3],color:this.faceLeftColor,normal:[-1,0,0]},right:{points:[s.p1,s.p5,s.p6,s.p2],color:this.faceRightColor,normal:[1,0,0]},front:{points:[s.p0,s.p1,s.p5,s.p4],color:this.faceFrontColor,normal:[0,-1,0]},back:{points:[s.p3,s.p2,s.p6,s.p7],color:this.faceBackColor,normal:[0,1,0]}},o=this.visibleFaces.map((t=>{const e=n[t];if(!e)return null;const i=e.points.reduce(((t,e)=>({x:t.x+e.x,y:t.y+e.y})),{x:0,y:0});i.x/=e.points.length,i.y/=e.points.length;return{key:t,face:e,depth:i.x*i.x+i.y*i.y}})).filter((t=>null!==t)).sort(((t,e)=>e.depth-t.depth));this.renderWithTransform((()=>{o.forEach((({key:t,face:e})=>{(null==e?void 0:e.color)&&Painter.polygon(e.points,e.color,this.strokeColor,this.lineWidth)}))}))}getBounds(){const t=1.5*this.size;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cone extends Shape{constructor(t,e,i=50,s=100,n={}){super(t,e,n),this.radius=i,this.height=s,this.segments=n.segments||24,this.bottomColor=n.bottomColor||"#eee",this.sideColor=n.sideColor||"#aaa",this.strokeColor=n.strokeColor||null,this.lineWidth=n.lineWidth||1,this.rotationX=n.rotationX||0,this.rotationY=n.rotationY||0,this.rotationZ=n.rotationZ||0,this.visibleFaces=n.visibleFaces||["bottom","side"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.radius,e=this.height/2,i=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let o=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=o*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-o*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),o=t,s=e,{x:t=o*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=o*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},s=(t,e,s)=>{const n=i(t,e,s);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z}},n=s(0,0,e),o=[],r=2*Math.PI/this.segments;for(let i=0;i<this.segments;i++){const n=i*r,a=Math.cos(n)*t,h=Math.sin(n)*t;o.push(s(a,h,-e))}const a=[];for(let t=0;t<this.segments;t++){const e=(t+1)%this.segments;a.push({points:[n,o[t],o[e]],z:(n.z+o[t].z+o[e].z)/3})}const h=[];this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...o].reverse(),z:-e}),this.visibleFaces.includes("side")&&h.push(...a.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,e)=>e.z-t.z)),this.renderWithTransform((()=>{for(const t of h){const e="bottom"===t.type?this.bottomColor:this.sideColor;Painter.polygon(t.points,e,this.strokeColor,this.lineWidth)}}))}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Prism extends Shape{constructor(t,e,i=80,s=60,n=100,o={}){super(t,e,o),this.width=i,this.height=s,this.depth=n,this.faceTopColor=o.faceTopColor||"#eee",this.faceBottomColor=o.faceBottomColor||"#ccc",this.faceLeftColor=o.faceLeftColor||"#aaa",this.faceRightColor=o.faceRightColor||"#888",this.faceFrontColor=o.faceFrontColor||"#666",this.faceBackColor=o.faceBackColor||"#444",this.strokeColor=o.strokeColor||null,this.lineWidth=o.lineWidth||1,this.rotationX=o.rotationX||0,this.rotationY=o.rotationY||0,this.rotationZ=o.rotationZ||0,this.visibleFaces=o.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.width/2,e=this.height/2,i=this.depth/2,s=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let o=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=o*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-o*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),o=t,s=e,{x:t=o*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=o*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},n=(t,e,i)=>{const n=s(t,e,i);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z}},o={p0:n(-t,-i,-e),p1:n(t,-i,-e),p2:n(0,-i,e),p3:n(-t,i,-e),p4:n(t,i,-e),p5:n(0,i,e)},r={front:{points:[o.p0,o.p1,o.p2],color:this.faceFrontColor},back:{points:[o.p3,o.p4,o.p5],color:this.faceBackColor},bottom:{points:[o.p0,o.p1,o.p4,o.p3],color:this.faceBottomColor},right:{points:[o.p1,o.p2,o.p5,o.p4],color:this.faceRightColor},left:{points:[o.p0,o.p2,o.p5,o.p3],color:this.faceLeftColor}},a=this.visibleFaces.filter((t=>r[t])).map((t=>{const e=r[t],i=e.points.reduce(((t,e)=>t+e.x),0)/e.points.length,s=e.points.reduce(((t,e)=>t+e.y),0)/e.points.length,n=e.points.reduce(((t,e)=>t+(e.z||0)),0)/e.points.length;return{key:t,face:e,depth:i*i+s*s+n*n}})).sort(((t,e)=>e.depth-t.depth));this.renderWithTransform((()=>{a.forEach((({key:t,face:e})=>{(null==e?void 0:e.color)&&Painter.polygon(e.points,e.color,this.strokeColor,this.lineWidth)}))}))}getBounds(){const t=1.5*Math.max(this.width,this.height,this.depth);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cylinder extends Shape{constructor(t,e,i=40,s=80,n={}){super(t,e,n),this.radius=i,this.height=s,this.segments=n.segments||24,this.topColor=n.topColor||"#FF00FF",this.bottomColor=n.bottomColor||"#FF0FFF",this.sideColor=n.sideColor||"#00FF00",this.strokeColor=n.strokeColor||"#000000",this.lineWidth=n.lineWidth||1,this.rotationX=n.rotationX||0,this.rotationY=n.rotationY||0,this.rotationZ=n.rotationZ||0,this.visibleFaces=n.visibleFaces||["top","bottom","side"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.radius,e=this.height/2,i=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let o=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=o*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-o*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),o=t,s=e,{x:t=o*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=o*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},s=(t,e,s)=>{const n=i(t,e,s);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z}},n=[],o=[],r=2*Math.PI/this.segments;for(let i=0;i<this.segments;i++){const a=i*r,h=Math.cos(a)*t,l=Math.sin(a)*t;n.push(s(h,l,e)),o.push(s(h,l,-e))}const a=[];for(let t=0;t<this.segments;t++){const e=(t+1)%this.segments;a.push({points:[o[t],o[e],n[e],n[t]],z:(n[t].z+n[e].z+o[t].z+o[e].z)/4})}const h=[];this.visibleFaces.includes("top")&&h.push({type:"top",points:n,z:e}),this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...o].reverse(),z:-e}),this.visibleFaces.includes("side")&&h.push(...a.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,e)=>e.z-t.z)),this.renderWithTransform((()=>{for(const t of h){let e;switch(t.type){case"top":e=this.topColor;break;case"bottom":e=this.bottomColor;break;case"side":e=this.sideColor}Painter.polygon(t.points,e,this.strokeColor,this.lineWidth)}}))}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Diamond extends Shape{constructor(t,e,i,s,n={}){super(t,e,n),this.width=i,this.height=s}draw(){super.draw(),this.renderWithTransform((()=>{const t=this.width/2,e=this.height/2,i=[{x:0,y:-e},{x:t,y:0},{x:0,y:e},{x:-t,y:0}];Painter.polygon(i,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Line extends Shape{constructor(t,e,i=40,s={}){super(t,e,s),this.length=i}draw(){super.draw();const t=this.length/2;this.renderWithTransform((()=>{Painter.line(-t,-t,t,t,this.strokeColor,this.lineWidth)}))}}class Triangle extends Shape{constructor(t,e,i=50,s={}){super(t,e,s),this.size=i}draw(){super.draw();const t=this.size/2,e=[{x:0,y:-t},{x:t,y:t},{x:-t,y:t}];this.renderWithTransform((()=>{Painter.polygon(e,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Star extends Shape{constructor(t,e,i=40,s=5,n=.5,o={}){super(t,e,o),this.radius=i,this.spikes=s,this.inset=n}draw(){super.draw();const t=Math.PI/this.spikes,e=-Math.PI/2;this.renderWithTransform((()=>{Painter.ctx.beginPath();for(let i=0;i<2*this.spikes;i++){const s=i%2==0?this.radius:this.radius*this.inset,n=i*t+e,o=Math.cos(n)*s,r=Math.sin(n)*s;0===i?Painter.ctx.moveTo(o,r):Painter.ctx.lineTo(o,r)}Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Sphere extends Shape{constructor(t,e,i=50,s={}){super(t,e,s),this.radius=i,this.hSegments=s.hSegments||16,this.vSegments=s.vSegments||12,this.color=s.color||"#6495ED",this.highlightColor=s.highlightColor||"#FFFFFF",this.wireframe=s.wireframe||!1,this.strokeColor=s.strokeColor||"#333333",this.lineWidth=s.lineWidth||1,this.rotationX=s.rotationX||0,this.rotationY=s.rotationY||0,this.rotationZ=s.rotationZ||0}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}calculateSurfaceColor(t,e,i){let s=t*(1/Math.sqrt(3))+e*(1/Math.sqrt(3))+i*(1/Math.sqrt(3));if(s=Math.max(.3,s),this.highlightColor){const t=this.hexToRgb(this.color),e=this.hexToRgb(this.highlightColor);return`rgb(${Math.round(t.r*(1-s)+e.r*s)}, ${Math.round(t.g*(1-s)+e.g*s)}, ${Math.round(t.b*(1-s)+e.b*s)})`}const n=this.hexToRgb(this.color);return`rgb(${Math.min(255,Math.round(n.r*s))}, ${Math.min(255,Math.round(n.g*s))}, ${Math.min(255,Math.round(n.b*s))})`}hexToRgb(t){const e={r:100,g:100,b:255};if(!t||"string"!=typeof t)return e;const i=t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,((t,e,i,s)=>e+e+i+i+s+s)),s=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(i);return s?{r:parseInt(s[1],16),g:parseInt(s[2],16),b:parseInt(s[3],16)}:e}draw(){super.draw();const t=this.radius,e=(t,e,i)=>{let s=e,n=i;e=s*Math.cos(this.rotationX)-n*Math.sin(this.rotationX);let o=t;return n=i=s*Math.sin(this.rotationX)+n*Math.cos(this.rotationX),t=o*Math.cos(this.rotationY)+n*Math.sin(this.rotationY),i=-o*Math.sin(this.rotationY)+n*Math.cos(this.rotationY),o=t,s=e,{x:t=o*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=o*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},i=(i,s,n)=>{const o=e(i,s,n);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z,z:o.z,nx:o.x/t,ny:o.y/t,nz:o.z/t}},s=[];for(let e=0;e<=this.vSegments;e++){const n=[],o=e/this.vSegments,r=Math.PI*o-Math.PI/2;for(let e=0;e<=this.hSegments;e++){const s=e/this.hSegments,o=2*Math.PI*s,a=t*Math.cos(r)*Math.cos(o),h=t*Math.cos(r)*Math.sin(o),l=t*Math.sin(r);n.push(i(a,h,l))}s.push(n)}const n=[];for(let t=0;t<this.vSegments;t++)for(let e=0;e<this.hSegments;e++){const i=s[t][e],o=s[t][e+1],r=s[t+1][e],a=s[t+1][e+1],h=(i.z+o.z+r.z+a.z)/4,l=(i.nx+o.nx+r.nx+a.nx)/4,c=(i.ny+o.ny+r.ny+a.ny)/4,u=(i.nz+o.nz+r.nz+a.nz)/4;n.push({points:[i,o,a,r],z:h,color:this.calculateSurfaceColor(l,c,u)})}n.sort(((t,e)=>e.z-t.z)),this.renderWithTransform((()=>{if(this.wireframe)for(const t of n){const e=t.points;for(let t=0;t<e.length;t++){const i=(t+1)%e.length;Painter.line(e[t].x,e[t].y,e[i].x,e[i].y,this.strokeColor,this.lineWidth)}}else for(const t of n)Painter.polygon(t.points,t.color,this.strokeColor,this.lineWidth)}))}getBounds(){const t=2*this.radius*1.5;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class SVGPath extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.scale=s.scale||1,this.centerPath=void 0===s.centerPath||s.centerPath,this.animationProgress=void 0!==s.animationProgress?s.animationProgress:1,this.svgPathData=i,this.pathCommands=this.parseSVGPath(i),this.centerPath?this.pathCommands=this.centerAndScalePath(this.pathCommands,this.scale):this.pathCommands=this.scalePath(this.pathCommands,this.scale),this.prevX=0,this.prevY=0,this.currentPoint={x:0,y:0}}parseSVGPath(t){const e=/M\s*([-\d.]+)[,\s]*([-\d.]+)/g,i=/L\s*([-\d.]+)[,\s]*([-\d.]+)/g,s=/C\s*([-\d.]+)[,\s]*([-\d.]+)\s*([-\d.]+)[,\s]*([-\d.]+)\s*([-\d.]+)[,\s]*([-\d.]+)/g,n=[];let o;for(;null!==(o=e.exec(t));)n.push(["M",parseFloat(o[1]),parseFloat(o[2])]);for(;null!==(o=i.exec(t));){const t=parseFloat(o[1]),e=parseFloat(o[2]);let i=0,s=0;for(let t=n.length-1;t>=0;t--){const e=n[t];if("M"===e[0]){i=e[1],s=e[2];break}if("C"===e[0]){i=e[5],s=e[6];break}}const r=i+(t-i)/3,a=s+(e-s)/3,h=i+2*(t-i)/3,l=s+2*(e-s)/3;n.push(["C",r,a,h,l,t,e])}for(;null!==(o=s.exec(t));)n.push(["C",parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3]),parseFloat(o[4]),parseFloat(o[5]),parseFloat(o[6])]);return/Z/g.test(t)&&n.push(["Z"]),n}centerAndScalePath(t,e){let i=1/0,s=1/0,n=-1/0,o=-1/0;for(const e of t)"M"===e[0]?(i=Math.min(i,e[1]),s=Math.min(s,e[2]),n=Math.max(n,e[1]),o=Math.max(o,e[2])):"C"===e[0]&&(i=Math.min(i,e[1],e[3],e[5]),s=Math.min(s,e[2],e[4],e[6]),n=Math.max(n,e[1],e[3],e[5]),o=Math.max(o,e[2],e[4],e[6]));const r=(i+n)/2,a=(s+o)/2;return this.originalWidth=(n-i)*e,this.originalHeight=(o-s)*e,t.map((t=>"M"===t[0]?["M",(t[1]-r)*e,(t[2]-a)*e]:"C"===t[0]?["C",(t[1]-r)*e,(t[2]-a)*e,(t[3]-r)*e,(t[4]-a)*e,(t[5]-r)*e,(t[6]-a)*e]:[...t]))}scalePath(t,e){let i=1/0,s=1/0,n=-1/0,o=-1/0;for(const e of t)"M"===e[0]?(i=Math.min(i,e[1]),s=Math.min(s,e[2]),n=Math.max(n,e[1]),o=Math.max(o,e[2])):"C"===e[0]&&(i=Math.min(i,e[1],e[3],e[5]),s=Math.min(s,e[2],e[4],e[6]),n=Math.max(n,e[1],e[3],e[5]),o=Math.max(o,e[2],e[4],e[6]));return this.originalWidth=(n-i)*e,this.originalHeight=(o-s)*e,t.map((t=>"M"===t[0]?["M",t[1]*e,t[2]*e]:"C"===t[0]?["C",t[1]*e,t[2]*e,t[3]*e,t[4]*e,t[5]*e,t[6]*e]:[...t]))}getBezierPoint(t,e){if("M"===t[0])return{x:t[1],y:t[2]};if("C"===t[0]){const i=this.prevX,s=this.prevY,n=t[1],o=t[2],r=t[3],a=t[4],h=t[5],l=t[6];return{x:Math.pow(1-e,3)*i+3*Math.pow(1-e,2)*e*n+3*(1-e)*Math.pow(e,2)*r+Math.pow(e,3)*h,y:Math.pow(1-e,3)*s+3*Math.pow(1-e,2)*e*o+3*(1-e)*Math.pow(e,2)*a+Math.pow(e,3)*l}}return{x:0,y:0}}getPartialPath(){const t=[];let e=this.pathCommands.length,i=Math.floor(this.animationProgress*e),s=this.animationProgress*e%1,n=!1;this.prevX=0,this.prevY=0;for(let e=0;e<i;e++){const i=this.pathCommands[e];t.push([...i]),"M"===i[0]?(this.prevX=i[1],this.prevY=i[2],n=!0):"C"===i[0]&&(this.prevX=i[5],this.prevY=i[6],n=!0)}if(i<e){const e=this.pathCommands[i];if("M"===e[0])t.push([...e]),this.prevX=e[1],this.prevY=e[2],this.currentPoint={x:e[1],y:e[2]},n=!0;else if("C"===e[0]){if(!n){for(let t=i-1;t>=0;t--)if("M"===this.pathCommands[t][0]){this.prevX=this.pathCommands[t][1],this.prevY=this.pathCommands[t][2],n=!0;break}n||(this.prevX=0,this.prevY=0)}const o=this.getBezierPoint(e,s);t.push(["C",e[1],e[2],e[3],e[4],o.x,o.y]),this.currentPoint=o}}return t}draw(){super.draw(),this.renderWithTransform((()=>{const t=this.getPartialPath();Painter.path(t,this.fillColor,this.strokeColor,this.lineWidth)}))}getCurrentPoint(){return{x:this.x+this.currentPoint.x,y:this.y+this.currentPoint.y}}setAnimationProgress(t){this.animationProgress=Math.max(0,Math.min(1,t))}getBounds(){return{x:this.x,y:this.y,width:this.originalWidth||100,height:this.originalHeight||100}}}class StickFigure extends Shape{constructor(t,e,i=1,s={}){super(t,e,s),this.scale=i,this.strokeColor=s.strokeColor||"#000",this.headColor=s.headColor||this.strokeColor,this.jointColor=s.jointColor||this.strokeColor,this.lineWidth=s.lineWidth||2,this.showJoints=!1!==s.showJoints}draw(){super.draw();const t=this.scale,e=10*t,i=-30*t,s=i+e,n=s+40*t,o=s+10*t,r=15*t,a=10*t,h=n+40*t,l=3*t;this.renderWithTransform((()=>{if(Painter.fillCircle(0,i,e,this.headColor),Painter.strokeCircle(0,i,e,this.strokeColor,this.lineWidth),Painter.line(0,s,0,n,this.strokeColor,this.lineWidth),Painter.line(-r,o,r,o,this.strokeColor,this.lineWidth),Painter.line(0,n,-a,h,this.strokeColor,this.lineWidth),Painter.line(0,n,a,h,this.strokeColor,this.lineWidth),this.showJoints){[[0,s],[-r,o],[r,o],[0,n],[-a,h],[a,h]].forEach((([t,e])=>Painter.fillCircle(t,e,l,this.jointColor)))}}))}getBounds(){const t=100*this.scale,e=40*this.scale;return{x:this.x,y:this.y,width:e,height:t}}}class Ring extends Shape{constructor(t,e,i,s,n={}){super(t,e,n),this.outerRadius=i,this.innerRadius=s}draw(){super.draw(),this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.arc(0,0,this.outerRadius,0,2*Math.PI),Painter.ctx.arc(0,0,this.innerRadius,0,2*Math.PI,!0),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Polygon extends Shape{constructor(t,e,i=6,s=40,n={}){super(t,e,n),this.sides=i,this.radius=s}draw(){super.draw();const t=[],e=2*Math.PI/this.sides;for(let i=0;i<this.sides;i++){const s=i*e;t.push({x:Math.cos(s)*this.radius,y:Math.sin(s)*this.radius})}this.renderWithTransform((()=>{Painter.polygon(t,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Arrow extends Shape{constructor(t,e,i,s,n={}){super(t,e,n),this.length=i,this.width=s}draw(){super.draw();const t=this.width/2,e=.4*this.length,i=this.length-e;this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.moveTo(-i/2,-t),Painter.ctx.lineTo(i/2,-t),Painter.ctx.lineTo(i/2,-this.width),Painter.ctx.lineTo(this.length/2,0),Painter.ctx.lineTo(i/2,this.width),Painter.ctx.lineTo(i/2,t),Painter.ctx.lineTo(-i/2,t),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Pin extends Shape{constructor(t,e,i=20,s={}){super(t,e,s),this.radius=i}draw(){super.draw();const t=this.radius,e=2.5*t;this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.arc(0,0,t,Math.PI,0),Painter.ctx.lineTo(t,0),Painter.ctx.lineTo(0,e),Painter.ctx.lineTo(-t,0),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}getBounds(){return{x:this.x,y:this.y+.98*this.radius,width:2*this.radius,height:2.5*this.radius}}}class PieSlice extends Shape{constructor(t,e,i,s,n,o={}){super(t,e,o),this.radius=i,this.startAngle=s,this.endAngle=n}draw(){super.draw(),this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.moveTo(0,0),Painter.ctx.arc(0,0,this.radius,this.startAngle,this.endAngle),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Hexagon extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.radius=i}draw(){super.draw();const t=Array.from({length:6},((t,e)=>{const i=Math.PI/3*e;return{x:Math.cos(i)*this.radius,y:Math.sin(i)*this.radius}}));this.renderWithTransform((()=>{Painter.polygon(t,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Heart extends Shape{constructor(t,e,i=50,s=50,n={}){super(t,e,n),this.width=i,this.height=s}draw(){super.draw();const t=this.width,e=this.height,i=.3*e;this.renderWithTransform((()=>{const s=Painter.ctx;s.beginPath(),s.moveTo(0,i),s.bezierCurveTo(0,0,-t/2,0,-t/2,i),s.bezierCurveTo(-t/2,.8*e,0,e,0,e),s.bezierCurveTo(0,e,t/2,.8*e,t/2,i),s.bezierCurveTo(t/2,0,0,0,0,i),s.closePath(),this.fillColor&&(s.fillStyle=this.fillColor,s.fill()),this.strokeColor&&(s.strokeStyle=this.strokeColor,s.lineWidth=this.lineWidth,s.stroke())}))}getBounds(){return{x:this.x,y:this.y+this.height/2,width:this.width,height:this.height}}}class Cross extends Shape{constructor(t,e,i,s,n={}){super(t,e,n),this.size=i,this.thickness=s,this.diagonal=n.diagonal||!1}draw(){super.draw(),this.renderWithTransform((()=>{const t=this.size/2,e=this.thickness/2;this.diagonal?(Painter.ctx.beginPath(),Painter.ctx.moveTo(-t,-t+e),Painter.ctx.lineTo(-t+e,-t),Painter.ctx.lineTo(0,-e),Painter.ctx.lineTo(t-e,-t),Painter.ctx.lineTo(t,-t+e),Painter.ctx.lineTo(e,0),Painter.ctx.lineTo(t,t-e),Painter.ctx.lineTo(t-e,t),Painter.ctx.lineTo(0,e),Painter.ctx.lineTo(-t+e,t),Painter.ctx.lineTo(-t,t-e),Painter.ctx.lineTo(-e,0),Painter.ctx.closePath()):(Painter.ctx.beginPath(),Painter.ctx.moveTo(-e,-t),Painter.ctx.lineTo(e,-t),Painter.ctx.lineTo(e,-e),Painter.ctx.lineTo(t,-e),Painter.ctx.lineTo(t,e),Painter.ctx.lineTo(e,e),Painter.ctx.lineTo(e,t),Painter.ctx.lineTo(-e,t),Painter.ctx.lineTo(-e,e),Painter.ctx.lineTo(-t,e),Painter.ctx.lineTo(-t,-e),Painter.ctx.lineTo(-e,-e),Painter.ctx.closePath()),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Group extends Shape{constructor(t,e,i={}){super(t,e,i),this.children=[]}add(t){this.children=[...this.children,t]}remove(t){this.children=this.children.filter((e=>e!==t))}removeMutable(t){const e=this.children.indexOf(t);-1!==e&&this.children.splice(e,1)}clear(){this.children=[]}draw(){this.renderWithTransform((()=>{this.children.forEach((t=>t.draw()))}))}getBounds(){if(0===this.children.length)return null;const t=this.children.map((t=>{const e="function"==typeof t.getBounds?t.getBounds():null;if(!e)return null;const i=e.width/2,s=e.height/2;return{minX:e.x-i,maxX:e.x+i,minY:e.y-s,maxY:e.y+s}})).filter((t=>null!==t));if(0===t.length)return null;const e=Math.min(...t.map((t=>t.minX))),i=Math.max(...t.map((t=>t.maxX))),s=Math.min(...t.map((t=>t.minY))),n=i-e,o=Math.max(...t.map((t=>t.maxY)))-s,r=e+n/2,a=s+o/2;return{x:this.x+r,y:this.y+a,width:n,height:o}}}class TextShape extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.text=i,this.font=s.font||"12px monospace",this.color=s.color||"#000",this.align=s.align||"center",this.baseline=s.baseline||"top"}draw(){super.draw(),this.renderWithTransform((()=>{Painter.setFont(this.font),Painter.setTextAlign(this.align),Painter.setTextBaseline(this.baseline),Painter.fillText(this.text,0,0,this.color)}))}getBounds(){return this.width=Painter.measureText(this.text),{x:this.x,y:this.y,width:this.width,height:parseInt(this.font)}}}class OutlinedText extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.text=i,this.centered=s.centered||!1,this.fillColor=s.fillColor||"#000000",this.strokeColor=s.strokeColor||"#FFFFFF",this.lineWidth=s.lineWidth||1,this.font=s.font||null,this.align=s.align||"left",this.baseline=s.baseline||"alphabetic",this.calculateDimensions()}calculateDimensions(){if(!Painter.ctx)return console.warn("Painter context not initialized. Cannot calculate text dimensions."),this.width=0,void(this.height=0);const t=Painter.ctx.font;this.font&&(Painter.ctx.font=this.font);const e=Painter.ctx.measureText(this.text);if(this.width=e.width,this.font){const t=parseInt(this.font);this.height=isNaN(t)?20:t}else this.height=e.actualBoundingBoxAscent+e.actualBoundingBoxDescent||20;this.width+=2*this.lineWidth,this.height+=2*this.lineWidth,Painter.ctx.font=t}setText(t){this.text=t,this.calculateDimensions()}draw(){super.draw(),Painter.ctx?this.renderWithTransform((()=>{let t=0;this.font&&(Painter.ctx.font=this.font),Painter.ctx.textAlign=this.align,Painter.ctx.textBaseline=this.baseline,this.centered&&("middle"===this.baseline||"alphabetic"===this.baseline?t=0:"top"===this.baseline?t=this.height/2:"bottom"===this.baseline&&(t=-this.height/2)),Painter.outlinedText(this.text,0,t,this.fillColor,this.strokeColor,this.lineWidth,this.font)})):console.warn("Painter context not initialized. Cannot draw text.")}getBounds(){let t=this.x,e=this.y;return this.centered||("left"===this.align?t+=this.width/2:"right"===this.align&&(t-=this.width/2),"top"===this.baseline?e+=this.height/2:"bottom"===this.baseline&&(e-=this.height/2)),{x:t,y:e,width:this.width,height:this.height}}}class WrappedText extends Shape{constructor(t,e,i,s,n=20,o={}){super(t,e,o),this.text=i,this.maxWidth=s,this.lineHeight=n,this.centered=o.centered||!1,this.fillColor=o.fillColor||"#000000",this.font=o.font||null,this.align=o.align||"left",this.baseline=o.baseline||"top",this.outlineColor=o.outlineColor||null,this.outlineWidth=o.outlineWidth||1,this.calculateDimensions()}calculateDimensions(){if(!Painter.ctx)return console.warn("Painter context not initialized. Cannot calculate text dimensions."),this.width=this.maxWidth,this.height=this.lineHeight,void(this.lines=[this.text]);const t=Painter.ctx.font,e=Painter.ctx.textAlign,i=Painter.ctx.textBaseline;this.font&&(Painter.ctx.font=this.font),Painter.ctx.textAlign="left",Painter.ctx.textBaseline="top";const s=this.text.split(" ");let n="",o="";this.lines=[],this.width=0;for(let t=0;t<s.length;t++){o=n+s[t]+" ";Painter.ctx.measureText(o).width>this.maxWidth&&t>0?(this.lines.push(n),this.width=Math.max(this.width,Painter.ctx.measureText(n).width),n=s[t]+" "):n=o}this.lines.push(n),this.width=Math.max(this.width,Painter.ctx.measureText(n).width),this.height=this.lines.length*this.lineHeight,Painter.ctx.font=t,Painter.ctx.textAlign=e,Painter.ctx.textBaseline=i}setText(t){this.text=t,this.calculateDimensions()}draw(){super.draw(),Painter.ctx?this.renderWithTransform((()=>{let t=0,e=0;this.centered&&(t=-this.width/2,e=-this.height/2),this.font&&(Painter.ctx.font=this.font),Painter.ctx.textAlign=this.align,Painter.ctx.textBaseline=this.baseline;let i=t;"center"===this.align?i=0:"right"===this.align&&(i=t+this.width);for(let t=0;t<this.lines.length;t++){const s=e+t*this.lineHeight;this.outlineColor?Painter.outlinedText(this.lines[t],i,s,this.fillColor,this.outlineColor,this.outlineWidth,this.font):Painter.fillText(this.lines[t],i,s,this.fillColor,this.font)}})):console.warn("Painter context not initialized. Cannot draw text.")}getBounds(){return this.centered?{x:this.x,y:this.y,width:this.width,height:this.height}:{x:this.x+this.width/2,y:this.y+this.height/2,width:this.width,height:this.height}}}const index=Object.freeze(Object.defineProperty({__proto__:null,Arc:Arc,Arrow:Arrow,BezierShape:BezierShape,Circle:Circle,Cloud:Cloud,Cone:Cone,Cross:Cross,Cube:Cube,Cylinder:Cylinder,Diamond:Diamond,Group:Group,Heart:Heart,Hexagon:Hexagon,Line:Line,OutlinedText:OutlinedText,PatternRectangle:PatternRectangle,PieSlice:PieSlice,Pin:Pin,Polygon:Polygon,Prism:Prism,Rectangle:Rectangle,Ring:Ring,RoundedRectangle:RoundedRectangle,SVGShape:SVGPath,Shape:Shape,Sphere:Sphere,Square:Square,Star:Star,StickFigure:StickFigure,TextShape:TextShape,Transformable:Transformable,Triangle:Triangle,WrappedText:WrappedText},Symbol.toStringTag,{value:"Module"}));class GameObject extends Transformable{constructor(t,e={}){super(e),this.game=t,this.ctx=t.ctx,this.active=!0,this.events=new EventEmitter,this.interactive=!1,this.parent=null,applyAnchor(this,e)}enableInteractivity(t){this.interactive=!0,this.shape=t,this._hovered=!1}_hitTest(t,e){var i,s,n;const o=(null==(s=null==(i=this.shape)?void 0:i.getBounds)?void 0:s.call(i))??(null==(n=this.getBounds)?void 0:n.call(this));if(!o)return!1;const{x:r,y:a,width:h,height:l}=o,c=h/2,u=l/2;return t>=r-c&&t<=r+c&&e>=a-u&&e<=a+u}on(t,e){this.events.on(t,e)}off(t,e){this.events.off(t,e)}update(t){}render(){}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class ShapeGOFactory{static create(t,e,i={}){return new GameObjectShapeWrapper(t,e,i)}}class GameObjectShapeWrapper extends GameObject{constructor(t,e,i={}){const s={...{x:(null==e?void 0:e.x)??0,y:(null==e?void 0:e.y)??0,width:(null==e?void 0:e.width)??0,height:(null==e?void 0:e.height)??0,scaleX:(null==e?void 0:e.scaleX)??1,scaleY:(null==e?void 0:e.scaleY)??1},...i};super(t,s),this.shape=e,console.log("creating GameObjectShapeWrapper",e,"with",s)}update(t){this.shape&&this.active&&(this.shape.x=this.x,this.shape.y=this.y,this.shape.width=this.width,this.shape.height=this.height,this.shape.opacity=this.opacity,this.shape.visible=this.visible,this.shape.scaleX=this.scaleX,this.shape.scaleY=this.scaleY,this.shape.offsetX=this.offsetX,this.shape.offsetY=this.offsetY)}render(){this.shape&&this.visible&&this.shape.draw()}}class Scene extends GameObject{constructor(t,e={}){super(t,e),this.children=[],this.x=e.x??0,this.y=e.y??0}add(t){return t.parent=this,this.children.push(t),t}remove(t){this.children=this.children.filter((e=>e!==t)),t.parent=null}clear(){this.children=[]}bringToFront(t){this.remove(t),this.children.push(t)}sendToBack(t){this.remove(t),this.children.unshift(t)}update(t){for(let e of this.children){"number"==typeof e.x&&(e.x+=this.x),"number"==typeof e.y&&(e.y+=this.y);const i=e.opacity??1;e.opacity=this.opacity*i;const s=e.scaleX??1,n=e.scaleY??1;e.scaleX*=this.scaleX,e.scaleY*=this.scaleY;const o=e.rotation??0;e.rotation+=this.rotation,e.update&&e.update(t),e.opacity=i,e.rotation=o,e.scaleX=s,e.scaleY=n,"number"==typeof e.x&&(e.x-=this.x),"number"==typeof e.y&&(e.y-=this.y)}}render(){if(this.visible&&!(this.opacity<=0))for(let t of this.children)t.render&&t.render()}}class Text extends GameObject{constructor(t,e,i={}){super(t,i),this.text=e,this.x=i.x||0,this.y=i.y||0,this.font=i.font||"16px monospace",this.color=i.color||"#fff",this.align=i.align||"left",this.baseline=i.baseline||"top",this.stroke=i.stroke||!1,this.strokeColor=i.strokeColor||"#000",this.lineWidth=i.lineWidth||1}render(){Painter.setFont(this.font),Painter.setTextAlign(this.align),Painter.setTextBaseline(this.baseline),this.stroke&&Painter.strokeText(this.text,this.x,this.y,this.strokeColor,this.lineWidth,this.font),Painter.fillText(this.text,this.x,this.y,this.color,this.font)}}class Tween{static lerp(t,e,i){return t+(e-t)*i}static lerpAngle(t,e,i){let s=e-t;for(;s<-Math.PI;)s+=2*Math.PI;for(;s>Math.PI;)s-=2*Math.PI;return t+s*i}static tweenColor(t,e,i){return t.map(((t,s)=>Tween.lerp(t,e[s],i)))}static tweenGradient(t,e,i){let s=t[0],n=e[0];Math.abs(n-s)>180&&(s<n?s+=360:n+=360);return[Tween.lerp(s,n,i)%360,Tween.lerp(t[1],e[1],i),Tween.lerp(t[2],e[2],i)]}}class Easing{static easeInQuad(t){return t*t}static easeOutQuad(t){return t*(2-t)}static easeInOutQuad(t){return t<.5?2*t*t:(4-2*t)*t-1}static easeInCubic(t){return t*t*t}static easeOutCubic(t){return--t*t*t+1}static easeInOutCubic(t){return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1}static easeInQuart(t){return t*t*t*t}static easeOutQuart(t){return 1- --t*t*t*t}static easeInOutQuart(t){return t<.5?8*t*t*t*t:1-8*--t*t*t*t}static easeInSine(t){return 1-Math.cos(t*Math.PI/2)}static easeOutSine(t){return Math.sin(t*Math.PI/2)}static easeInOutSine(t){return-(Math.cos(Math.PI*t)-1)/2}static easeInExpo(t){return 0===t?0:Math.pow(2,10*(t-1))}static easeOutExpo(t){return 1===t?1:1-Math.pow(2,-10*t)}static easeInOutExpo(t){return 0===t||1===t?t:t<.5?.5*Math.pow(2,20*t-10):.5*(2-Math.pow(2,-20*t+10))}static easeInCirc(t){return 1-Math.sqrt(1-t*t)}static easeOutCirc(t){return Math.sqrt(1- --t*t)}static easeInOutCirc(t){return t<.5?.5*(1-Math.sqrt(1-4*t*t)):.5*(Math.sqrt(-(2*t-3)*(2*t-1))+1)}static easeInElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return-e*Math.pow(2,10*(t-1))*Math.sin((t-1-s)*(2*Math.PI)/i)}static easeOutElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return e*Math.pow(2,-10*t)*Math.sin((t-s)*(2*Math.PI)/i)+1}static easeInOutElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return t<.5?e*Math.pow(2,10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/i)*-.5:e*Math.pow(2,-10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/i)*.5+1}static easeInBack(t,e=1.70158){return t*t*((e+1)*t-e)}static easeOutBack(t,e=1.70158){return--t*t*((e+1)*t+e)+1}static easeInOutBack(t,e=1.70158){const i=1.525*e;return t<.5?2*t*.5*(2*t)*(2*(i+1)*t-i):.5*((2*t-2)*(2*t-2)*((i+1)*(2*t-2)+i)+2)}static easeOutBounce(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}static easeInBounce(t){return 1-Easing.easeOutBounce(1-t)}static easeInOutBounce(t){return t<.5?.5*Easing.easeInBounce(2*t):.5*Easing.easeOutBounce(2*t-1)+.5}}function bezierV1(t,e,i,s,n,o,r=!1,a=!1,h=null,l={},c=null){if(o<=0)return Motion.animationResult({x:s[0],y:s[1],phase:"complete"},1,!1,!0);let u=n/o,d="forward",p=0;r?(p=Math.floor(u),u%=1,p>0&&l.onLoop&&l.onLoop(p)):u>1&&(u=1),u>0&&n<=o&&l.onStart&&l.onStart();let g=h?h(u):u;a&&(u>=.5?(g=1-2*(u-.5),d="return",u>=.5&&u<.51&&l.onYoyoTurn&&l.onYoyoTurn()):(g=2*u,d="forward"),g=h?h(g):g);const x=3*(e[0]-t[0]),f=3*(i[0]-e[0])-x,m=s[0]-t[0]-x-f,P=3*(e[1]-t[1]),y=3*(i[1]-e[1])-P,M=s[1]-t[1]-P-y,w=m*Math.pow(g,3)+f*Math.pow(g,2)+x*g+t[0],C=M*Math.pow(g,3)+y*Math.pow(g,2)+P*g+t[1],b=!r&&u>=1;return b&&l.onComplete&&l.onComplete(),Motion.animationResult({x:w,y:C,phase:d},u,r,b,c)}function bounceV1(t,e,i,s,n,o=!1,r=null,a={},h=null){const{t:l,easedT:c,completed:u,state:d}=Motion._frame(s,n,o,r,a,h),p=1/(i+1),g=Math.min(Math.floor(c/p),i),x=c%p/p,f=t*Math.pow(.6,g),m=e-Math.sin(x*Math.PI)*(e-f);return Motion.animationResult({y:m,segment:g,bounceHeight:f},l,o,u,d)}function floatV1(t,e,i,s,n,o,r=!0,a=null,h={},l=null){if(i<=0)return Motion.animationResult({x:t.x,y:t.y,moving:!1},1,!1,!0);l||(l={initialX:0,initialY:0,started:!1,completed:!1,loopCount:0});const c=l.initialX,u=l.initialY,{t:d,easedT:p,completed:g,state:x}=Motion._frame(e,i,r,a,h,l);l={...l,...x};const f=e*s,m=Math.max(0,Math.min(1,n)),P=c+(Math.sin(.7*f)+.4*m*Math.sin(2.3*f+.5))*o,y=u+(Math.cos(.9*f)+.4*m*Math.cos(1.9*f+.7))*o,M=.7*Math.cos(.7*f)+.4*m*2.3*Math.cos(2.3*f+.5),w=-.9*Math.sin(.9*f)+.4*m*-1.9*Math.sin(1.9*f+.7),C=Math.sqrt(M*M+w*w),b=C>.8,v=Math.sqrt((P-c)*(P-c)+(y-u)*(y-u));return Motion.animationResult({x:P,y:y,centerX:c,centerY:u,offsetX:P-c,offsetY:y-u,distance:v,moving:b,velocity:C},d,r,g,l)}function followPath(t,e=!1,i,s,n=!1,o=null,r={},a=null){if(!t||t.length<2)return this._createResult({x:0,y:0},0,n,!1);const{t:h,easedT:l,completed:c,state:u}=Motion._frame(i,s,n,o,r,a);if(!a||!a.pathData){const i={segmentLengths:[],totalLength:0,points:[...t]};for(let e=0;e<t.length-1;e++){const s=t[e],n=t[e+1],o=n[0]-s[0],r=n[1]-s[1],a=Math.sqrt(o*o+r*r);i.segmentLengths.push(a),i.totalLength+=a}if(e){const e=t[t.length-1],s=t[0],n=s[0]-e[0],o=s[1]-e[1],r=Math.sqrt(n*n+o*o);i.segmentLengths.push(r),i.totalLength+=r}u.pathData=i}const{segmentLengths:d,totalLength:p,points:g}=u.pathData,x=l*p;let f=0,m=0;for(let t=0;t<d.length;t++){if(f+d[t]>=x){m=t;break}f+=d[t]}const P=(x-f)/d[m],y=g[m],M=m<g.length-1?g[m+1]:g[0],w=Tween.lerp(y[0],M[0],P),C=Tween.lerp(y[1],M[1],P),b=Math.atan2(M[1]-y[1],M[0]-y[0]);return Motion.animationResult({x:w,y:C,angle:b,segmentIndex:m,segmentProgress:P,pathProgress:l},h,n,c,u)}function orbitV1(t,e,i,s,n,o,r,a=!0,h=!0,l=null,c={},u=null){const{t:d,easedT:p,completed:g,state:x}=Motion._frame(o,r,a,l,c,u),f=n+(h?1:-1)*p*Math.PI*2,m=t+i*Math.cos(f),P=e+s*Math.sin(f);return Motion.animationResult({x:m,y:P,angle:f},d,a,g,x)}function oscillateV1(t,e,i,s,n=!0,o=null,r={},a=null){const{t:h,easedT:l,completed:c,state:u}=Motion._frame(i,s,n,o,r,a),d=(e-t)/2,p=t+d+d*Math.sin(l*Math.PI*2);return Motion.animationResult({value:p},h,n,c,u)}function parabolicV1(t,e,i,s,n,o=!1,r=!1,a=null,h={},l=null){l||(l={started:!1,loopCount:0,direction:1,lastDirection:1,completed:!1});let c=n>0?s/n:1,u=!1,d={...h};if(r||o)if(o)if(r){const t=2*n,e=s%t,i=Math.floor(s/t),o=e<n?1:-1;c=1===o?e/n:2-e/n,o!==l.direction&&(l.direction=o,1===l.direction&&d.onLoop&&d.onLoop(i)),i>l.loopCount&&(l.loopCount=i)}else{c%=1;const t=Math.floor(s/n);t>l.loopCount&&d.onLoop&&(d.onLoop(t),l.loopCount=t)}else r&&!o&&(c<=1?l.direction=1:c<=2?(c=2-c,l.direction=-1):(c=0,u=!0,l.direction=1));else c>=1&&(c=1,u=!0);!l.started&&d.onStart&&(d.onStart(),l.started=!0),u&&!l.completed&&d.onComplete&&(d.onComplete(),l.completed=!0);const p=a?a(c):c,g=(t+i-2*e)*p*p+2*(e-t)*p+t,x={...l,lastDirection:l.direction,completed:u||l.completed};return Motion.animationResult({value:g,direction:l.direction},c,o||r&&!u,u,x)}function patrolV1(t,e,i,s,n,o,r=!0,a=null){a||(a={currentX:t,currentY:e,targetX:t,targetY:e,isWaiting:!0,waitStartTime:0,moveStartTime:0,moveCount:0,direction:"idle"});const h=()=>Math.random();let l=a.isWaiting,c=a.currentX,u=a.currentY,d=a.direction;if(l){if(i-a.waitStartTime>=n){l=!1,a.moveStartTime=i;d=["up","down","left","right"][Math.floor(4*h())];let s=a.currentX,n=a.currentY;const r=o*(.2+.6*h());switch(d){case"up":n=a.currentY-r;break;case"down":n=a.currentY+r;break;case"left":s=a.currentX-r;break;case"right":s=a.currentX+r}Math.pow(s-t,2)+Math.pow(n-e,2)>o*o&&("up"===d||"down"===d?(n=e,d=a.currentY>e?"up":"down"):(s=t,d=a.currentX>t?"left":"right")),a.targetX=s,a.targetY=n,a.direction=d,a.moveCount++}}else{const t=(i-a.moveStartTime)/s;t>=1?(l=!0,a.waitStartTime=i,a.currentX=a.targetX,a.currentY=a.targetY,d="idle"):(c=a.currentX+(a.targetX-a.currentX)*t,u=a.currentY+(a.targetY-a.currentY)*t)}a.isWaiting=l,a.direction=d,l||(a.currentX=c,a.currentY=u);const p=s+n,g=i%p/p,x=Math.sqrt(Math.pow(c-t,2)+Math.pow(u-e,2));return Motion.animationResult({x:c,y:u,moving:!l,direction:d,distanceFromCenter:x},g,r,!1,a)}function pendulumV1(t,e,i,s,n=!0,o=!1,r=null,a={},h=null){const{t:l,easedT:c,completed:u,state:d}=Motion._frame(i,s,n,null,a,h),p=o&&!n?Math.exp(-4*l):1;let g=t+e*Math.cos(2*c*Math.PI)*p;if(r){g=t+r(((g-t)/(e*p)+1)/2)*e*p*2-e*p}return Motion.animationResult({angle:g},l,n,u,d)}function pulseV1(t,e,i,s,n=!0,o=!1,r=null,a={}){let h,l=i/s,c="forward";if(n){const t=Math.floor(l);l%=1,t>0&&a.onLoop&&a.onLoop(t)}else l>1&&(l=1);if(l>0&&i<=s&&a.onStart&&a.onStart(),o)if(l<.5){const i=2*l;h=t+(e-t)*(r?r(i):i),c="forward"}else{const i=2*(l-.5);h=e-(e-t)*(r?r(i):i),c="return",l>=.5&&l<.51&&a.onYoyoTurn&&a.onYoyoTurn()}else{const i=r?r(l):l;h=t+(e-t)*(i<.5?2*i:2-2*i)}const u=!n&&l>=1;return u&&a.onComplete&&a.onComplete(),Motion.animationResult({value:h,phase:c},l,n,u)}function hopV1(t,e,i,s,n=!0,o=!0,r=null,a={},h=null){const{t:l,easedT:c,completed:u,state:d}=Motion._frame(i,s,n,r,a,h,o);let p=0;p=n||o?o?Math.sin(c*Math.PI):Math.sin(Math.min(l,1)*Math.PI*.5):u?1:Math.sin(Math.min(l,1)*Math.PI*.5);const g=t-e*p;return Motion.animationResult({y:g},l,n,u,d)}function shakeV1(t,e,i,s,n,o,r,a,h=!1,l=null,c={},u=null){const{t:d,easedT:p,completed:g,state:x}=Motion._frame(r,a,h,l,c,u),f=Math.pow(1-p,o),m=p*Math.PI*2*n,P=p*Math.PI*2*n*1.3,y=f*i*(.6*Math.sin(m)+.3*Math.sin(2.5*m)+.1*Math.sin(5.6*m)),M=f*s*(.6*Math.cos(P)+.3*Math.cos(2.7*P)+.1*Math.cos(6.3*P));let w=t+y,C=e+M;if(p>.9){const i=(p-.9)/.1;w=t+y*(1-i),C=e+M*(1-i)}return Motion.animationResult({x:w,y:C,intensity:f},d,h,g,x)}function spiralV1(t,e,i,s,n,o,r,a,h=!1,l=!1,c=null,u={},d=null){d||(d={started:!1,loopCount:0,direction:1,lastDirection:1});let p=a>0?r/a:1,g=!1,x={...u};if(l||h)if(h)if(l){const t=2*a,e=r%t,i=Math.floor(r/t),s=e<a?1:-1;p=1===s?e/a:2-e/a,s!==d.direction&&(d.direction=s,1===d.direction&&x.onLoop&&x.onLoop(i)),i>d.loopCount&&(d.loopCount=i)}else{p%=1;const t=Math.floor(r/a);t>d.loopCount&&x.onLoop&&(x.onLoop(t),d.loopCount=t)}else l&&!h&&(p<=1?d.direction=1:p<=2?(p=2-p,d.direction=-1):(p=0,g=!0,d.direction=1));else p>=1&&(p=1,g=!0);!d.started&&x.onStart&&(x.onStart(),d.started=!0),g&&!d.completed&&x.onComplete&&(x.onComplete(),d.completed=!0);const f=c?c(p):p,m=Tween.lerp(i,s,f),P=n+f*o*Math.PI*2,y=t+m*Math.cos(P),M=e+m*Math.sin(P),w={...d,lastDirection:d.direction};return Motion.animationResult({x:y,y:M,radius:m,angle:P,direction:d.direction},p,h||l&&!g,g,w)}function springV1(t,e,i,s,n=!1,o=!1,r={},a={}){if(s<=0)return this.animationResult({value:e,velocity:0,done:!0,phase:"complete"},1,!1,!0);let h,l,c,u=i/s,d="forward",p=0;n?(p=Math.floor(u),u%=1,p>0&&a.onLoop&&a.onLoop(p)):u>1&&(u=1),u>0&&i<=s&&a.onStart&&a.onStart(),o?u>=.5?(h=t,l=e,c=2*(u-.5),d="return",u>=.5&&u<.51&&a.onYoyoTurn&&a.onYoyoTurn()):(h=e,l=t,c=2*u,d="forward"):(h=e,l=t,c=u);const g=void 0!==r.stiffness?r.stiffness:.3,x=void 0!==r.damping?r.damping:.6,f=Math.max(.1,1/(1.5*x)),m=Math.max(.1,.8/(1.5*g+.5));let P;if(c<.99)P=Easing.easeOutElastic(c,f,m);else{const t=(c-.99)/.01;P=Easing.easeOutElastic(.99,f,m)*(1-t)+1*t}const y=Tween.lerp(l,h,P),M=Math.min(c+.01,1);let w;if(M<.99)w=Easing.easeOutElastic(M,f,m);else{const t=(M-.99)/.01;w=Easing.easeOutElastic(.99,f,m)*(1-t)+1*t}const C=(Tween.lerp(l,h,w)-y)/.01*s,b=!n&&u>=1;return b&&a.onComplete&&a.onComplete(),Motion.animationResult({value:y,velocity:C,delta:"forward"===d?e-y:t-y,done:b,phase:d},u,n,b)}function swingV1(t,e,i,s,n,o=!0,r=!0,a=null,h={},l=null){const{t:c,easedT:u,completed:d,state:p}=Motion._frame(s,n,o,a,h,l),g=(r?Math.sin(u*Math.PI*2):Math.sin(u*Math.PI))*i;return Motion.animationResult({angle:g},c,o,d,p)}function waypointV1(t,e,i,s,n,o=!0,r={},a=null){if(!i||!Array.isArray(i)||i.length<2)return console.warn("Patrol animation requires at least 2 waypoints"),Motion._createResult({x:0,y:0,moving:!1,direction:"idle",waypoint:0},0,!1,!0);a||(a={currentWaypoint:0,nextWaypoint:1,isWaiting:!0,waitStartTime:0,lastWaypointTime:0,lastWaypointReached:-1,completed:!1});let h=0;for(let t=0;t<i.length;t++){const e=(t+1)%i.length;if(!o&&t===i.length-1)break;const s=i[e][0]-i[t][0],n=i[e][1]-i[t][1];h+=Math.abs(s)+Math.abs(n)}const l=h/s+n*i.length;let c=e;c=o?e%l:Math.min(e,l);const u=c/l;let d,p,g,x=c,f=0,m=1,P=!0,y=0,M=0,w=!1;if(x<n)y=x/n,f=0,m=1,P=!0;else{x-=n;for(let t=0;t<i.length;t++){if(!o&&t===i.length-1){f=t,m=t,P=!0,y=1,w=!0;break}const e=(t+1)%i.length,h=i[e][0]-i[t][0],l=i[e][1]-i[t][1],c=(Math.abs(h)+Math.abs(l))/s;if(x<c){f=t,m=e,P=!1,M=x/c;break}if(x-=c,x<n){f=e,m=(e+1)%i.length,P=!0,y=x/n,a.lastWaypointReached!==f&&(r.onWaypointReached&&r.onWaypointReached(f),r.onWaitStart&&r.onWaitStart(f),a.lastWaypointReached=f);break}x-=n}}if(P||w)d=i[f][0],p=i[f][1],g="idle",!a.isWaiting&&P&&r.onWaitEnd&&r.onWaitEnd(f);else{const t=i[f],e=i[m],s=e[0]-t[0],n=e[1]-t[1],o=Math.abs(s)+Math.abs(n),r=Math.abs(s)/o;if(M<=r&&0!==s){const e=M/r;d=t[0]+s*e,p=t[1],g=s>0?"right":"left"}else{const i=(M-r)/(1-r);d=e[0],p=t[1]+n*i,g=n>0?"down":"up"}}return a.currentWaypoint=f,a.nextWaypoint=m,a.isWaiting=P,!a.completed&&w&&r.onPatrolComplete&&(r.onPatrolComplete(),a.completed=!0),Motion.animationResult({x:d,y:p,moving:!P,waiting:P,waitProgress:P?y:0,direction:g,waypoint:f,nextWaypoint:m},u,o,w,a)}class Motion{static animationResult(t,e,i,s=!1,n=null){return{...t,t:e,progress:e,loop:i,completed:s,state:n}}static _step(t,e,i,s={},n={started:!1,loopCount:0}){let o=e>0?t/e:1,r=!1;if(!(n=n||{started:!1,loopCount:0}).started&&s.onStart&&(s.onStart(),n.started=!0),i){o%=1;const i=Math.floor(t/e);i>n.loopCount&&s.onLoop&&(s.onLoop(i),n.loopCount=i)}else o>=1&&(o=1,r=!0,!n.completed&&s.onComplete&&(s.onComplete(),n.completed=!0));return{t:o,completed:r,state:n}}static _frame(t,e,i,s=null,n={},o=null){const{t:r,completed:a,state:h}=this._step(t,e,i,n,o);return{t:r,easedT:s?s(r):r,completed:a,state:h}}static oscillate(t,e,i,s,n=!0,o=null,r={},a=null){return oscillateV1(t,e,i,s,n,o,r,a)}static parabolic(t,e,i,s,n,o=!1,r=!1,a=null,h={},l=null){return parabolicV1(t,e,i,s,n,o,r,a,h,l)}static float(t,e,i,s,n,o,r=!0,a=null,h={},l=null){return floatV1(t,e,i,s,n,o,r,a,h,l)}static spring(t,e,i,s,n=!1,o=!1,r={},a={}){return springV1(t,e,i,s,n,o,r,a)}static swing(t,e,i,s,n,o=!0,r=!0,a=null,h={},l=null){return swingV1(t,e,i,s,n,o,r,a,h,l)}static pendulum(t,e,i,s,n=!0,o=!1,r=null,a={},h=null){return pendulumV1(t,e,i,s,n,o,r,a,h)}static pulse(t,e,i,s,n=!0,o=!1,r=null,a={}){return pulseV1(t,e,i,s,n,o,r,{})}static spiral(t,e,i,s,n,o,r,a,h=!1,l=!1,c=null,u={},d=null){return spiralV1(t,e,i,s,n,o,r,a,h,l,c,u,d)}static orbit(t,e,i,s,n,o,r,a=!0,h=!0,l=null,c={},u=null){return orbitV1(t,e,i,s,n,o,r,a,h,l,c,u)}static bezier(t,e,i,s,n,o,r=!1,a=!1,h=null,l={},c=null){return bezierV1(t,e,i,s,n,o,r,a,h,l,c)}static bounce(t,e,i,s,n,o=!1,r=null,a={},h=null){return bounceV1(t,e,i,s,n,o,r,a,h)}static shake(t,e,i,s,n,o,r,a,h=!1,l=null,c={},u=null){return shakeV1(t,e,i,s,n,o,r,a,h,l,c,u)}static follow(t,e=!1,i,s,n=!1,o=null,r={},a=null){return followPath(t,e,i,s,n,o,r,a)}static waypoint(t,e,i,s,n,o=!0,r={},a=null){return waypointV1(t,e,i,s,n,o,r,a)}static patrol(t,e,i,s,n,o,r=!0,a=null){return patrolV1(t,e,i,s,n,o,r,a)}static hop(t,e,i,s,n=!0,o=!0,r=null,a={},h=null){return hopV1(t,e,i,s,n,o,r,a,h)}static group(t,e,i,s,n=!1,o=null,r={},a=null){a||(a={started:!1,loopCount:0,animationStates:Array(t.length).fill(null)});const{t:h,easedT:l,completed:c,state:u}=this._frame(i,s,n,o,r,a),d={};for(let a=0;a<t.length;a++){const h=t[a],l=[...e[a]];h===this.parabolic||h===this.oscillate||h===this.pulse?(l[3]=i,l[4]=s,l[5]=n,void 0===l[6]&&(l[6]=o)):h===this.spring?(l[2]=i,l[3]=s,l[4]=n):h===this.spiral||h===this.bezier?(l[6]=i,l[7]=s,l[8]=n,void 0===l[9]&&(l[9]=o)):h===this.orbit?(l[5]=i,l[6]=s,l[7]=n,void 0===l[9]&&(l[9]=o)):h===this.bounce||h===this.shake?(l[6]=i,l[7]=s,l[8]=n,void 0===l[9]&&(l[9]=o)):h===this.followPath&&(l[2]=i,l[3]=s,l[4]=n,void 0===l[5]&&(l[5]=o)),l.push(r),l.push(u.animationStates[a]);const c=h.apply(this,l);u.animationStates[a]=c.state;d[`anim${a}`]=c}return this.animationResult(d,h,n,c,u)}static sequence(t,e,i,s,n=!1,o=null,r={},a=null,h=null){if(!h){h={started:!1,loopCount:0,animationStates:Array(t.length).fill(null),currentAnim:0,animStartTimes:[0],totalDuration:0};let e=0;for(let t=0;t<i.length;t++)e+=i[t],t<i.length-1&&h.animStartTimes.push(e);h.totalDuration=e}let l=s;if(n&&h.totalDuration>0){l=s%h.totalDuration;const t=Math.floor(s/h.totalDuration);t>h.loopCount&&r.onLoop&&(r.onLoop(t),h.loopCount=t)}!h.started&&r.onStart&&(r.onStart(),h.started=!0);let c=0;for(let e=t.length-1;e>=0;e--)if(l>=h.animStartTimes[e]){c=e;break}h.currentAnim=c;const u=l-h.animStartTimes[c],d=i[c],p=t[c],g=[...e[c]];p===this.parabolic||p===this.oscillate||p===this.pulse?(g[3]=u,g[4]=d,g[5]=!1,o&&o[c]&&(g[6]=o[c])):p===this.spring?(g[2]=u,g[3]=d,g[4]=!1):p===this.spiral||p===this.bezier?(g[6]=u,g[7]=d,g[8]=!1,o&&o[c]&&(g[9]=o[c])):p===this.orbit?(g[5]=u,g[6]=d,g[7]=!1,o&&o[c]&&(g[9]=o[c])):p===this.bounce||p===this.shake?(g[6]=u,g[7]=d,g[8]=!1,o&&o[c]&&(g[9]=o[c])):p===this.followPath&&(g[2]=u,g[3]=d,g[4]=!1,o&&o[c]&&(g[5]=o[c]));const x=a&&a[c]?a[c]:{},f=p.apply(this,[...g,x,h.animationStates[c]]);h.animationStates[c]=f.state;const m=!n&&l>=h.totalDuration;return m&&!h.completed&&r.onComplete&&(r.onComplete(),h.completed=!0),this.animationResult({...f,currentAnim:c,totalAnimations:t.length,sequenceProgress:Math.min(l/h.totalDuration,1)},l/h.totalDuration,n,m,h)}}class Tweenetik{constructor(t,e,i,s,n={}){this.target=t,this.toProps={...e},this.duration=i,this.easingFn=s||Easing.easeOutQuad,this.delay=n.delay||0,this.onStart=n.onStart||null,this.onComplete=n.onComplete||null,this.onUpdate=n.onUpdate||null,this._elapsed=0,this._started=!1,this._finished=!1,this._startProps={};for(const t in this.toProps)Object.prototype.hasOwnProperty.call(this.target,t)&&(this._startProps[t]=this.target[t])}static to(t,e,i,s,n){const o=new Tweenetik(t,e,i,s,n);return Tweenetik._active.push(o),o}update(t){if(this._finished)return;if(this._elapsed+=t,this._elapsed<this.delay)return;const e=this._elapsed-this.delay,i=Math.min(e/this.duration,1);!this._started&&i>0&&(this._started=!0,this.onStart&&this.onStart());const s=this.easingFn(i);for(const t in this._startProps){const e=this._startProps[t],i=this.toProps[t];this.target[t]=Tween.lerp(e,i,s)}this.onUpdate&&this.onUpdate(),i>=1&&(this._finished=!0,this.onComplete&&this.onComplete())}static updateAll(t){for(const e of Tweenetik._active)e.update(t);Tweenetik._active=Tweenetik._active.filter((t=>!t._finished))}}class Pipeline{constructor(t){this.game=t,this.gameObjects=[];["inputdown","inputup","inputmove"].forEach((t=>{this.game.events.on(t,(e=>{this.dispatchInputEvent(t,e)}))}))}_hoverObject(t,e){if(!t.interactive||!t._hitTest)return;const i=t._hitTest(e.x,e.y);i&&!t._hovered?(t._hovered=!0,t.events.emit("mouseover",e)):!i&&t._hovered&&(t._hovered=!1,t.events.emit("mouseout",e))}_hoverScene(t,e){for(let i=t.children.length-1;i>=0;i--){const s=t.children[i];s instanceof Scene?this._hoverScene(s,e):this._hoverObject(s,e)}}dispatchInputEvent(t,e){var i;for(let s=this.gameObjects.length-1;s>=0;s--){const n=this.gameObjects[s];if(n instanceof Scene){if(this._dispatchToScene(n,t,e))break}else if(n.interactive&&(null==(i=n._hitTest)?void 0:i.call(n,e.x,e.y))){n.events.emit(t,e);break}}"inputmove"===t&&this._dispatchHover(e)}_dispatchHover(t){for(let e=this.gameObjects.length-1;e>=0;e--){const i=this.gameObjects[e];i instanceof Scene?this._hoverScene(i,t):this._hoverObject(i,t)}}_dispatchToScene(t,e,i){var s;for(let n=t.children.length-1;n>=0;n--){const o=t.children[n];if(o instanceof Scene){if(this._dispatchToScene(o,e,i))return!0}else if(o.interactive&&(null==(s=o._hitTest)?void 0:s.call(o,i.x,i.y)))return o.events.emit(e,i),!0}return!1}add(t){return t.parent=this,this.gameObjects=[...this.gameObjects,t],t}remove(t){this.gameObjects=this.gameObjects.filter((e=>e!==t))}update(t){this.gameObjects.filter((t=>t.active)).forEach((e=>e.update(t))),Tweenetik.updateAll(t)}render(){this.gameObjects.filter((t=>t.visible)).forEach((t=>t.render()))}clear(){this.gameObjects=[]}}class Cursor extends GameObject{constructor(t,e,i=null,s={}){super(t,s),this.normalShape=e,this.pressedShape=i||e,this.active=!1,this.offsetX=0,this.offsetY=0,this.isDown=!1,this.game.events.on("inputmove",(t=>{this.x=t.x,this.y=t.y})),this.game.events.on("inputdown",(()=>{this.isDown=!0})),this.game.events.on("inputup",(()=>{this.isDown=!1}))}activate(){this.active=!0,this.game.canvas.style.cursor="none"}deactivate(){this.active=!1,this.game.canvas.style.cursor="default"}update(t){super.update(t)}render(){if(!this.active)return;const t=this.isDown&&this.pressedShape?this.pressedShape:this.normalShape;t&&(t.x=this.x+this.offsetX,t.y=this.y+this.offsetY,t.draw(),super.render())}}class Game{constructor(t){this.canvas=t,this.ctx=t.getContext("2d"),this.events=new EventEmitter,this._cursor=null,this.lastTime=0,this.running=!1,this.pipeline=new Pipeline(this),Painter.init(this.ctx),this.initIO(),this.initMotion(),console.log("[Game] Constructor")}init(){console.log("[Game] Initialized")}initMouse(){Mouse.init(this)}initTouch(){Touch.init(this)}initInput(){Input.init(this)}initKeyboard(){Keys.init(this)}initIO(){this.initMouse(),this.initTouch(),this.initInput(),this.initKeyboard()}initMotion(){Tweenetik._active=[]}enableFluidSize(t=window){if(t===window){const t=()=>{this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight};t(),window.addEventListener("resize",t),this._fluidResizeCleanup=()=>{window.removeEventListener("resize",t)}}else{if(!("ResizeObserver"in window))return void console.warn("ResizeObserver not supported in this browser.");const e=()=>{const e=t.getBoundingClientRect();this.canvas.width=e.width,this.canvas.height=e.height},i=new ResizeObserver((()=>{e()}));i.observe(t),e(),this._fluidResizeCleanup=()=>i.disconnect()}}disableFluidSize(){this._fluidResizeCleanup&&(this._fluidResizeCleanup(),this._fluidResizeCleanup=null)}start(){this.running=!0,this.loop=this.loop.bind(this),requestAnimationFrame(this.loop),console.log("[Game] Started")}stop(){this.running=!1,console.log("[Game] Stopped")}restart(){this.pipeline.clear(),this.init(),this.start(),console.log("[Game] Restarted")}loop(t){if(!this.running)return;const e=(t-this.lastTime)/1e3;this.lastTime=t,this.update(e),this.render(),requestAnimationFrame(this.loop)}update(t){this.pipeline.update(t)}render(){this.running&&this.clear(),this.pipeline.render()}clear(){Painter.clear()}get width(){return this.canvas.width}get height(){return this.canvas.height}set backgroundColor(t){this.canvas.style.backgroundColor=t}set cursor(t){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor)),this._cursor=t,this._cursor.activate(),this.pipeline.add(t)}get cursor(){return this._cursor}resetCursor(){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor),this._cursor=null)}}class Button extends GameObject{constructor(t,e={}){const{x:i=0,y:s=0,width:n=120,height:o=40,text:r="Button",shape:a=null,label:h=null,onClick:l=null,anchor:c,padding:u,...d}=e;super(t,{anchor:c,padding:u,...d}),this.x=i,this.y=s,this.width=n,this.height=o,this.state="default",this.bg=a??new Rectangle(0,0,n,o,{fillColor:"#eee",strokeColor:"#ccc",lineWidth:2}),this.label=h??new TextShape(0,0,r,{font:"16px monospace",color:"#333",align:"center",baseline:"middle"}),this.group=new Group(i,s),this.group.add(this.bg),this.group.add(this.label),this.enableInteractivity(this.group),this.on("mouseover",this.setState.bind(this,"hover")),this.on("mouseout",this.setState.bind(this,"default")),this.on("inputdown",this.setState.bind(this,"pressed")),this.on("inputup",(()=>{"pressed"===this.state&&"function"==typeof l&&l(),this.setState("hover")})),this.setState("default")}setState(t){if(this.state!==t)switch(this.state=t,t){case"default":this.game.cursor&&setTimeout((()=>{this.game.cursor.activate()}),0),this.bg.fillColor="#eee",this.bg.strokeColor="#ccc",this.label.color="#333",this.game.canvas.style.cursor="default";break;case"hover":this.game.cursor&&this.game.cursor.deactivate(),this.bg.fillColor="#222",this.bg.strokeColor="#16F529",this.label.color="#16F529",this.game.canvas.style.cursor="pointer";break;case"pressed":this.game.cursor&&this.game.cursor.deactivate(),this.bg.fillColor="#111",this.bg.strokeColor="#00aaff",this.label.color="#00aaff",this.game.canvas.style.cursor="pointer"}}update(t){this.group.x=this.x,this.group.y=this.y}render(){this.group.draw()}}class ToggleButton extends Button{constructor(t,e={}){const i=e.onClick;super(t,{...e,onClick:()=>{this.toggled=!this.toggled,"function"==typeof e.onToggle&&e.onToggle(this.toggled),"function"==typeof i&&i(),this.refreshToggleVisual()}}),this.toggled=!!e.startToggled,this.refreshToggleVisual()}toggle(t){this.toggled=t,this.refreshToggleVisual()}refreshToggleVisual(){this.toggled?(this.bg.fillColor="#444",this.bg.strokeColor="#0f0",this.label.color="#0f0"):(this.bg.fillColor="#eee",this.bg.strokeColor="#ccc",this.label.color="#333")}setState(t){super.setState(t),this.toggled&&(this.bg.fillColor="#444",this.bg.strokeColor="#0f0",this.label.color="#0f0")}}class FPSCounter extends Text{constructor(t,e={}){super(t,"0 FPS",{x:0,y:0,font:e.font||"12px monospace",color:e.color||"#0f0",align:e.align,baseline:e.baseline,stroke:e.stroke||!1,strokeColor:e.strokeColor||"#000",lineWidth:e.lineWidth||1,anchor:e.anchor||"top-left"}),this.fps=0,this._frames=0,this._accum=0}update(t){var e;this._frames++,this._accum+=t,this._accum>=.5&&(this.fps=Math.round(this._frames/this._accum),this.text=`${this.fps} FPS`,this._frames=0,this._accum=0),null==(e=super.update)||e.call(this,t)}}class LayoutScene extends Scene{constructor(t,e={}){super(t,e),this.spacing=e.spacing??10,this.padding=e.padding??0,this.autoSize=e.autoSize??!0,this.align=e.align??"start",this.debug=e.debug??!1,this.width=0,this.height=0}render(){if(this.debug){new Rectangle(this.x+this.width/2,Math.round(this.y+this.height/2),this.width,this.height,{strokeColor:"#0f0",fillColor:"rgba(0,0,0,0.1)",lineWidth:1}).draw()}super.render()}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}update(t){var e;null==(e=super.update)||e.call(this,t);for(let e of this.children)e.update&&e.update(t)}}class HorizontalLayout extends LayoutScene{update(t){let e=this.padding,i=0;for(let t of this.children)i=Math.max(i,t.height??0);for(let t=0;t<this.children.length;t++){const s=this.children[t],n=this.y+(s.height??0)/2;switch(s.x=this.x+e+(s.width??0)/2,this.align){case"center":s.y=n+this.padding+(i-(s.height??0))/2;break;case"end":s.y=n+this.padding+(i-(s.height??0));break;default:s.y=n+this.padding}e+=s.width??0,t<this.children.length-1&&(e+=this.spacing)}this.autoSize&&(this.width=e+this.padding,this.height=i+2*this.padding),super.update(t)}}class VerticalLayout extends LayoutScene{update(t){let e=this.padding,i=0;for(let t of this.children)i=Math.max(i,t.width??0);for(let t=0;t<this.children.length;t++){const s=this.children[t],n=this.x+(s.width??0)/2;switch(s.y=this.y+e+(s.height??0)/2,this.align){case"center":s.x=n+this.padding+(i-(s.width??0))/2;break;case"end":s.x=n+this.padding+(i-(s.width??0));break;default:s.x=n+this.padding}e+=s.height??0,t<this.children.length-1&&(e+=this.spacing)}this.autoSize&&(this.height=e+this.padding,this.width=i+2*this.padding),super.update(t)}}class TileLayout extends LayoutScene{constructor(t,e={}){super(t,e),this.columns=e.columns??4}update(t){if(!this.children.length)return void super.update(t);const e=this.children[0].width||0;let i=this.padding,s=this.padding,n=0;for(let t=0;t<this.children.length;t++){const o=this.children[t];o.x=this.x+i+e/2,o.y=this.y+s+e/2,n++,n<this.columns?i+=e+this.spacing:(n=0,i=this.padding,s+=e+this.spacing)}if(this.autoSize){const t=Math.ceil(this.children.length/this.columns);this.width=this.columns*e+(this.columns-1)*this.spacing+2*this.padding,this.height=t*e+(t-1)*this.spacing+2*this.padding}super.update(t)}}function applyDraggable(t,e,i={}){const s=t.game;t.dragging=!1,t.dragOffset={x:0,y:0},t.target={x:e.x,y:e.y},t.friction=i.friction??.2,t.enableInteractivity(e),t.on("inputdown",(s=>{t.dragging=!0,t.dragOffset.x=e.x-s.x,t.dragOffset.y=e.y-s.y,i.onDragStart&&i.onDragStart()})),s.events.on("inputmove",(e=>{t.dragging&&(t.target.x=e.x+t.dragOffset.x,t.target.y=e.y+t.dragOffset.y)})),s.events.on("inputup",(()=>{t.dragging&&(t.dragging=!1,i.onDragEnd&&i.onDragEnd())}));const n=t.update.bind(t);t.update=function(i){t.x+=(t.target.x-e.x)*t.friction,t.y+=(t.target.y-e.y)*t.friction,n(i)}}export{Arc,Arrow,BezierShape,Button,Circle,Cloud,Cone,Cross,Cube,Cursor,Cylinder,Diamond,Easing,EventEmitter,FPSCounter,Game,GameObject,Group,Heart,Hexagon,HorizontalLayout,Input,Keys,LayoutScene,Line,Motion,Mouse,OutlinedText,Painter,PatternRectangle,PieSlice,Pin,Pipeline,Polygon,Prism,Rectangle,Ring,RoundedRectangle,SVGPath as SVGShape,Scene,Shape,ShapeGOFactory,index as Shapes,Sphere,Square,Star,StickFigure,Text,TextShape,TileLayout,ToggleButton,Touch,Transformable,Triangle,Tween,Tweenetik,VerticalLayout,WrappedText,applyAnchor,applyDraggable};