var __defProp=Object.defineProperty,__defNormalProp=(t,e,i)=>e in t?__defProp(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i,__publicField=(t,e,i)=>__defNormalProp(t,"symbol"!=typeof e?e+"":e,i);class Painter{static init(t){Painter.ctx=t}static save(){Painter.ctx.save()}static restore(){Painter.ctx.restore()}static clear(t=0,e=0,i=Painter.ctx.canvas.width,s=Painter.ctx.canvas.height){Painter.ctx.clearRect(t,e,i,s)}static translate(t,e){Painter.ctx.translate(t,e)}static rotate(t){Painter.ctx.rotate(t)}static scale(t,e){Painter.ctx.scale(t,e)}static fillRect(t,e,i,s,o){o&&(Painter.ctx.fillStyle=o),Painter.ctx.fillRect(t,e,i,s)}static strokeRect(t,e,i,s,o,n){o&&(Painter.ctx.strokeStyle=o),void 0!==n&&(Painter.ctx.lineWidth=n),Painter.ctx.strokeRect(t,e,i,s)}static fillCircle(t,e,i,s){Painter.ctx.beginPath(),Painter.ctx.arc(t,e,i,0,2*Math.PI),s&&(Painter.ctx.fillStyle=s),Painter.ctx.fill()}static strokeCircle(t,e,i,s,o){Painter.ctx.beginPath(),Painter.ctx.arc(t,e,i,0,2*Math.PI),s&&(Painter.ctx.strokeStyle=s),void 0!==o&&(Painter.ctx.lineWidth=o),Painter.ctx.stroke()}static fillEllipse(t,e,i,s,o=0,n){Painter.ctx.beginPath(),Painter.ctx.ellipse(t,e,i,s,o,0,2*Math.PI),n&&(Painter.ctx.fillStyle=n),Painter.ctx.fill()}static path(t,e,i,s=1){const o=Painter.ctx;o.beginPath();for(const e of t){const[t,...i]=e;"M"===t?o.moveTo(...i):"L"===t?o.lineTo(...i):"C"===t?o.bezierCurveTo(...i):"Q"===t?o.quadraticCurveTo(...i):"Z"===t&&o.closePath()}e&&(o.fillStyle=e,o.fill()),i&&(o.strokeStyle=i,o.lineWidth=s,o.stroke())}static strokeEllipse(t,e,i,s,o=0,n,r){Painter.ctx.beginPath(),Painter.ctx.ellipse(t,e,i,s,o,0,2*Math.PI),n&&(Painter.ctx.strokeStyle=n),void 0!==r&&(Painter.ctx.lineWidth=r),Painter.ctx.stroke()}static line(t,e,i,s,o,n){Painter.ctx.beginPath(),Painter.ctx.moveTo(t,e),Painter.ctx.lineTo(i,s),o&&(Painter.ctx.strokeStyle=o),void 0!==n&&(Painter.ctx.lineWidth=n),Painter.ctx.stroke()}static beginPath(){Painter.ctx.beginPath()}static moveTo(t,e){Painter.ctx.moveTo(t,e)}static lineTo(t,e){Painter.ctx.lineTo(t,e)}static bezierCurveTo(t,e,i,s,o,n){Painter.ctx.bezierCurveTo(t,e,i,s,o,n)}static closePath(){Painter.ctx.closePath()}static fill(t){t&&(Painter.ctx.fillStyle=t),Painter.ctx.fill()}static strokeOptions(t){t.color&&(Painter.ctx.strokeStyle=t.color),void 0!==t.lineWidth&&(Painter.ctx.lineWidth=t.lineWidth),t.lineCap&&(Painter.ctx.lineCap=t.lineCap),t.lineJoin&&(Painter.ctx.lineJoin=t.lineJoin),t.strokeStyle&&(Painter.ctx.strokeStyle=t.strokeStyle)}static stroke(t,e){t&&(Painter.ctx.strokeStyle=t),void 0!==e&&(Painter.ctx.lineWidth=e),Painter.ctx.stroke()}static polygon(t,e,i,s){if(!(t.length<2)){Painter.ctx.beginPath(),Painter.ctx.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++)Painter.ctx.lineTo(t[e].x,t[e].y);Painter.ctx.closePath(),e&&(Painter.ctx.fillStyle=e,Painter.ctx.fill()),i&&(Painter.ctx.strokeStyle=i,void 0!==s&&(Painter.ctx.lineWidth=s),Painter.ctx.stroke())}}static heart(t,e,i,s,o="#FF0055"){const n=i/2;Painter.ctx.save(),Painter.ctx.translate(t,e),Painter.ctx.beginPath(),Painter.ctx.moveTo(0,.3*s),Painter.ctx.bezierCurveTo(.5*-n,.3*-s,-n,.6*-s,0,-s),Painter.ctx.bezierCurveTo(n,.6*-s,.5*n,.3*-s,0,.3*s),Painter.ctx.closePath(),Painter.ctx.fillStyle=o,Painter.ctx.fill(),Painter.ctx.restore()}static setFont(t){Painter.ctx.font=t}static setTextAlign(t){Painter.ctx.textAlign=t}static setTextBaseline(t){Painter.ctx.textBaseline=t}static fillText(t,e,i,s,o){s&&(Painter.ctx.fillStyle=s),o&&(Painter.ctx.font=o),Painter.ctx.fillText(t,e,i)}static strokeText(t,e,i,s,o,n){s&&(Painter.ctx.strokeStyle=s),void 0!==o&&(Painter.ctx.lineWidth=o),n&&(Painter.ctx.font=n),Painter.ctx.strokeText(t,e,i)}static measureText(t){return Painter.ctx.measureText(t).width}static setFillColor(t){Painter.ctx.fillStyle=t}static setStrokeColor(t){Painter.ctx.strokeStyle=t}static setLineWidth(t){Painter.ctx.lineWidth=t}static rgba(t,e,i,s=1){return`rgba(${Math.round(t)}, ${Math.round(e)}, ${Math.round(i)}, ${s})`}static hsl(t,e,i){return`hsl(${t}, ${e}%, ${i}%)`}static hsla(t,e,i,s){return`hsla(${t}, ${e}%, ${i}%, ${s})`}static randomColorRGB(){const t=Math.floor(360*Math.random()),e=70+Math.floor(30*Math.random()),i=50+Math.floor(20*Math.random());return Painter.hslToRgb(t,e,i)}static randomColorHSL(){return`hsl(${360*Math.random()}, 100%, 50%)`}static randomColorHEX(){return"#"+(1048575*Math.random()*1e6).toString(16).slice(0,6)}static parseColorString(t){if((t=t.trim().toLowerCase()).startsWith("hsl")){const e=t.replace(/hsla?\(|\)/g,""),[i,s,o]=e.split(",").map((t=>t.trim())),n=parseFloat(i),r=parseFloat(s)/100,a=parseFloat(o)/100;return Painter.hslToRgb(n,r,a)}if(t.startsWith("#"))return hexToRgb(t);if(t.startsWith("rgb")){const e=t.replace(/rgba?\(|\)/g,""),[i,s,o]=e.split(",").map((t=>parseInt(t.trim())));return[i,s,o]}return[0,0,0]}static rgbArrayToCSS([t,e,i]){return`rgb(${Math.round(t)}, ${Math.round(e)}, ${Math.round(i)})`}static hslToRgb(t,e,i){const s=(1-Math.abs(2*i-1))*e,o=t/60,n=s*(1-Math.abs(o%2-1));let[r,a,h]=[0,0,0];o>=0&&o<1?[r,a,h]=[s,n,0]:o>=1&&o<2?[r,a,h]=[n,s,0]:o>=2&&o<3?[r,a,h]=[0,s,n]:o>=3&&o<4?[r,a,h]=[0,n,s]:o>=4&&o<5?[r,a,h]=[n,0,s]:o>=5&&o<6&&([r,a,h]=[s,0,n]);const l=i-s/2;return[255*(r+l),255*(a+l),255*(h+l)]}static hexToRgb(t){const e=t.replace("#","");return[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}static linearGradient(t,e,i,s,o){const n=Painter.ctx.createLinearGradient(t,e,i,s);for(const t of o)n.addColorStop(t.offset,t.color);return n}static radialGradient(t,e,i,s,o,n,r){const a=Painter.ctx.createRadialGradient(t,e,i,s,o,n);for(const t of r)a.addColorStop(t.offset,t.color);return a}static verticalGradient(t,e,i,s,o){return Painter.linearGradient(t,e,t,e+s,o)}static horizontalGradient(t,e,i,s,o){return Painter.linearGradient(t,e,t+i,e,o)}static setShadow(t,e,i=0,s=0){Painter.ctx.shadowColor=t,Painter.ctx.shadowBlur=e,Painter.ctx.shadowOffsetX=i,Painter.ctx.shadowOffsetY=s}static clearShadow(){Painter.ctx.shadowColor="rgba(0, 0, 0, 0)",Painter.ctx.shadowBlur=0,Painter.ctx.shadowOffsetX=0,Painter.ctx.shadowOffsetY=0}static setAlpha(t){Painter.ctx.globalAlpha=t}static setBlendMode(t){Painter.ctx.globalCompositeOperation=t}}const _Mouse=class t{static init(e){t.game=e,t.canvas=e.canvas,t.x=0,t.y=0,t.leftDown=!1,t.middleDown=!1,t.rightDown=!1,t.canvas.addEventListener("mousemove",t._onMove),t.canvas.addEventListener("mousedown",t._onDown),t.canvas.addEventListener("mouseup",t._onUp),t.canvas.addEventListener("click",t._onClick),t.canvas.addEventListener("wheel",t._onWheel)}static _updatePosition(e){const i=t.canvas.getBoundingClientRect();t.x=e.clientX-i.left,t.y=e.clientY-i.top}};__publicField(_Mouse,"_onMove",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("mousemove",t)})),__publicField(_Mouse,"_onDown",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!0),1===t.button&&(_Mouse.middleDown=!0),2===t.button&&(_Mouse.rightDown=!0),_Mouse.game.events.emit("mousedown",t)})),__publicField(_Mouse,"_onUp",(t=>{_Mouse._updatePosition(t),0===t.button&&(_Mouse.leftDown=!1),1===t.button&&(_Mouse.middleDown=!1),2===t.button&&(_Mouse.rightDown=!1),_Mouse.game.events.emit("mouseup",t)})),__publicField(_Mouse,"_onClick",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("click",t)})),__publicField(_Mouse,"_onWheel",(t=>{_Mouse._updatePosition(t),_Mouse.game.events.emit("wheel",t)}));let Mouse=_Mouse;const _Keys=class t{static init(e){t.game=e,window.addEventListener("keydown",t._onKeyDown),window.addEventListener("keyup",t._onKeyUp)}static isDown(e){return t._down.has(e)}static _onKeyDown(e){const i=t._codeMap[e.code];i&&(t._down.has(i)||(t._down.add(i),t.game.events.emit(i,e))),t.game.events.emit(e.type,e)}static _onKeyUp(e){const i=t._codeMap[e.code];i&&t._down.has(i)&&(t._down.delete(i),t.game.events.emit(i+"_up",e)),t.game.events.emit(e.type,e)}};__publicField(_Keys,"W","W"),__publicField(_Keys,"A","A"),__publicField(_Keys,"S","S"),__publicField(_Keys,"D","D"),__publicField(_Keys,"UP","UP"),__publicField(_Keys,"DOWN","DOWN"),__publicField(_Keys,"LEFT","LEFT"),__publicField(_Keys,"RIGHT","RIGHT"),__publicField(_Keys,"SPACE","SPACE"),__publicField(_Keys,"SHIFT","SHIFT"),__publicField(_Keys,"ENTER","ENTER"),__publicField(_Keys,"ESC","ESC"),__publicField(_Keys,"_codeMap",{KeyW:_Keys.W,KeyA:_Keys.A,KeyS:_Keys.S,KeyD:_Keys.D,ArrowUp:_Keys.UP,ArrowDown:_Keys.DOWN,ArrowLeft:_Keys.LEFT,ArrowRight:_Keys.RIGHT,Space:_Keys.SPACE,ShiftLeft:_Keys.SHIFT,ShiftRight:_Keys.SHIFT,Enter:_Keys.ENTER,NumpadEnter:_Keys.ENTER,Escape:_Keys.ESC}),__publicField(_Keys,"_down",new Set),__publicField(_Keys,"game",null);let Keys=_Keys;const _Touch=class t{static init(e){t.game=e,t.canvas=e.canvas,t.x=0,t.y=0,t.active=!1,t.canvas.addEventListener("touchstart",t._onStart),t.canvas.addEventListener("touchend",t._onEnd),t.canvas.addEventListener("touchmove",t._onMove)}static _updatePosition(e){const i=t.canvas.getBoundingClientRect();t.x=e.clientX-i.left,t.y=e.clientY-i.top}};__publicField(_Touch,"_onStart",(t=>{t.touches.length>0&&(_Touch.active=!0,_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchstart",t))})),__publicField(_Touch,"_onEnd",(t=>{_Touch.active=!1,_Touch.game.events.emit("touchend",t)})),__publicField(_Touch,"_onMove",(t=>{t.touches.length>0&&(_Touch._updatePosition(t.touches[0]),_Touch.game.events.emit("touchmove",t))}));let Touch=_Touch;const _Input=class t{static init(e){t.game=e,t.x=0,t.y=0,t.down=!1,e.events.on("mousedown",t._onDown),e.events.on("mouseup",t._onUp),e.events.on("mousemove",t._onMove),e.events.on("touchstart",t._onTouchStart),e.events.on("touchend",t._onTouchEnd),e.events.on("touchmove",t._onTouchMove)}static _setPosition(e,i){t.x=e,t.y=i}};__publicField(_Input,"_onDown",(t=>{_Input.down=!0,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onUp",(t=>{_Input.down=!1,_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onMove",(t=>{_Input._setPosition(t.offsetX,t.offsetY),_Input.game.events.emit("inputmove",t)})),__publicField(_Input,"_onTouchStart",(t=>{const e=t.touches[0],i=_Input.game.canvas.getBoundingClientRect();_Input.down=!0,_Input._setPosition(e.clientX-i.left,e.clientY-i.top),_Input.game.events.emit("inputdown",t)})),__publicField(_Input,"_onTouchEnd",(t=>{_Input.down=!1,_Input.game.events.emit("inputup",t)})),__publicField(_Input,"_onTouchMove",(t=>{const e=t.touches[0],i=_Input.game.canvas.getBoundingClientRect();_Input._setPosition(e.clientX-i.left,e.clientY-i.top),_Input.game.events.emit("inputmove",t)}));let Input=_Input;class EventEmitter{constructor(){this.listeners={}}on(t,e){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e)}off(t,e){this.listeners[t]&&(this.listeners[t]=this.listeners[t].filter((t=>t!==e)))}emit(t,e){this.listeners[t]&&this.listeners[t].forEach((t=>t(e)))}}function applyAnchor(t,e={}){var i;t.anchor=e.anchor??null,t.padding=e.padding??10;const s=t.game,o=null==(i=t.update)?void 0:i.bind(t);t.update=function(e){if(t.anchor){const{x:e,y:i,align:o,baseline:n}=((e,i)=>{const o=s.width,n=s.height;switch(e){case"top-left":return{x:i,y:i,align:"left",baseline:"top"};case"top-center":return{x:(o-t.width)/2,y:i,align:"center",baseline:"top"};case"top-right":return{x:o-t.width-i,y:i,align:"right",baseline:"top"};case"center-left":return{x:i,y:(n-t.height)/2,align:"left",baseline:"middle"};case"center":return{x:(o-t.width)/2,y:(n-t.height)/2,align:"center",baseline:"middle"};case"center-right":return{x:o-t.width-i,y:n/2,align:"right",baseline:"middle"};case"bottom-left":return{x:i,y:n-i,align:"left",baseline:"bottom"};case"bottom-center":return{x:(o-t.width)/2,y:n-t.height-i,align:"center",baseline:"bottom"};case"bottom-right":return{x:o-i,y:n-i,align:"right",baseline:"bottom"};default:return{x:10,y:10,align:"left",baseline:"top"}}})(t.anchor,t.padding);t.x=e,t.y=i,"align"in t&&(t.align=o),"baseline"in t&&(t.baseline=n)}null==o||o(e)}}class Transformable{constructor(t={}){this.options=t,this.x=t.x??0,this.y=t.y??0,this.width=t.width??0,this.height=t.height??0,this.rotation=t.rotation??0,this.scaleX=t.scaleX??1,this.scaleY=t.scaleY??1,this.opacity=t.opacity??1,this.visible=void 0===t.visible||t.visible}}class Shape extends Transformable{constructor(t,e,i={}){super(i),this.crisp=i.crisp??!0,this.x=t,this.y=e,this.fillColor=i.fillColor||null,this.strokeColor=i.strokeColor||null,this.lineWidth=i.lineWidth||1,this.shadowColor=i.shadowColor??null,this.shadowBlur=i.shadowBlur??0,this.shadowOffsetX=i.shadowOffsetX??0,this.shadowOffsetY=i.shadowOffsetY??0,this.minX=i.minX,this.maxX=i.maxX,this.minY=i.minY,this.maxY=i.maxY}applyConstraints(){void 0!==this.minX&&(this.x=Math.max(this.x,this.minX)),void 0!==this.maxX&&(this.x=Math.min(this.x,this.maxX)),void 0!==this.minY&&(this.y=Math.max(this.y,this.minY)),void 0!==this.maxY&&(this.y=Math.min(this.y,this.maxY)),this.crisp&&(this.x=Math.round(this.x),this.y=Math.round(this.y),this.width=Math.round(this.width),this.height=Math.round(this.height))}draw(){this.applyConstraints()}renderWithTransform(t){this.visible&&(Painter.ctx.save(),Painter.ctx.globalAlpha=this.opacity,Painter.ctx.translate(this.x,this.y),Painter.ctx.rotate(this.rotation),Painter.ctx.scale(this.scaleX,this.scaleY),t(),Painter.ctx.restore())}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class Arc extends Shape{constructor(t,e,i,s,o,n={}){super(t,e,n),this.radius=i,this.startAngle=s,this.endAngle=o}draw(){super.draw(),this.renderWithTransform((()=>{const t=Painter.ctx;t.beginPath(),t.arc(0,0,this.radius,this.startAngle,this.endAngle,!1),this.strokeColor&&(t.strokeStyle=this.strokeColor,t.lineWidth=this.lineWidth,t.stroke())}))}getBounds(){const t=this.radius;return{x:this.x,y:this.y,width:2*t,height:2*t}}}class Circle extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.radius=i}draw(){super.draw(),this.renderWithTransform((()=>{this.fillColor&&Painter.fillCircle(0,0,this.radius,this.fillColor),this.strokeColor&&Painter.strokeCircle(0,0,this.radius,this.strokeColor,this.lineWidth)}))}getBounds(){const t=2*this.radius;return{x:this.x,y:this.y,width:t,height:t}}}class Cloud extends Shape{constructor(t,e,i=40,s={}){super(t,e,s),this.size=i}draw(){super.draw();const t=this.size,e=[["M",-t,0],["C",-t,-t,0,-t,0,0],["C",0,1.2*-t,1.2*t,-t,t,0],["C",1.5*t,.5*t,.5*t,1.2*t,0,t],["C",.8*-t,1.3*t,1.2*-t,.3*t,-t,0],["Z"]];this.renderWithTransform((()=>{Painter.path(e,this.fillColor,this.strokeColor,this.lineWidth)}))}getBounds(){const t=2*this.size;return{x:this.x,y:this.y,width:t,height:t}}}class BezierShape extends Shape{constructor(t,e,i=[],s={}){super(t,e,s),this.path=i}draw(){super.draw(),this.renderWithTransform((()=>{Painter.path(this.path,this.fillColor,this.strokeColor,this.lineWidth)}))}getBounds(){return{x:this.x,y:this.y,width:100,height:100}}}class Rectangle extends Shape{constructor(t,e,i,s,o={}){super(t,e,o),this.width=i,this.height=s}draw(){super.draw(),this.renderWithTransform((()=>{const t=-this.width/2,e=-this.height/2;this.fillColor&&Painter.fillRect(t,e,this.width,this.height,this.fillColor),this.strokeColor&&Painter.strokeRect(t,e,this.width,this.height,this.strokeColor,this.lineWidth)}))}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class Square extends Rectangle{constructor(t,e,i,s={}){super(t,e,i,i,s)}}class Cube extends Shape{constructor(t,e,i=50,s={}){super(t,e,s),this.size=i,this.faceTopColor=s.faceTopColor||"#eee",this.faceBottomColor=s.faceBottomColor||"#ccc",this.faceLeftColor=s.faceLeftColor||"#aaa",this.faceRightColor=s.faceRightColor||"#888",this.faceFrontColor=s.faceFrontColor||"#666",this.faceBackColor=s.faceBackColor||"#444",this.strokeColor=s.strokeColor||null,this.lineWidth=s.lineWidth||1,this.rotationX=s.rotationX||0,this.rotationY=s.rotationY||0,this.rotationZ=s.rotationZ||0,this.visibleFaces=s.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.size/2,e=(t,e,i)=>{let s=e,o=i;e=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=i=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),i=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=e,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},i=(t,i,s)=>{const o=e(t,i,s);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z}},s={p0:i(-t,-t,-t),p1:i(t,-t,-t),p2:i(t,t,-t),p3:i(-t,t,-t),p4:i(-t,-t,t),p5:i(t,-t,t),p6:i(t,t,t),p7:i(-t,t,t)},o={top:{points:[s.p4,s.p5,s.p6,s.p7],color:this.faceTopColor,normal:[0,0,1]},bottom:{points:[s.p0,s.p1,s.p2,s.p3],color:this.faceBottomColor,normal:[0,0,-1]},left:{points:[s.p0,s.p4,s.p7,s.p3],color:this.faceLeftColor,normal:[-1,0,0]},right:{points:[s.p1,s.p5,s.p6,s.p2],color:this.faceRightColor,normal:[1,0,0]},front:{points:[s.p0,s.p1,s.p5,s.p4],color:this.faceFrontColor,normal:[0,-1,0]},back:{points:[s.p3,s.p2,s.p6,s.p7],color:this.faceBackColor,normal:[0,1,0]}},n=this.visibleFaces.map((t=>{const e=o[t];if(!e)return null;const i=e.points.reduce(((t,e)=>({x:t.x+e.x,y:t.y+e.y})),{x:0,y:0});i.x/=e.points.length,i.y/=e.points.length;return{key:t,face:e,depth:i.x*i.x+i.y*i.y}})).filter((t=>null!==t)).sort(((t,e)=>e.depth-t.depth));this.renderWithTransform((()=>{n.forEach((({key:t,face:e})=>{(null==e?void 0:e.color)&&Painter.polygon(e.points,e.color,this.strokeColor,this.lineWidth)}))}))}getBounds(){const t=1.5*this.size;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cone extends Shape{constructor(t,e,i=50,s=100,o={}){super(t,e,o),this.radius=i,this.height=s,this.segments=o.segments||24,this.bottomColor=o.bottomColor||"#eee",this.sideColor=o.sideColor||"#aaa",this.strokeColor=o.strokeColor||null,this.lineWidth=o.lineWidth||1,this.rotationX=o.rotationX||0,this.rotationY=o.rotationY||0,this.rotationZ=o.rotationZ||0,this.visibleFaces=o.visibleFaces||["bottom","side"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.radius,e=this.height/2,i=(t,e,i)=>{let s=e,o=i;e=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=i=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),i=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=e,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},s=(t,e,s)=>{const o=i(t,e,s);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z,z:o.z}},o=s(0,0,e),n=[],r=2*Math.PI/this.segments;for(let i=0;i<this.segments;i++){const o=i*r,a=Math.cos(o)*t,h=Math.sin(o)*t;n.push(s(a,h,-e))}const a=[];for(let t=0;t<this.segments;t++){const e=(t+1)%this.segments;a.push({points:[o,n[t],n[e]],z:(o.z+n[t].z+n[e].z)/3})}const h=[];this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...n].reverse(),z:-e}),this.visibleFaces.includes("side")&&h.push(...a.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,e)=>e.z-t.z)),this.renderWithTransform((()=>{for(const t of h){const e="bottom"===t.type?this.bottomColor:this.sideColor;Painter.polygon(t.points,e,this.strokeColor,this.lineWidth)}}))}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Prism extends Shape{constructor(t,e,i=80,s=60,o=100,n={}){super(t,e,n),this.width=i,this.height=s,this.depth=o,this.faceTopColor=n.faceTopColor||"#eee",this.faceBottomColor=n.faceBottomColor||"#ccc",this.faceLeftColor=n.faceLeftColor||"#aaa",this.faceRightColor=n.faceRightColor||"#888",this.faceFrontColor=n.faceFrontColor||"#666",this.faceBackColor=n.faceBackColor||"#444",this.strokeColor=n.strokeColor||null,this.lineWidth=n.lineWidth||1,this.rotationX=n.rotationX||0,this.rotationY=n.rotationY||0,this.rotationZ=n.rotationZ||0,this.visibleFaces=n.visibleFaces||["top","left","right","front","back","bottom"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.width/2,e=this.height/2,i=this.depth/2,s=(t,e,i)=>{let s=e,o=i;e=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=i=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),i=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=e,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},o=(t,e,i)=>{const o=s(t,e,i);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z,z:o.z}},n={p0:o(-t,-i,-e),p1:o(t,-i,-e),p2:o(0,-i,e),p3:o(-t,i,-e),p4:o(t,i,-e),p5:o(0,i,e)},r={front:{points:[n.p0,n.p1,n.p2],color:this.faceFrontColor},back:{points:[n.p3,n.p4,n.p5],color:this.faceBackColor},bottom:{points:[n.p0,n.p1,n.p4,n.p3],color:this.faceBottomColor},right:{points:[n.p1,n.p2,n.p5,n.p4],color:this.faceRightColor},left:{points:[n.p0,n.p2,n.p5,n.p3],color:this.faceLeftColor}},a=this.visibleFaces.filter((t=>r[t])).map((t=>{const e=r[t],i=e.points.reduce(((t,e)=>t+e.x),0)/e.points.length,s=e.points.reduce(((t,e)=>t+e.y),0)/e.points.length,o=e.points.reduce(((t,e)=>t+(e.z||0)),0)/e.points.length;return{key:t,face:e,depth:i*i+s*s+o*o}})).sort(((t,e)=>e.depth-t.depth));this.renderWithTransform((()=>{a.forEach((({key:t,face:e})=>{(null==e?void 0:e.color)&&Painter.polygon(e.points,e.color,this.strokeColor,this.lineWidth)}))}))}getBounds(){const t=1.5*Math.max(this.width,this.height,this.depth);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Cylinder extends Shape{constructor(t,e,i=40,s=80,o={}){super(t,e,o),this.radius=i,this.height=s,this.segments=o.segments||24,this.topColor=o.topColor||"#FF00FF",this.bottomColor=o.bottomColor||"#FF0FFF",this.sideColor=o.sideColor||"#00FF00",this.strokeColor=o.strokeColor||"#000000",this.lineWidth=o.lineWidth||1,this.rotationX=o.rotationX||0,this.rotationY=o.rotationY||0,this.rotationZ=o.rotationZ||0,this.visibleFaces=o.visibleFaces||["top","bottom","side"]}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}draw(){super.draw();const t=this.radius,e=this.height/2,i=(t,e,i)=>{let s=e,o=i;e=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=i=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),i=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=e,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},s=(t,e,s)=>{const o=i(t,e,s);return{x:(o.x-o.y)*Math.cos(Math.PI/6),y:(o.x+o.y)*Math.sin(Math.PI/6)-o.z,z:o.z}},o=[],n=[],r=2*Math.PI/this.segments;for(let i=0;i<this.segments;i++){const a=i*r,h=Math.cos(a)*t,l=Math.sin(a)*t;o.push(s(h,l,e)),n.push(s(h,l,-e))}const a=[];for(let t=0;t<this.segments;t++){const e=(t+1)%this.segments;a.push({points:[n[t],n[e],o[e],o[t]],z:(o[t].z+o[e].z+n[t].z+n[e].z)/4})}const h=[];this.visibleFaces.includes("top")&&h.push({type:"top",points:o,z:e}),this.visibleFaces.includes("bottom")&&h.push({type:"bottom",points:[...n].reverse(),z:-e}),this.visibleFaces.includes("side")&&h.push(...a.map((t=>({type:"side",points:t.points,z:t.z})))),h.sort(((t,e)=>e.z-t.z)),this.renderWithTransform((()=>{for(const t of h){let e;switch(t.type){case"top":e=this.topColor;break;case"bottom":e=this.bottomColor;break;case"side":e=this.sideColor}Painter.polygon(t.points,e,this.strokeColor,this.lineWidth)}}))}getBounds(){const t=1.5*Math.max(2*this.radius,this.height);return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class Diamond extends Shape{constructor(t,e,i,s,o={}){super(t,e,o),this.width=i,this.height=s}draw(){super.draw(),this.renderWithTransform((()=>{const t=this.width/2,e=this.height/2,i=[{x:0,y:-e},{x:t,y:0},{x:0,y:e},{x:-t,y:0}];Painter.polygon(i,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Line extends Shape{constructor(t,e,i=40,s={}){super(t,e,s),this.length=i}draw(){super.draw();const t=this.length/2;this.renderWithTransform((()=>{Painter.line(-t,-t,t,t,this.strokeColor,this.lineWidth)}))}}class Triangle extends Shape{constructor(t,e,i=50,s={}){super(t,e,s),this.size=i}draw(){super.draw();const t=this.size/2,e=[{x:0,y:-t},{x:t,y:t},{x:-t,y:t}];this.renderWithTransform((()=>{Painter.polygon(e,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Star extends Shape{constructor(t,e,i=40,s=5,o=.5,n={}){super(t,e,n),this.radius=i,this.spikes=s,this.inset=o}draw(){super.draw();const t=Math.PI/this.spikes,e=-Math.PI/2;this.renderWithTransform((()=>{Painter.ctx.beginPath();for(let i=0;i<2*this.spikes;i++){const s=i%2==0?this.radius:this.radius*this.inset,o=i*t+e,n=Math.cos(o)*s,r=Math.sin(o)*s;0===i?Painter.ctx.moveTo(n,r):Painter.ctx.lineTo(n,r)}Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Sphere extends Shape{constructor(t,e,i=50,s={}){super(t,e,s),this.radius=i,this.hSegments=s.hSegments||16,this.vSegments=s.vSegments||12,this.color=s.color||"#6495ED",this.highlightColor=s.highlightColor||"#FFFFFF",this.wireframe=s.wireframe||!1,this.strokeColor=s.strokeColor||"#333333",this.lineWidth=s.lineWidth||1,this.rotationX=s.rotationX||0,this.rotationY=s.rotationY||0,this.rotationZ=s.rotationZ||0}setRotation(t,e,i){return this.rotationX=t,this.rotationY=e,this.rotationZ=i,this}rotate(t,e,i){return this.rotationX+=t,this.rotationY+=e,this.rotationZ+=i,this}calculateSurfaceColor(t,e,i){let s=t*(1/Math.sqrt(3))+e*(1/Math.sqrt(3))+i*(1/Math.sqrt(3));if(s=Math.max(.3,s),this.highlightColor){const t=this.hexToRgb(this.color),e=this.hexToRgb(this.highlightColor);return`rgb(${Math.round(t.r*(1-s)+e.r*s)}, ${Math.round(t.g*(1-s)+e.g*s)}, ${Math.round(t.b*(1-s)+e.b*s)})`}const o=this.hexToRgb(this.color);return`rgb(${Math.min(255,Math.round(o.r*s))}, ${Math.min(255,Math.round(o.g*s))}, ${Math.min(255,Math.round(o.b*s))})`}hexToRgb(t){const e={r:100,g:100,b:255};if(!t||"string"!=typeof t)return e;const i=t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,((t,e,i,s)=>e+e+i+i+s+s)),s=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(i);return s?{r:parseInt(s[1],16),g:parseInt(s[2],16),b:parseInt(s[3],16)}:e}draw(){super.draw();const t=this.radius,e=(t,e,i)=>{let s=e,o=i;e=s*Math.cos(this.rotationX)-o*Math.sin(this.rotationX);let n=t;return o=i=s*Math.sin(this.rotationX)+o*Math.cos(this.rotationX),t=n*Math.cos(this.rotationY)+o*Math.sin(this.rotationY),i=-n*Math.sin(this.rotationY)+o*Math.cos(this.rotationY),n=t,s=e,{x:t=n*Math.cos(this.rotationZ)-s*Math.sin(this.rotationZ),y:e=n*Math.sin(this.rotationZ)+s*Math.cos(this.rotationZ),z:i}},i=(i,s,o)=>{const n=e(i,s,o);return{x:(n.x-n.y)*Math.cos(Math.PI/6),y:(n.x+n.y)*Math.sin(Math.PI/6)-n.z,z:n.z,nx:n.x/t,ny:n.y/t,nz:n.z/t}},s=[];for(let e=0;e<=this.vSegments;e++){const o=[],n=e/this.vSegments,r=Math.PI*n-Math.PI/2;for(let e=0;e<=this.hSegments;e++){const s=e/this.hSegments,n=2*Math.PI*s,a=t*Math.cos(r)*Math.cos(n),h=t*Math.cos(r)*Math.sin(n),l=t*Math.sin(r);o.push(i(a,h,l))}s.push(o)}const o=[];for(let t=0;t<this.vSegments;t++)for(let e=0;e<this.hSegments;e++){const i=s[t][e],n=s[t][e+1],r=s[t+1][e],a=s[t+1][e+1],h=(i.z+n.z+r.z+a.z)/4,l=(i.nx+n.nx+r.nx+a.nx)/4,c=(i.ny+n.ny+r.ny+a.ny)/4,d=(i.nz+n.nz+r.nz+a.nz)/4;o.push({points:[i,n,a,r],z:h,color:this.calculateSurfaceColor(l,c,d)})}o.sort(((t,e)=>e.z-t.z)),this.renderWithTransform((()=>{if(this.wireframe)for(const t of o){const e=t.points;for(let t=0;t<e.length;t++){const i=(t+1)%e.length;Painter.line(e[t].x,e[t].y,e[i].x,e[i].y,this.strokeColor,this.lineWidth)}}else for(const t of o)Painter.polygon(t.points,t.color,this.strokeColor,this.lineWidth)}))}getBounds(){const t=2*this.radius*1.5;return{x:this.x-t/2,y:this.y-t/2,width:t,height:t}}}class StickFigure extends Shape{constructor(t,e,i=1,s={}){super(t,e,s),this.scale=i,this.strokeColor=s.strokeColor||"#000",this.headColor=s.headColor||this.strokeColor,this.jointColor=s.jointColor||this.strokeColor,this.lineWidth=s.lineWidth||2,this.showJoints=!1!==s.showJoints}draw(){super.draw();const t=this.scale,e=10*t,i=-30*t,s=i+e,o=s+40*t,n=s+10*t,r=15*t,a=10*t,h=o+40*t,l=3*t;this.renderWithTransform((()=>{if(Painter.fillCircle(0,i,e,this.headColor),Painter.strokeCircle(0,i,e,this.strokeColor,this.lineWidth),Painter.line(0,s,0,o,this.strokeColor,this.lineWidth),Painter.line(-r,n,r,n,this.strokeColor,this.lineWidth),Painter.line(0,o,-a,h,this.strokeColor,this.lineWidth),Painter.line(0,o,a,h,this.strokeColor,this.lineWidth),this.showJoints){[[0,s],[-r,n],[r,n],[0,o],[-a,h],[a,h]].forEach((([t,e])=>Painter.fillCircle(t,e,l,this.jointColor)))}}))}getBounds(){const t=100*this.scale,e=40*this.scale;return{x:this.x,y:this.y,width:e,height:t}}}class Ring extends Shape{constructor(t,e,i,s,o={}){super(t,e,o),this.outerRadius=i,this.innerRadius=s}draw(){super.draw(),this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.arc(0,0,this.outerRadius,0,2*Math.PI),Painter.ctx.arc(0,0,this.innerRadius,0,2*Math.PI,!0),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Polygon extends Shape{constructor(t,e,i=6,s=40,o={}){super(t,e,o),this.sides=i,this.radius=s}draw(){super.draw();const t=[],e=2*Math.PI/this.sides;for(let i=0;i<this.sides;i++){const s=i*e;t.push({x:Math.cos(s)*this.radius,y:Math.sin(s)*this.radius})}this.renderWithTransform((()=>{Painter.polygon(t,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Arrow extends Shape{constructor(t,e,i,s,o={}){super(t,e,o),this.length=i,this.width=s}draw(){super.draw();const t=this.width/2,e=.4*this.length,i=this.length-e;this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.moveTo(-i/2,-t),Painter.ctx.lineTo(i/2,-t),Painter.ctx.lineTo(i/2,-this.width),Painter.ctx.lineTo(this.length/2,0),Painter.ctx.lineTo(i/2,this.width),Painter.ctx.lineTo(i/2,t),Painter.ctx.lineTo(-i/2,t),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Pin extends Shape{constructor(t,e,i=20,s={}){super(t,e,s),this.radius=i}draw(){super.draw();const t=this.radius,e=2.5*t;this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.arc(0,0,t,Math.PI,0),Painter.ctx.lineTo(t,0),Painter.ctx.lineTo(0,e),Painter.ctx.lineTo(-t,0),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}getBounds(){return{x:this.x,y:this.y+.98*this.radius,width:2*this.radius,height:2.5*this.radius}}}class PieSlice extends Shape{constructor(t,e,i,s,o,n={}){super(t,e,n),this.radius=i,this.startAngle=s,this.endAngle=o}draw(){super.draw(),this.renderWithTransform((()=>{Painter.ctx.beginPath(),Painter.ctx.moveTo(0,0),Painter.ctx.arc(0,0,this.radius,this.startAngle,this.endAngle),Painter.ctx.closePath(),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Hexagon extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.radius=i}draw(){super.draw();const t=Array.from({length:6},((t,e)=>{const i=Math.PI/3*e;return{x:Math.cos(i)*this.radius,y:Math.sin(i)*this.radius}}));this.renderWithTransform((()=>{Painter.polygon(t,this.fillColor,this.strokeColor,this.lineWidth)}))}}class Heart extends Shape{constructor(t,e,i=50,s=50,o={}){super(t,e,o),this.width=i,this.height=s}draw(){super.draw();const t=this.width,e=this.height,i=.3*e;this.renderWithTransform((()=>{const s=Painter.ctx;s.beginPath(),s.moveTo(0,i),s.bezierCurveTo(0,0,-t/2,0,-t/2,i),s.bezierCurveTo(-t/2,.8*e,0,e,0,e),s.bezierCurveTo(0,e,t/2,.8*e,t/2,i),s.bezierCurveTo(t/2,0,0,0,0,i),s.closePath(),this.fillColor&&(s.fillStyle=this.fillColor,s.fill()),this.strokeColor&&(s.strokeStyle=this.strokeColor,s.lineWidth=this.lineWidth,s.stroke())}))}getBounds(){return{x:this.x,y:this.y+this.height/2,width:this.width,height:this.height}}}class Cross extends Shape{constructor(t,e,i,s,o={}){super(t,e,o),this.size=i,this.thickness=s,this.diagonal=o.diagonal||!1}draw(){super.draw(),this.renderWithTransform((()=>{const t=this.size/2,e=this.thickness/2;this.diagonal?(Painter.ctx.beginPath(),Painter.ctx.moveTo(-t,-t+e),Painter.ctx.lineTo(-t+e,-t),Painter.ctx.lineTo(0,-e),Painter.ctx.lineTo(t-e,-t),Painter.ctx.lineTo(t,-t+e),Painter.ctx.lineTo(e,0),Painter.ctx.lineTo(t,t-e),Painter.ctx.lineTo(t-e,t),Painter.ctx.lineTo(0,e),Painter.ctx.lineTo(-t+e,t),Painter.ctx.lineTo(-t,t-e),Painter.ctx.lineTo(-e,0),Painter.ctx.closePath()):(Painter.ctx.beginPath(),Painter.ctx.moveTo(-e,-t),Painter.ctx.lineTo(e,-t),Painter.ctx.lineTo(e,-e),Painter.ctx.lineTo(t,-e),Painter.ctx.lineTo(t,e),Painter.ctx.lineTo(e,e),Painter.ctx.lineTo(e,t),Painter.ctx.lineTo(-e,t),Painter.ctx.lineTo(-e,e),Painter.ctx.lineTo(-t,e),Painter.ctx.lineTo(-t,-e),Painter.ctx.lineTo(-e,-e),Painter.ctx.closePath()),this.fillColor&&(Painter.ctx.fillStyle=this.fillColor,Painter.ctx.fill()),this.strokeColor&&(Painter.ctx.strokeStyle=this.strokeColor,Painter.ctx.lineWidth=this.lineWidth,Painter.ctx.stroke())}))}}class Group extends Shape{constructor(t,e,i={}){super(t,e,i),this.children=[]}add(t){this.children=[...this.children,t]}remove(t){this.children=this.children.filter((e=>e!==t))}removeMutable(t){const e=this.children.indexOf(t);-1!==e&&this.children.splice(e,1)}clear(){this.children=[]}draw(){this.renderWithTransform((()=>{this.children.forEach((t=>t.draw()))}))}getBounds(){if(0===this.children.length)return null;const t=this.children.map((t=>{const e="function"==typeof t.getBounds?t.getBounds():null;if(!e)return null;const i=e.width/2,s=e.height/2;return{minX:e.x-i,maxX:e.x+i,minY:e.y-s,maxY:e.y+s}})).filter((t=>null!==t));if(0===t.length)return null;const e=Math.min(...t.map((t=>t.minX))),i=Math.max(...t.map((t=>t.maxX))),s=Math.min(...t.map((t=>t.minY))),o=i-e,n=Math.max(...t.map((t=>t.maxY)))-s,r=e+o/2,a=s+n/2;return{x:this.x+r,y:this.y+a,width:o,height:n}}}class TextShape extends Shape{constructor(t,e,i,s={}){super(t,e,s),this.text=i,this.font=s.font||"12px monospace",this.color=s.color||"#000",this.align=s.align||"center",this.baseline=s.baseline||"top"}draw(){super.draw(),this.renderWithTransform((()=>{Painter.setFont(this.font),Painter.setTextAlign(this.align),Painter.setTextBaseline(this.baseline),Painter.fillText(this.text,0,0,this.color)}))}getBounds(){return this.width=Painter.measureText(this.text),{x:this.x,y:this.y,width:this.width,height:parseInt(this.font)}}}const index=Object.freeze(Object.defineProperty({__proto__:null,Arc:Arc,Arrow:Arrow,BezierShape:BezierShape,Circle:Circle,Cloud:Cloud,Cone:Cone,Cross:Cross,Cube:Cube,Cylinder:Cylinder,Diamond:Diamond,Group:Group,Heart:Heart,Hexagon:Hexagon,Line:Line,PieSlice:PieSlice,Pin:Pin,Polygon:Polygon,Prism:Prism,Rectangle:Rectangle,Ring:Ring,Shape:Shape,Sphere:Sphere,Square:Square,Star:Star,StickFigure:StickFigure,TextShape:TextShape,Transformable:Transformable,Triangle:Triangle},Symbol.toStringTag,{value:"Module"}));class GameObject extends Transformable{constructor(t,e={}){super(e),this.game=t,this.ctx=t.ctx,this.active=!0,this.events=new EventEmitter,this.interactive=!1,this.parent=null,applyAnchor(this,e)}enableInteractivity(t){this.interactive=!0,this.shape=t,this._hovered=!1}_hitTest(t,e){var i,s,o;const n=(null==(s=null==(i=this.shape)?void 0:i.getBounds)?void 0:s.call(i))??(null==(o=this.getBounds)?void 0:o.call(this));if(!n)return!1;const{x:r,y:a,width:h,height:l}=n,c=h/2,d=l/2;return t>=r-c&&t<=r+c&&e>=a-d&&e<=a+d}on(t,e){this.events.on(t,e)}off(t,e){this.events.off(t,e)}update(t){}render(){}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class ShapeGOFactory{static create(t,e){const i={x:(null==e?void 0:e.x)??0,y:(null==e?void 0:e.y)??0,width:(null==e?void 0:e.width)??0,height:(null==e?void 0:e.height)??0};return new class extends GameObject{constructor(){super(t,i),this.shape=e}update(t){this.shape&&this.active&&(this.shape.x=this.x,this.shape.y=this.y,this.shape.width=this.width,this.shape.height=this.height,this.shape.opacity=this.opacity,this.shape.visible=this.visible,this.shape.scaleX=this.scaleX,this.shape.scaleY=this.scaleY)}render(){this.shape&&this.visible&&this.shape.draw()}}}}class Scene extends GameObject{constructor(t,e={}){super(t,e),this.children=[],this.x=e.x??0,this.y=e.y??0}add(t){return t.parent=this,this.children.push(t),t}remove(t){this.children=this.children.filter((e=>e!==t)),t.parent=null}clear(){this.children=[]}bringToFront(t){this.remove(t),this.children.push(t)}sendToBack(t){this.remove(t),this.children.unshift(t)}update(t){for(let e of this.children){"number"==typeof e.x&&(e.x+=this.x),"number"==typeof e.y&&(e.y+=this.y);const i=e.opacity??1;e.opacity=this.opacity*i;const s=e.scaleX??1,o=e.scaleY??1;e.scaleX*=this.scaleX,e.scaleY*=this.scaleY;const n=e.rotation??0;e.rotation+=this.rotation,e.update&&e.update(t),e.opacity=i,e.rotation=n,e.scaleX=s,e.scaleY=o,"number"==typeof e.x&&(e.x-=this.x),"number"==typeof e.y&&(e.y-=this.y)}}render(){if(this.visible&&!(this.opacity<=0))for(let t of this.children)t.render&&t.render()}}class Text extends GameObject{constructor(t,e,i={}){super(t,i),this.text=e,this.x=i.x||0,this.y=i.y||0,this.font=i.font||"16px monospace",this.color=i.color||"#fff",this.align=i.align||"left",this.baseline=i.baseline||"top",this.stroke=i.stroke||!1,this.strokeColor=i.strokeColor||"#000",this.lineWidth=i.lineWidth||1}render(){Painter.setFont(this.font),Painter.setTextAlign(this.align),Painter.setTextBaseline(this.baseline),this.stroke&&Painter.strokeText(this.text,this.x,this.y,this.strokeColor,this.lineWidth,this.font),Painter.fillText(this.text,this.x,this.y,this.color,this.font)}}class Tween{static go(t,e,i){return t+(e-t)*i}static tweenColor(t,e,i){return t.map(((t,s)=>Tween.go(t,e[s],i)))}static tweenGradient(t,e,i){let s=t[0],o=e[0];Math.abs(o-s)>180&&(s<o?s+=360:o+=360);return[Tween.go(s,o,i)%360,Tween.go(t[1],e[1],i),Tween.go(t[2],e[2],i)]}static easeInQuad(t){return t*t}static easeOutQuad(t){return t*(2-t)}static easeInOutQuad(t){return t<.5?2*t*t:(4-2*t)*t-1}static easeInCubic(t){return t*t*t}static easeOutCubic(t){return--t*t*t+1}static easeInOutCubic(t){return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1}static easeInQuart(t){return t*t*t*t}static easeOutQuart(t){return 1- --t*t*t*t}static easeInOutQuart(t){return t<.5?8*t*t*t*t:1-8*--t*t*t*t}static easeInSine(t){return 1-Math.cos(t*Math.PI/2)}static easeOutSine(t){return Math.sin(t*Math.PI/2)}static easeInOutSine(t){return-(Math.cos(Math.PI*t)-1)/2}static easeInExpo(t){return 0===t?0:Math.pow(2,10*(t-1))}static easeOutExpo(t){return 1===t?1:1-Math.pow(2,-10*t)}static easeInOutExpo(t){return 0===t||1===t?t:t<.5?.5*Math.pow(2,20*t-10):.5*(2-Math.pow(2,-20*t+10))}static easeInCirc(t){return 1-Math.sqrt(1-t*t)}static easeOutCirc(t){return Math.sqrt(1- --t*t)}static easeInOutCirc(t){return t<.5?.5*(1-Math.sqrt(1-4*t*t)):.5*(Math.sqrt(-(2*t-3)*(2*t-1))+1)}static easeInElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return-e*Math.pow(2,10*(t-1))*Math.sin((t-1-s)*(2*Math.PI)/i)}static easeOutElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return e*Math.pow(2,-10*t)*Math.sin((t-s)*(2*Math.PI)/i)+1}static easeInOutElastic(t,e=1,i=.3){if(0===t||1===t)return t;const s=i/(2*Math.PI)*Math.asin(1/e);return t<.5?e*Math.pow(2,10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/i)*-.5:e*Math.pow(2,-10*(2*t-1))*Math.sin((2*t-1-s)*(2*Math.PI)/i)*.5+1}static easeInBack(t,e=1.70158){return t*t*((e+1)*t-e)}static easeOutBack(t,e=1.70158){return--t*t*((e+1)*t+e)+1}static easeInOutBack(t,e=1.70158){const i=1.525*e;return t<.5?2*t*.5*(2*t)*(2*(i+1)*t-i):.5*((2*t-2)*(2*t-2)*((i+1)*(2*t-2)+i)+2)}static easeOutBounce(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}static easeInBounce(t){return 1-Tween.easeOutBounce(1-t)}static easeInOutBounce(t){return t<.5?.5*Tween.easeInBounce(2*t):.5*Tween.easeOutBounce(2*t-1)+.5}static parabolicArc(t,e,i,s){return(t+i-2*e)*s*s+2*(e-t)*s+t}static oscillate(t,e,i,s=1){const o=(e-t)/2;return t+o+o*Math.sin(i*Math.PI*2/s)}static pulse(t,e,i){return t+(e-t)*(i<.5?2*i:2-2*i)}static spring(t,e,{velocity:i=0,stiffness:s=.1,damping:o=.8,precision:n=.01}={}){const r=e-t,a=t+(i=i*o+r*s),h=Math.abs(r)<n&&Math.abs(i)<n;return{value:h?e:a,velocity:i,done:h}}static spiral(t,e,i,s,o,n,r){const a=Tween.go(i,s,r),h=o+r*n*Math.PI*2;return{x:t+a*Math.cos(h),y:e+a*Math.sin(h)}}static orbit(t,e,i,s,o,n,r=!0){const a=o+(r?1:-1)*n*Math.PI*2;return{x:t+i*Math.cos(a),y:e+s*Math.sin(a)}}static bezier(t,e,i,s,o){const n=3*(e[0]-t[0]),r=3*(i[0]-e[0])-n,a=s[0]-t[0]-n-r,h=3*(e[1]-t[1]),l=3*(i[1]-e[1])-h,c=s[1]-t[1]-h-l;return{x:a*Math.pow(o,3)+r*Math.pow(o,2)+n*o+t[0],y:c*Math.pow(o,3)+l*Math.pow(o,2)+h*o+t[1]}}static bounce(t,e,i,s){const o=1/(i+1),n=Math.min(Math.floor(s/o),i),r=s%o/o,a=t*Math.pow(.6,n);return e-Math.sin(r*Math.PI)*(e-a)}static shake(t,e,i,s,o,n,r){const a=Math.pow(1-r,n),h=r*Math.PI*2*o,l=r*Math.PI*2*o*1.3,c=a*i*(.6*Math.sin(h)+.3*Math.sin(2.5*h)+.1*Math.sin(5.6*h)),d=a*s*(.6*Math.cos(l)+.3*Math.cos(2.7*l)+.1*Math.cos(6.3*l));let u=t+c,p=e+d;if(r>.9){const i=(r-.9)/.1;u=t+c*(1-i),p=e+d*(1-i)}return{x:u,y:p}}}class Tweenetik{constructor(t,e,i,s,o={}){this.target=t,this.toProps={...e},this.duration=i,this.easingFn=s||Tween.easeOutQuad,this.delay=o.delay||0,this.onStart=o.onStart||null,this.onComplete=o.onComplete||null,this.onUpdate=o.onUpdate||null,this._elapsed=0,this._started=!1,this._finished=!1,this._startProps={};for(const t in this.toProps)Object.prototype.hasOwnProperty.call(this.target,t)&&(this._startProps[t]=this.target[t])}static to(t,e,i,s,o){const n=new Tweenetik(t,e,i,s,o);return Tweenetik._active.push(n),n}update(t){if(this._finished)return;if(this._elapsed+=t,this._elapsed<this.delay)return;const e=this._elapsed-this.delay,i=Math.min(e/this.duration,1);!this._started&&i>0&&(this._started=!0,this.onStart&&this.onStart());const s=this.easingFn(i);for(const t in this._startProps){const e=this._startProps[t],i=this.toProps[t];this.target[t]=Tween.go(e,i,s)}this.onUpdate&&this.onUpdate(),i>=1&&(this._finished=!0,this.onComplete&&this.onComplete())}static updateAll(t){for(const e of Tweenetik._active)e.update(t);Tweenetik._active=Tweenetik._active.filter((t=>!t._finished))}}Tweenetik._active=[];class Pipeline{constructor(t){this.game=t,this.gameObjects=[];["inputdown","inputup","inputmove"].forEach((t=>{this.game.events.on(t,(e=>{this.dispatchInputEvent(t,e)}))}))}_hoverObject(t,e){if(!t.interactive||!t._hitTest)return;const i=t._hitTest(e.x,e.y);i&&!t._hovered?(t._hovered=!0,t.events.emit("mouseover",e)):!i&&t._hovered&&(t._hovered=!1,t.events.emit("mouseout",e))}_hoverScene(t,e){for(let i=t.children.length-1;i>=0;i--){const s=t.children[i];s instanceof Scene?this._hoverScene(s,e):this._hoverObject(s,e)}}dispatchInputEvent(t,e){var i;for(let s=this.gameObjects.length-1;s>=0;s--){const o=this.gameObjects[s];if(o instanceof Scene){if(this._dispatchToScene(o,t,e))break}else if(o.interactive&&(null==(i=o._hitTest)?void 0:i.call(o,e.x,e.y))){o.events.emit(t,e);break}}"inputmove"===t&&this._dispatchHover(e)}_dispatchHover(t){for(let e=this.gameObjects.length-1;e>=0;e--){const i=this.gameObjects[e];i instanceof Scene?this._hoverScene(i,t):this._hoverObject(i,t)}}_dispatchToScene(t,e,i){var s;for(let o=t.children.length-1;o>=0;o--){const n=t.children[o];if(n instanceof Scene){if(this._dispatchToScene(n,e,i))return!0}else if(n.interactive&&(null==(s=n._hitTest)?void 0:s.call(n,i.x,i.y)))return n.events.emit(e,i),!0}return!1}add(t){return t.parent=this,this.gameObjects=[...this.gameObjects,t],t}remove(t){this.gameObjects=this.gameObjects.filter((e=>e!==t))}update(t){this.gameObjects.filter((t=>t.active)).forEach((e=>e.update(t))),Tweenetik.updateAll(t)}render(){this.gameObjects.filter((t=>t.visible)).forEach((t=>t.render()))}clear(){this.gameObjects=[]}}class Cursor extends GameObject{constructor(t,e,i=null,s={}){super(t,s),this.normalShape=e,this.pressedShape=i||e,this.active=!1,this.offsetX=0,this.offsetY=0,this.isDown=!1,this.game.events.on("inputmove",(t=>{this.x=t.x,this.y=t.y})),this.game.events.on("inputdown",(()=>{this.isDown=!0})),this.game.events.on("inputup",(()=>{this.isDown=!1}))}activate(){this.active=!0,this.game.canvas.style.cursor="none"}deactivate(){this.active=!1,this.game.canvas.style.cursor="default"}update(t){super.update(t)}render(){if(!this.active)return;const t=this.isDown&&this.pressedShape?this.pressedShape:this.normalShape;t&&(t.x=this.x+this.offsetX,t.y=this.y+this.offsetY,t.draw(),super.render())}}class Game{constructor(t){this.canvas=t,this.ctx=t.getContext("2d"),this.events=new EventEmitter,this._cursor=null,this.lastTime=0,this.running=!1,this.pipeline=new Pipeline(this),Painter.init(this.ctx),this.initIO(),console.log("[Game] Constructor")}init(){console.log("[Game] Initialized")}initMouse(){Mouse.init(this)}initTouch(){Touch.init(this)}initInput(){Input.init(this)}initKeyboard(){Keys.init(this)}initIO(){this.initMouse(),this.initTouch(),this.initInput(),this.initKeyboard()}enableFluidSize(t=window){if(t===window){const t=()=>{this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight};t(),window.addEventListener("resize",t),this._fluidResizeCleanup=()=>{window.removeEventListener("resize",t)}}else{if(!("ResizeObserver"in window))return void console.warn("ResizeObserver not supported in this browser.");const e=()=>{const e=t.getBoundingClientRect();this.canvas.width=e.width,this.canvas.height=e.height},i=new ResizeObserver((()=>{e()}));i.observe(t),e(),this._fluidResizeCleanup=()=>i.disconnect()}}disableFluidSize(){this._fluidResizeCleanup&&(this._fluidResizeCleanup(),this._fluidResizeCleanup=null)}start(){this.running=!0,this.loop=this.loop.bind(this),requestAnimationFrame(this.loop),console.log("[Game] Started")}stop(){this.running=!1,console.log("[Game] Stopped")}restart(){this.pipeline.clear(),this.init(),this.start(),console.log("[Game] Restarted")}loop(t){if(!this.running)return;const e=(t-this.lastTime)/1e3;this.lastTime=t,this.update(e),this.render(),requestAnimationFrame(this.loop)}update(t){this.pipeline.update(t)}render(){this.running&&this.clear(),this.pipeline.render()}clear(){Painter.clear()}get width(){return this.canvas.width}get height(){return this.canvas.height}set backgroundColor(t){this.canvas.style.backgroundColor=t}set cursor(t){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor)),this._cursor=t,this._cursor.activate(),this.pipeline.add(t)}get cursor(){return this._cursor}resetCursor(){this._cursor&&(this._cursor.destroy(),this.pipeline.remove(this._cursor),this._cursor=null)}}class Button extends GameObject{constructor(t,e={}){const{x:i=0,y:s=0,width:o=120,height:n=40,text:r="Button",shape:a=null,label:h=null,onClick:l=null,anchor:c,padding:d,...u}=e;super(t,{anchor:c,padding:d,...u}),this.x=i,this.y=s,this.width=o,this.height=n,this.state="default",this.bg=a??new Rectangle(0,0,o,n,{fillColor:"#eee",strokeColor:"#ccc",lineWidth:2}),this.label=h??new TextShape(0,0,r,{font:"16px monospace",color:"#333",align:"center",baseline:"middle"}),this.group=new Group(i,s),this.group.add(this.bg),this.group.add(this.label),this.enableInteractivity(this.group),this.on("mouseover",this.setState.bind(this,"hover")),this.on("mouseout",this.setState.bind(this,"default")),this.on("inputdown",this.setState.bind(this,"pressed")),this.on("inputup",(()=>{"pressed"===this.state&&"function"==typeof l&&l(),this.setState("hover")})),this.setState("default")}setState(t){if(this.state!==t)switch(this.state=t,t){case"default":this.game.cursor&&setTimeout((()=>{this.game.cursor.activate()}),0),this.bg.fillColor="#eee",this.bg.strokeColor="#ccc",this.label.color="#333",this.game.canvas.style.cursor="default";break;case"hover":this.game.cursor&&this.game.cursor.deactivate(),this.bg.fillColor="#222",this.bg.strokeColor="#16F529",this.label.color="#16F529",this.game.canvas.style.cursor="pointer";break;case"pressed":this.game.cursor&&this.game.cursor.deactivate(),this.bg.fillColor="#111",this.bg.strokeColor="#00aaff",this.label.color="#00aaff",this.game.canvas.style.cursor="pointer"}}update(t){this.group.x=this.x,this.group.y=this.y}render(){this.group.draw()}}class ToggleButton extends Button{constructor(t,e={}){const i=e.onClick;super(t,{...e,onClick:()=>{this.toggled=!this.toggled,"function"==typeof e.onToggle&&e.onToggle(this.toggled),"function"==typeof i&&i(),this.refreshToggleVisual()}}),this.toggled=!!e.startToggled,this.refreshToggleVisual()}toggle(t){this.toggled=t,this.refreshToggleVisual()}refreshToggleVisual(){this.toggled?(this.bg.fillColor="#444",this.bg.strokeColor="#0f0",this.label.color="#0f0"):(this.bg.fillColor="#eee",this.bg.strokeColor="#ccc",this.label.color="#333")}setState(t){super.setState(t),this.toggled&&(this.bg.fillColor="#444",this.bg.strokeColor="#0f0",this.label.color="#0f0")}}class FPSCounter extends Text{constructor(t,e={}){super(t,"0 FPS",{x:0,y:0,font:e.font||"12px monospace",color:e.color||"#0f0",align:e.align,baseline:e.baseline,stroke:e.stroke||!1,strokeColor:e.strokeColor||"#000",lineWidth:e.lineWidth||1,anchor:e.anchor||"top-left"}),this.fps=0,this._frames=0,this._accum=0}update(t){var e;this._frames++,this._accum+=t,this._accum>=.5&&(this.fps=Math.round(this._frames/this._accum),this.text=`${this.fps} FPS`,this._frames=0,this._accum=0),null==(e=super.update)||e.call(this,t)}}class LayoutScene extends Scene{constructor(t,e={}){super(t,e),this.spacing=e.spacing??10,this.padding=e.padding??0,this.autoSize=e.autoSize??!0,this.align=e.align??"start",this.debug=e.debug??!1,this.width=0,this.height=0}render(){if(this.debug){new Rectangle(this.x+this.width/2,Math.round(this.y+this.height/2),this.width,this.height,{strokeColor:"#0f0",fillColor:"rgba(0,0,0,0.1)",lineWidth:1}).draw()}super.render()}getBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}update(t){var e;null==(e=super.update)||e.call(this,t);for(let e of this.children)e.update&&e.update(t)}}class HorizontalLayout extends LayoutScene{update(t){let e=this.padding,i=0;for(let t of this.children)i=Math.max(i,t.height??0);for(let t=0;t<this.children.length;t++){const s=this.children[t],o=this.y+(s.height??0)/2;switch(s.x=this.x+e+(s.width??0)/2,this.align){case"center":s.y=o+this.padding+(i-(s.height??0))/2;break;case"end":s.y=o+this.padding+(i-(s.height??0));break;default:s.y=o+this.padding}e+=s.width??0,t<this.children.length-1&&(e+=this.spacing)}this.autoSize&&(this.width=e+this.padding,this.height=i+2*this.padding),super.update(t)}}class VerticalLayout extends LayoutScene{update(t){let e=this.padding,i=0;for(let t of this.children)i=Math.max(i,t.width??0);for(let t=0;t<this.children.length;t++){const s=this.children[t],o=this.x+(s.width??0)/2;switch(s.y=this.y+e+(s.height??0)/2,this.align){case"center":s.x=o+this.padding+(i-(s.width??0))/2;break;case"end":s.x=o+this.padding+(i-(s.width??0));break;default:s.x=o+this.padding}e+=s.height??0,t<this.children.length-1&&(e+=this.spacing)}this.autoSize&&(this.height=e+this.padding,this.width=i+2*this.padding),super.update(t)}}class TileLayout extends LayoutScene{constructor(t,e={}){super(t,e),this.columns=e.columns??4}update(t){if(!this.children.length)return void super.update(t);const e=this.children[0].width||0;let i=this.padding,s=this.padding,o=0;for(let t=0;t<this.children.length;t++){const n=this.children[t];n.x=this.x+i+e/2,n.y=this.y+s+e/2,o++,o<this.columns?i+=e+this.spacing:(o=0,i=this.padding,s+=e+this.spacing)}if(this.autoSize){const t=Math.ceil(this.children.length/this.columns);this.width=this.columns*e+(this.columns-1)*this.spacing+2*this.padding,this.height=t*e+(t-1)*this.spacing+2*this.padding}super.update(t)}}function applyDraggable(t,e,i={}){const s=t.game;t.dragging=!1,t.dragOffset={x:0,y:0},t.target={x:e.x,y:e.y},t.friction=i.friction??.2,t.enableInteractivity(e),t.on("inputdown",(s=>{t.dragging=!0,t.dragOffset.x=e.x-s.x,t.dragOffset.y=e.y-s.y,i.onDragStart&&i.onDragStart()})),s.events.on("inputmove",(e=>{t.dragging&&(t.target.x=e.x+t.dragOffset.x,t.target.y=e.y+t.dragOffset.y)})),s.events.on("inputup",(()=>{t.dragging&&(t.dragging=!1,i.onDragEnd&&i.onDragEnd())}));const o=t.update.bind(t);t.update=function(i){t.x+=(t.target.x-e.x)*t.friction,t.y+=(t.target.y-e.y)*t.friction,o(i)}}export{Arc,Arrow,BezierShape,Button,Circle,Cloud,Cone,Cross,Cube,Cursor,Cylinder,Diamond,EventEmitter,FPSCounter,Game,GameObject,Group,Heart,Hexagon,HorizontalLayout,Input,Keys,LayoutScene,Line,Mouse,Painter,PieSlice,Pin,Pipeline,Polygon,Prism,Rectangle,Ring,Scene,Shape,ShapeGOFactory,index as Shapes,Sphere,Square,Star,StickFigure,Text,TextShape,TileLayout,ToggleButton,Touch,Transformable,Triangle,Tween,Tweenetik,VerticalLayout,applyAnchor,applyDraggable};